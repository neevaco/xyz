{"mappings":"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","sources":["runtime.ts","models/BlockchainInfo.ts","models/CurrencyInfo.ts","models/MediaVersion.ts","models/Media.ts","models/SocialMedia.ts","models/URL.ts","models/Collection.ts","models/ENS.ts","models/ErrorMessage.ts","models/MediaPreview.ts","models/TokenAttribute.ts","models/TransactionLogLine.ts","models/Transaction.ts","models/OpenSeaContract.ts","models/Token.ts","models/OwnedCollection.ts","models/Wallet.ts","models/NonFungibleToken.ts","models/SearchDocument.ts","models/TokenEvents.ts","models/TokenGate.ts","models/index.ts","apis/AlphaApi.ts","apis/DefaultApi.ts","apis/index.ts","index.ts"],"sourcesContent":["/* tslint:disable */\n/* eslint-disable */\n/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * The version of the OpenAPI document: 0.17.1\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nexport const BASE_PATH = \"https://api.n.xyz\".replace(/\\/+$/, \"\");\n\nexport interface ConfigurationParameters {\n    basePath?: string; // override base path\n    fetchApi?: FetchAPI; // override for fetch implementation\n    middleware?: Middleware[]; // middleware to apply before/after fetch requests\n    queryParamsStringify?: (params: HTTPQuery) => string; // stringify function for query strings\n    username?: string; // parameter for basic security\n    password?: string; // parameter for basic security\n    apiKey?: string | ((name: string) => string); // parameter for apiKey security\n    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string | Promise<string>); // parameter for oauth2 security\n    headers?: HTTPHeaders; //header params we want to use on every request\n    credentials?: RequestCredentials; //value for the credentials param we want to use on each request\n}\n\nexport class Configuration {\n    constructor(private configuration: ConfigurationParameters = {}) {}\n\n    set config(configuration: Configuration) {\n        this.configuration = configuration;\n    }\n\n    get basePath(): string {\n        return this.configuration.basePath != null ? this.configuration.basePath : BASE_PATH;\n    }\n\n    get fetchApi(): FetchAPI | undefined {\n        return this.configuration.fetchApi;\n    }\n\n    get middleware(): Middleware[] {\n        return this.configuration.middleware || [];\n    }\n\n    get queryParamsStringify(): (params: HTTPQuery) => string {\n        return this.configuration.queryParamsStringify || querystring;\n    }\n\n    get username(): string | undefined {\n        return this.configuration.username;\n    }\n\n    get password(): string | undefined {\n        return this.configuration.password;\n    }\n\n    get apiKey(): ((name: string) => string) | undefined {\n        const apiKey = this.configuration.apiKey;\n        if (apiKey) {\n            return typeof apiKey === 'function' ? apiKey : () => apiKey;\n        }\n        return undefined;\n    }\n\n    get accessToken(): ((name?: string, scopes?: string[]) => string | Promise<string>) | undefined {\n        const accessToken = this.configuration.accessToken;\n        if (accessToken) {\n            return typeof accessToken === 'function' ? accessToken : async () => accessToken;\n        }\n        return undefined;\n    }\n\n    get headers(): HTTPHeaders | undefined {\n        return this.configuration.headers;\n    }\n\n    get credentials(): RequestCredentials | undefined {\n        return this.configuration.credentials;\n    }\n}\n\nexport const DefaultConfig = new Configuration();\n\n/**\n * This is the base class for all generated API classes.\n */\nexport class BaseAPI {\n\n    private middleware: Middleware[];\n\n    constructor(protected configuration = DefaultConfig) {\n        this.middleware = configuration.middleware;\n    }\n\n    withMiddleware<T extends BaseAPI>(this: T, ...middlewares: Middleware[]) {\n        const next = this.clone<T>();\n        next.middleware = next.middleware.concat(...middlewares);\n        return next;\n    }\n\n    withPreMiddleware<T extends BaseAPI>(this: T, ...preMiddlewares: Array<Middleware['pre']>) {\n        const middlewares = preMiddlewares.map((pre) => ({ pre }));\n        return this.withMiddleware<T>(...middlewares);\n    }\n\n    withPostMiddleware<T extends BaseAPI>(this: T, ...postMiddlewares: Array<Middleware['post']>) {\n        const middlewares = postMiddlewares.map((post) => ({ post }));\n        return this.withMiddleware<T>(...middlewares);\n    }\n\n    protected async request(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction): Promise<Response> {\n        const { url, init } = await this.createFetchParams(context, initOverrides);\n        const response = await this.fetchApi(url, init);\n        if (response.status >= 200 && response.status < 300) {\n            return response;\n        }\n        throw new ResponseError(response, 'Response returned an error code');\n    }\n\n    private async createFetchParams(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction) {\n        let url = this.configuration.basePath + context.path;\n        if (context.query !== undefined && Object.keys(context.query).length !== 0) {\n            // only add the querystring to the URL if there are query parameters.\n            // this is done to avoid urls ending with a \"?\" character which buggy webservers\n            // do not handle correctly sometimes.\n            url += '?' + this.configuration.queryParamsStringify(context.query);\n        }\n\n        const headers = Object.assign({}, this.configuration.headers, context.headers);\n        Object.keys(headers).forEach(key => headers[key] === undefined ? delete headers[key] : {});\n\n        const initOverrideFn =\n            typeof initOverrides === \"function\"\n                ? initOverrides\n                : async () => initOverrides;\n\n        const initParams = {\n            method: context.method,\n            headers,\n            body: context.body,\n            credentials: this.configuration.credentials,\n        };\n\n        const overridedInit: RequestInit = {\n            ...initParams,\n            ...(await initOverrideFn({\n                init: initParams,\n                context,\n            }))\n        }\n\n        const init: RequestInit = {\n            ...overridedInit,\n            body:\n                isFormData(overridedInit.body) ||\n                overridedInit.body instanceof URLSearchParams ||\n                isBlob(overridedInit.body)\n                    ? overridedInit.body\n                    : JSON.stringify(overridedInit.body),\n        };\n\n        return { url, init };\n    }\n\n    private fetchApi = async (url: string, init: RequestInit) => {\n        let fetchParams = { url, init };\n        for (const middleware of this.middleware) {\n            if (middleware.pre) {\n                fetchParams = await middleware.pre({\n                    fetch: this.fetchApi,\n                    ...fetchParams,\n                }) || fetchParams;\n            }\n        }\n        let response = undefined;\n        try {\n            response = await (this.configuration.fetchApi || fetch)(fetchParams.url, fetchParams.init);\n        } catch (e) {\n            for (const middleware of this.middleware) {\n                if (middleware.onError) {\n                    response = await middleware.onError({\n                        fetch: this.fetchApi,\n                        url: fetchParams.url,\n                        init: fetchParams.init,\n                        error: e,\n                        response: response ? response.clone() : undefined,\n                    }) || response;\n                }\n            }\n            if (response !== undefined) {\n                throw new FetchError(e, 'The request failed and the interceptors did not return an alternative response');\n            }\n        }\n        for (const middleware of this.middleware) {\n            if (middleware.post) {\n                response = await middleware.post({\n                    fetch: this.fetchApi,\n                    url: fetchParams.url,\n                    init: fetchParams.init,\n                    response: response.clone(),\n                }) || response;\n            }\n        }\n        return response;\n    }\n\n    /**\n     * Create a shallow clone of `this` by constructing a new instance\n     * and then shallow cloning data members.\n     */\n    private clone<T extends BaseAPI>(this: T): T {\n        const constructor = this.constructor as any;\n        const next = new constructor(this.configuration);\n        next.middleware = this.middleware.slice();\n        return next;\n    }\n};\n\nfunction isBlob(value: any): value is Blob {\n    return typeof Blob !== 'undefined' && value instanceof Blob\n}\n\nfunction isFormData(value: any): value is FormData {\n    return typeof FormData !== \"undefined\" && value instanceof FormData\n}\n\nexport class ResponseError extends Error {\n    name: \"ResponseError\" = \"ResponseError\";\n    constructor(public response: Response, msg?: string) {\n        super(msg);\n    }\n}\n\nexport class FetchError extends Error {\n    name: \"FetchError\" = \"FetchError\";\n    constructor(public cause: unknown, msg?: string) {\n        super(msg);\n    }\n}\n\nexport class RequiredError extends Error {\n    name: \"RequiredError\" = \"RequiredError\";\n    constructor(public field: string, msg?: string) {\n        super(msg);\n    }\n}\n\nexport const COLLECTION_FORMATS = {\n    csv: \",\",\n    ssv: \" \",\n    tsv: \"\\t\",\n    pipes: \"|\",\n};\n\nexport type FetchAPI = WindowOrWorkerGlobalScope['fetch'];\n\nexport type Json = any;\nexport type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD';\nexport type HTTPHeaders = { [key: string]: string };\nexport type HTTPQuery = { [key: string]: string | number | null | boolean | Array<string | number | null | boolean> | Set<string | number | null | boolean> | HTTPQuery };\nexport type HTTPBody = Json | FormData | URLSearchParams;\nexport type HTTPRequestInit = { headers?: HTTPHeaders; method: HTTPMethod; credentials?: RequestCredentials; body?: HTTPBody }\nexport type ModelPropertyNaming = 'camelCase' | 'snake_case' | 'PascalCase' | 'original';\n\nexport type InitOverrideFunction = (requestContext: { init: HTTPRequestInit, context: RequestOpts }) => Promise<RequestInit>\n\nexport interface FetchParams {\n    url: string;\n    init: RequestInit;\n}\n\nexport interface RequestOpts {\n    path: string;\n    method: HTTPMethod;\n    headers: HTTPHeaders;\n    query?: HTTPQuery;\n    body?: HTTPBody;\n}\n\nexport function exists(json: any, key: string) {\n    const value = json[key];\n    return value !== null && value !== undefined;\n}\n\nexport function querystring(params: HTTPQuery, prefix: string = ''): string {\n    return Object.keys(params)\n        .map(key => querystringSingleKey(key, params[key], prefix))\n        .filter(part => part.length > 0)\n        .join('&');\n}\n\nfunction querystringSingleKey(key: string, value: string | number | null | undefined | boolean | Array<string | number | null | boolean> | Set<string | number | null | boolean> | HTTPQuery, keyPrefix: string = ''): string {\n    const fullKey = keyPrefix + (keyPrefix.length ? `[${key}]` : key);\n    if (value instanceof Array) {\n        const multiValue = value.map(singleValue => encodeURIComponent(String(singleValue)))\n            .join(`&${encodeURIComponent(fullKey)}=`);\n        return `${encodeURIComponent(fullKey)}=${multiValue}`;\n    }\n    if (value instanceof Set) {\n        const valueAsArray = Array.from(value);\n        return querystringSingleKey(key, valueAsArray, keyPrefix);\n    }\n    if (value instanceof Date) {\n        return `${encodeURIComponent(fullKey)}=${encodeURIComponent(value.toISOString())}`;\n    }\n    if (value instanceof Object) {\n        return querystring(value as HTTPQuery, fullKey);\n    }\n    return `${encodeURIComponent(fullKey)}=${encodeURIComponent(String(value))}`;\n}\n\nexport function mapValues(data: any, fn: (item: any) => any) {\n  return Object.keys(data).reduce(\n    (acc, key) => ({ ...acc, [key]: fn(data[key]) }),\n    {}\n  );\n}\n\nexport function canConsumeForm(consumes: Consume[]): boolean {\n    for (const consume of consumes) {\n        if ('multipart/form-data' === consume.contentType) {\n            return true;\n        }\n    }\n    return false;\n}\n\nexport interface Consume {\n    contentType: string\n}\n\nexport interface RequestContext {\n    fetch: FetchAPI;\n    url: string;\n    init: RequestInit;\n}\n\nexport interface ResponseContext {\n    fetch: FetchAPI;\n    url: string;\n    init: RequestInit;\n    response: Response;\n}\n\nexport interface ErrorContext {\n    fetch: FetchAPI;\n    url: string;\n    init: RequestInit;\n    error: unknown;\n    response?: Response;\n}\n\nexport interface Middleware {\n    pre?(context: RequestContext): Promise<FetchParams | void>;\n    post?(context: ResponseContext): Promise<Response | void>;\n    onError?(context: ErrorContext): Promise<Response | void>;\n}\n\nexport interface ApiResponse<T> {\n    raw: Response;\n    value(): Promise<T>;\n}\n\nexport interface ResponseTransformer<T> {\n    (json: any): T;\n}\n\nexport class JSONApiResponse<T> {\n    constructor(public raw: Response, private transformer: ResponseTransformer<T> = (jsonValue: any) => jsonValue) {}\n\n    async value(): Promise<T> {\n        return this.transformer(await this.raw.json());\n    }\n}\n\nexport class VoidApiResponse {\n    constructor(public raw: Response) {}\n\n    async value(): Promise<void> {\n        return undefined;\n    }\n}\n\nexport class BlobApiResponse {\n    constructor(public raw: Response) {}\n\n    async value(): Promise<Blob> {\n        return await this.raw.blob();\n    };\n}\n\nexport class TextApiResponse {\n    constructor(public raw: Response) {}\n\n    async value(): Promise<string> {\n        return await this.raw.text();\n    };\n}\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * The version of the OpenAPI document: 0.17.1\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { exists, mapValues } from '../runtime';\n/**\n * \n * @export\n * @interface BlockchainInfo\n */\nexport interface BlockchainInfo {\n    /**\n     * The name of a given chain. This is often a canonical name since a protocol may have multiple chains.\n     * @type {string}\n     * @memberof BlockchainInfo\n     */\n    name?: string;\n    /**\n     * The short-hand name for a given chain. Multiple chains (e.g. mainnet and a testnet) may have the same name.\n     * @type {string}\n     * @memberof BlockchainInfo\n     */\n    shortName?: string;\n    /**\n     * A CAIP-2 compliant chain ID. This ID is designed to provide a unique identifier for a given chain.\n     * @type {string}\n     * @memberof BlockchainInfo\n     */\n    chainID?: string;\n    /**\n     * An ID used for a chain in a given ecosystem. This ID is not canonical and may collide with other chains. Do not use this value as a unique identifier.\n     * @type {string}\n     * @memberof BlockchainInfo\n     */\n    shortChainID?: string;\n}\n\n/**\n * Check if a given object implements the BlockchainInfo interface.\n */\nexport function instanceOfBlockchainInfo(value: object): boolean {\n    let isInstance = true;\n\n    return isInstance;\n}\n\nexport function BlockchainInfoFromJSON(json: any): BlockchainInfo {\n    return BlockchainInfoFromJSONTyped(json, false);\n}\n\nexport function BlockchainInfoFromJSONTyped(json: any, ignoreDiscriminator: boolean): BlockchainInfo {\n    if ((json === undefined) || (json === null)) {\n        return json;\n    }\n    return {\n        \n        'name': !exists(json, 'name') ? undefined : json['name'],\n        'shortName': !exists(json, 'shortName') ? undefined : json['shortName'],\n        'chainID': !exists(json, 'chainID') ? undefined : json['chainID'],\n        'shortChainID': !exists(json, 'shortChainID') ? undefined : json['shortChainID'],\n    };\n}\n\nexport function BlockchainInfoToJSON(value?: BlockchainInfo | null): any {\n    if (value === undefined) {\n        return undefined;\n    }\n    if (value === null) {\n        return null;\n    }\n    return {\n        \n        'name': value.name,\n        'shortName': value.shortName,\n        'chainID': value.chainID,\n        'shortChainID': value.shortChainID,\n    };\n}\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * The version of the OpenAPI document: 0.17.1\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { exists, mapValues } from '../runtime';\n/**\n * \n * @export\n * @interface CurrencyInfo\n */\nexport interface CurrencyInfo {\n    /**\n     * Transaction value as a string-encoded bigint in the base unit for a given blockchain (e.g. wei for Ethereum) or fiat currency (e.g. US Dollars).\n     * @type {string}\n     * @memberof CurrencyInfo\n     */\n    value?: string;\n    /**\n     * Transaction value as a float representing the amount of tokens, e.g. 0.89 would be 89% of a token.\n     * @type {number}\n     * @memberof CurrencyInfo\n     */\n    tokenValue?: number;\n    /**\n     * The total value of this token in fiat currency.\n     * @type {Array<CurrencyInfo>}\n     * @memberof CurrencyInfo\n     */\n    fiat?: Array<CurrencyInfo>;\n    /**\n     * A formatted, human-friendly representation of the transaction value, e.g. the value in Ether, possibly with localized thousands separator and radix character.\n     * @type {string}\n     * @memberof CurrencyInfo\n     */\n    pretty?: string;\n    /**\n     * The base value for a given token. For Ethereum this would be 18. This would yield an equation such as 890000000000000000wei / 10^18 = 0.89 ETH.\n     * @type {number}\n     * @memberof CurrencyInfo\n     */\n    decimals?: number;\n    /**\n     * \n     * @type {string}\n     * @memberof CurrencyInfo\n     */\n    symbol?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof CurrencyInfo\n     */\n    contractAddress?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof CurrencyInfo\n     */\n    name?: string;\n}\n\n/**\n * Check if a given object implements the CurrencyInfo interface.\n */\nexport function instanceOfCurrencyInfo(value: object): boolean {\n    let isInstance = true;\n\n    return isInstance;\n}\n\nexport function CurrencyInfoFromJSON(json: any): CurrencyInfo {\n    return CurrencyInfoFromJSONTyped(json, false);\n}\n\nexport function CurrencyInfoFromJSONTyped(json: any, ignoreDiscriminator: boolean): CurrencyInfo {\n    if ((json === undefined) || (json === null)) {\n        return json;\n    }\n    return {\n        \n        'value': !exists(json, 'value') ? undefined : json['value'],\n        'tokenValue': !exists(json, 'tokenValue') ? undefined : json['tokenValue'],\n        'fiat': !exists(json, 'fiat') ? undefined : ((json['fiat'] as Array<any>).map(CurrencyInfoFromJSON)),\n        'pretty': !exists(json, 'pretty') ? undefined : json['pretty'],\n        'decimals': !exists(json, 'decimals') ? undefined : json['decimals'],\n        'symbol': !exists(json, 'symbol') ? undefined : json['symbol'],\n        'contractAddress': !exists(json, 'contractAddress') ? undefined : json['contractAddress'],\n        'name': !exists(json, 'name') ? undefined : json['name'],\n    };\n}\n\nexport function CurrencyInfoToJSON(value?: CurrencyInfo | null): any {\n    if (value === undefined) {\n        return undefined;\n    }\n    if (value === null) {\n        return null;\n    }\n    return {\n        \n        'value': value.value,\n        'tokenValue': value.tokenValue,\n        'fiat': value.fiat === undefined ? undefined : ((value.fiat as Array<any>).map(CurrencyInfoToJSON)),\n        'pretty': value.pretty,\n        'decimals': value.decimals,\n        'symbol': value.symbol,\n        'contractAddress': value.contractAddress,\n        'name': value.name,\n    };\n}\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * The version of the OpenAPI document: 0.17.1\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { exists, mapValues } from '../runtime';\n/**\n * \n * @export\n * @interface MediaVersion\n */\nexport interface MediaVersion {\n    /**\n     * \n     * @type {string}\n     * @memberof MediaVersion\n     */\n    kind?: MediaVersionKindEnum;\n    /**\n     * \n     * @type {string}\n     * @memberof MediaVersion\n     */\n    format?: string;\n    /**\n     * \n     * @type {number}\n     * @memberof MediaVersion\n     */\n    width?: number;\n    /**\n     * \n     * @type {number}\n     * @memberof MediaVersion\n     */\n    height?: number;\n    /**\n     * \n     * @type {number}\n     * @memberof MediaVersion\n     */\n    numBytes?: number;\n    /**\n     * If a video, length of video in ISO 8601 duration format.\n     * @type {string}\n     * @memberof MediaVersion\n     */\n    duration?: string;\n}\n\n\n/**\n * @export\n */\nexport const MediaVersionKindEnum = {\n    Video: 'video',\n    Image: 'image',\n    Raw: 'raw',\n    Audio: 'audio'\n} as const;\nexport type MediaVersionKindEnum = typeof MediaVersionKindEnum[keyof typeof MediaVersionKindEnum];\n\n\n/**\n * Check if a given object implements the MediaVersion interface.\n */\nexport function instanceOfMediaVersion(value: object): boolean {\n    let isInstance = true;\n\n    return isInstance;\n}\n\nexport function MediaVersionFromJSON(json: any): MediaVersion {\n    return MediaVersionFromJSONTyped(json, false);\n}\n\nexport function MediaVersionFromJSONTyped(json: any, ignoreDiscriminator: boolean): MediaVersion {\n    if ((json === undefined) || (json === null)) {\n        return json;\n    }\n    return {\n        \n        'kind': !exists(json, 'kind') ? undefined : json['kind'],\n        'format': !exists(json, 'format') ? undefined : json['format'],\n        'width': !exists(json, 'width') ? undefined : json['width'],\n        'height': !exists(json, 'height') ? undefined : json['height'],\n        'numBytes': !exists(json, 'numBytes') ? undefined : json['numBytes'],\n        'duration': !exists(json, 'duration') ? undefined : json['duration'],\n    };\n}\n\nexport function MediaVersionToJSON(value?: MediaVersion | null): any {\n    if (value === undefined) {\n        return undefined;\n    }\n    if (value === null) {\n        return null;\n    }\n    return {\n        \n        'kind': value.kind,\n        'format': value.format,\n        'width': value.width,\n        'height': value.height,\n        'numBytes': value.numBytes,\n        'duration': value.duration,\n    };\n}\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * The version of the OpenAPI document: 0.17.1\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { exists, mapValues } from '../runtime';\nimport type { MediaVersion } from './MediaVersion';\nimport {\n    MediaVersionFromJSON,\n    MediaVersionFromJSONTyped,\n    MediaVersionToJSON,\n} from './MediaVersion';\n\n/**\n * \n * @export\n * @interface Media\n */\nexport interface Media {\n    /**\n     * \n     * @type {string}\n     * @memberof Media\n     */\n    key: string;\n    /**\n     * URI for the image asset.\n     * @type {string}\n     * @memberof Media\n     */\n    uRI?: string;\n    /**\n     * \n     * @type {Array<MediaVersion>}\n     * @memberof Media\n     */\n    version?: Array<MediaVersion>;\n}\n\n/**\n * Check if a given object implements the Media interface.\n */\nexport function instanceOfMedia(value: object): boolean {\n    let isInstance = true;\n    isInstance = isInstance && \"key\" in value;\n\n    return isInstance;\n}\n\nexport function MediaFromJSON(json: any): Media {\n    return MediaFromJSONTyped(json, false);\n}\n\nexport function MediaFromJSONTyped(json: any, ignoreDiscriminator: boolean): Media {\n    if ((json === undefined) || (json === null)) {\n        return json;\n    }\n    return {\n        \n        'key': json['key'],\n        'uRI': !exists(json, 'URI') ? undefined : json['URI'],\n        'version': !exists(json, 'version') ? undefined : ((json['version'] as Array<any>).map(MediaVersionFromJSON)),\n    };\n}\n\nexport function MediaToJSON(value?: Media | null): any {\n    if (value === undefined) {\n        return undefined;\n    }\n    if (value === null) {\n        return null;\n    }\n    return {\n        \n        'key': value.key,\n        'URI': value.uRI,\n        'version': value.version === undefined ? undefined : ((value.version as Array<any>).map(MediaVersionToJSON)),\n    };\n}\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * The version of the OpenAPI document: 0.17.1\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { exists, mapValues } from '../runtime';\n/**\n * \n * @export\n * @interface SocialMedia\n */\nexport interface SocialMedia {\n    /**\n     * \n     * @type {string}\n     * @memberof SocialMedia\n     */\n    network?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof SocialMedia\n     */\n    username?: string;\n}\n\n/**\n * Check if a given object implements the SocialMedia interface.\n */\nexport function instanceOfSocialMedia(value: object): boolean {\n    let isInstance = true;\n\n    return isInstance;\n}\n\nexport function SocialMediaFromJSON(json: any): SocialMedia {\n    return SocialMediaFromJSONTyped(json, false);\n}\n\nexport function SocialMediaFromJSONTyped(json: any, ignoreDiscriminator: boolean): SocialMedia {\n    if ((json === undefined) || (json === null)) {\n        return json;\n    }\n    return {\n        \n        'network': !exists(json, 'network') ? undefined : json['network'],\n        'username': !exists(json, 'username') ? undefined : json['username'],\n    };\n}\n\nexport function SocialMediaToJSON(value?: SocialMedia | null): any {\n    if (value === undefined) {\n        return undefined;\n    }\n    if (value === null) {\n        return null;\n    }\n    return {\n        \n        'network': value.network,\n        'username': value.username,\n    };\n}\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * The version of the OpenAPI document: 0.17.1\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { exists, mapValues } from '../runtime';\n/**\n * \n * @export\n * @interface URL\n */\nexport interface URL {\n    /**\n     * Human-readable name of the site.\n     * @type {string}\n     * @memberof URL\n     */\n    name?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof URL\n     */\n    url?: string;\n}\n\n/**\n * Check if a given object implements the URL interface.\n */\nexport function instanceOfURL(value: object): boolean {\n    let isInstance = true;\n\n    return isInstance;\n}\n\nexport function URLFromJSON(json: any): URL {\n    return URLFromJSONTyped(json, false);\n}\n\nexport function URLFromJSONTyped(json: any, ignoreDiscriminator: boolean): URL {\n    if ((json === undefined) || (json === null)) {\n        return json;\n    }\n    return {\n        \n        'name': !exists(json, 'name') ? undefined : json['name'],\n        'url': !exists(json, 'url') ? undefined : json['url'],\n    };\n}\n\nexport function URLToJSON(value?: URL | null): any {\n    if (value === undefined) {\n        return undefined;\n    }\n    if (value === null) {\n        return null;\n    }\n    return {\n        \n        'name': value.name,\n        'url': value.url,\n    };\n}\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * The version of the OpenAPI document: 0.17.1\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { exists, mapValues } from '../runtime';\nimport type { BlockchainInfo } from './BlockchainInfo';\nimport {\n    BlockchainInfoFromJSON,\n    BlockchainInfoFromJSONTyped,\n    BlockchainInfoToJSON,\n} from './BlockchainInfo';\nimport type { CurrencyInfo } from './CurrencyInfo';\nimport {\n    CurrencyInfoFromJSON,\n    CurrencyInfoFromJSONTyped,\n    CurrencyInfoToJSON,\n} from './CurrencyInfo';\nimport type { Media } from './Media';\nimport {\n    MediaFromJSON,\n    MediaFromJSONTyped,\n    MediaToJSON,\n} from './Media';\nimport type { SocialMedia } from './SocialMedia';\nimport {\n    SocialMediaFromJSON,\n    SocialMediaFromJSONTyped,\n    SocialMediaToJSON,\n} from './SocialMedia';\nimport type { URL } from './URL';\nimport {\n    URLFromJSON,\n    URLFromJSONTyped,\n    URLToJSON,\n} from './URL';\n\n/**\n * \n * @export\n * @interface Collection\n */\nexport interface Collection {\n    /**\n     * \n     * @type {BlockchainInfo}\n     * @memberof Collection\n     */\n    blockchain: BlockchainInfo;\n    /**\n     * Address of the contract that minted this NFT.\n     * @type {string}\n     * @memberof Collection\n     */\n    contractAddress: string;\n    /**\n     * \n     * @type {string}\n     * @memberof Collection\n     */\n    symbol?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof Collection\n     */\n    slug?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof Collection\n     */\n    name?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof Collection\n     */\n    description?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof Collection\n     */\n    shortDescription?: string;\n    /**\n     * Timestamp of creation of this contract in RFC 3339.\n     * @type {Date}\n     * @memberof Collection\n     */\n    createdDate?: Date | null;\n    /**\n     * \n     * @type {CurrencyInfo}\n     * @memberof Collection\n     */\n    floorPrice?: CurrencyInfo;\n    /**\n     * \n     * @type {Media}\n     * @memberof Collection\n     */\n    bannerImage?: Media;\n    /**\n     * \n     * @type {Media}\n     * @memberof Collection\n     */\n    featuredImage?: Media;\n    /**\n     * \n     * @type {Array<URL>}\n     * @memberof Collection\n     */\n    urls?: Array<URL>;\n    /**\n     * \n     * @type {Array<SocialMedia>}\n     * @memberof Collection\n     */\n    socialMedia?: Array<SocialMedia>;\n}\n\n/**\n * Check if a given object implements the Collection interface.\n */\nexport function instanceOfCollection(value: object): boolean {\n    let isInstance = true;\n    isInstance = isInstance && \"blockchain\" in value;\n    isInstance = isInstance && \"contractAddress\" in value;\n\n    return isInstance;\n}\n\nexport function CollectionFromJSON(json: any): Collection {\n    return CollectionFromJSONTyped(json, false);\n}\n\nexport function CollectionFromJSONTyped(json: any, ignoreDiscriminator: boolean): Collection {\n    if ((json === undefined) || (json === null)) {\n        return json;\n    }\n    return {\n        \n        'blockchain': BlockchainInfoFromJSON(json['blockchain']),\n        'contractAddress': json['contractAddress'],\n        'symbol': !exists(json, 'symbol') ? undefined : json['symbol'],\n        'slug': !exists(json, 'slug') ? undefined : json['slug'],\n        'name': !exists(json, 'name') ? undefined : json['name'],\n        'description': !exists(json, 'description') ? undefined : json['description'],\n        'shortDescription': !exists(json, 'shortDescription') ? undefined : json['shortDescription'],\n        'createdDate': !exists(json, 'createdDate') ? undefined : (json['createdDate'] === null ? null : new Date(json['createdDate'])),\n        'floorPrice': !exists(json, 'floorPrice') ? undefined : CurrencyInfoFromJSON(json['floorPrice']),\n        'bannerImage': !exists(json, 'bannerImage') ? undefined : MediaFromJSON(json['bannerImage']),\n        'featuredImage': !exists(json, 'featuredImage') ? undefined : MediaFromJSON(json['featuredImage']),\n        'urls': !exists(json, 'urls') ? undefined : ((json['urls'] as Array<any>).map(URLFromJSON)),\n        'socialMedia': !exists(json, 'socialMedia') ? undefined : ((json['socialMedia'] as Array<any>).map(SocialMediaFromJSON)),\n    };\n}\n\nexport function CollectionToJSON(value?: Collection | null): any {\n    if (value === undefined) {\n        return undefined;\n    }\n    if (value === null) {\n        return null;\n    }\n    return {\n        \n        'blockchain': BlockchainInfoToJSON(value.blockchain),\n        'contractAddress': value.contractAddress,\n        'symbol': value.symbol,\n        'slug': value.slug,\n        'name': value.name,\n        'description': value.description,\n        'shortDescription': value.shortDescription,\n        'createdDate': value.createdDate === undefined ? undefined : (value.createdDate === null ? null : value.createdDate.toISOString()),\n        'floorPrice': CurrencyInfoToJSON(value.floorPrice),\n        'bannerImage': MediaToJSON(value.bannerImage),\n        'featuredImage': MediaToJSON(value.featuredImage),\n        'urls': value.urls === undefined ? undefined : ((value.urls as Array<any>).map(URLToJSON)),\n        'socialMedia': value.socialMedia === undefined ? undefined : ((value.socialMedia as Array<any>).map(SocialMediaToJSON)),\n    };\n}\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * The version of the OpenAPI document: 0.17.1\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { exists, mapValues } from '../runtime';\n/**\n * \n * @export\n * @interface ENS\n */\nexport interface ENS {\n    /**\n     * The ENS or domain name.\n     * @type {string}\n     * @memberof ENS\n     */\n    name?: string;\n    /**\n     * The address the ENS record points to.\n     * @type {string}\n     * @memberof ENS\n     */\n    pointsTo?: string;\n    /**\n     * Date the ENS registration expires.\n     * @type {Date}\n     * @memberof ENS\n     */\n    expires?: Date | null;\n    /**\n     * A wallet address can have multiple ENS records. The primary ENS name represents a \"cross-platform web3 username and profile.\" A wallet address can only have one primary name, and it can change at any time.\n     * @type {boolean}\n     * @memberof ENS\n     */\n    isPrimary?: boolean;\n}\n\n/**\n * Check if a given object implements the ENS interface.\n */\nexport function instanceOfENS(value: object): boolean {\n    let isInstance = true;\n\n    return isInstance;\n}\n\nexport function ENSFromJSON(json: any): ENS {\n    return ENSFromJSONTyped(json, false);\n}\n\nexport function ENSFromJSONTyped(json: any, ignoreDiscriminator: boolean): ENS {\n    if ((json === undefined) || (json === null)) {\n        return json;\n    }\n    return {\n        \n        'name': !exists(json, 'name') ? undefined : json['name'],\n        'pointsTo': !exists(json, 'pointsTo') ? undefined : json['pointsTo'],\n        'expires': !exists(json, 'expires') ? undefined : (json['expires'] === null ? null : new Date(json['expires'])),\n        'isPrimary': !exists(json, 'isPrimary') ? undefined : json['isPrimary'],\n    };\n}\n\nexport function ENSToJSON(value?: ENS | null): any {\n    if (value === undefined) {\n        return undefined;\n    }\n    if (value === null) {\n        return null;\n    }\n    return {\n        \n        'name': value.name,\n        'pointsTo': value.pointsTo,\n        'expires': value.expires === undefined ? undefined : (value.expires === null ? null : value.expires.toISOString()),\n        'isPrimary': value.isPrimary,\n    };\n}\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * The version of the OpenAPI document: 0.17.1\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { exists, mapValues } from '../runtime';\n/**\n * \n * @export\n * @interface ErrorMessage\n */\nexport interface ErrorMessage {\n    /**\n     * \n     * @type {string}\n     * @memberof ErrorMessage\n     */\n    error: string;\n}\n\n/**\n * Check if a given object implements the ErrorMessage interface.\n */\nexport function instanceOfErrorMessage(value: object): boolean {\n    let isInstance = true;\n    isInstance = isInstance && \"error\" in value;\n\n    return isInstance;\n}\n\nexport function ErrorMessageFromJSON(json: any): ErrorMessage {\n    return ErrorMessageFromJSONTyped(json, false);\n}\n\nexport function ErrorMessageFromJSONTyped(json: any, ignoreDiscriminator: boolean): ErrorMessage {\n    if ((json === undefined) || (json === null)) {\n        return json;\n    }\n    return {\n        \n        'error': json['error'],\n    };\n}\n\nexport function ErrorMessageToJSON(value?: ErrorMessage | null): any {\n    if (value === undefined) {\n        return undefined;\n    }\n    if (value === null) {\n        return null;\n    }\n    return {\n        \n        'error': value.error,\n    };\n}\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * The version of the OpenAPI document: 0.17.1\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { exists, mapValues } from '../runtime';\n/**\n * \n * @export\n * @interface MediaPreview\n */\nexport interface MediaPreview {\n    /**\n     * URI for the image asset.\n     * @type {string}\n     * @memberof MediaPreview\n     */\n    uRI?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof MediaPreview\n     */\n    kind?: MediaPreviewKindEnum;\n    /**\n     * \n     * @type {string}\n     * @memberof MediaPreview\n     */\n    format?: string;\n    /**\n     * The image's approximate height in pixels.\n     * @type {number}\n     * @memberof MediaPreview\n     */\n    height?: number;\n    /**\n     * The image's approximate width in pixels.\n     * @type {number}\n     * @memberof MediaPreview\n     */\n    width?: number;\n    /**\n     * If a video, length of video in ISO 8601 duration format.\n     * @type {string}\n     * @memberof MediaPreview\n     */\n    duration?: string;\n}\n\n\n/**\n * @export\n */\nexport const MediaPreviewKindEnum = {\n    Video: 'video',\n    Image: 'image',\n    Raw: 'raw',\n    Audio: 'audio'\n} as const;\nexport type MediaPreviewKindEnum = typeof MediaPreviewKindEnum[keyof typeof MediaPreviewKindEnum];\n\n\n/**\n * Check if a given object implements the MediaPreview interface.\n */\nexport function instanceOfMediaPreview(value: object): boolean {\n    let isInstance = true;\n\n    return isInstance;\n}\n\nexport function MediaPreviewFromJSON(json: any): MediaPreview {\n    return MediaPreviewFromJSONTyped(json, false);\n}\n\nexport function MediaPreviewFromJSONTyped(json: any, ignoreDiscriminator: boolean): MediaPreview {\n    if ((json === undefined) || (json === null)) {\n        return json;\n    }\n    return {\n        \n        'uRI': !exists(json, 'URI') ? undefined : json['URI'],\n        'kind': !exists(json, 'kind') ? undefined : json['kind'],\n        'format': !exists(json, 'format') ? undefined : json['format'],\n        'height': !exists(json, 'height') ? undefined : json['height'],\n        'width': !exists(json, 'width') ? undefined : json['width'],\n        'duration': !exists(json, 'duration') ? undefined : json['duration'],\n    };\n}\n\nexport function MediaPreviewToJSON(value?: MediaPreview | null): any {\n    if (value === undefined) {\n        return undefined;\n    }\n    if (value === null) {\n        return null;\n    }\n    return {\n        \n        'URI': value.uRI,\n        'kind': value.kind,\n        'format': value.format,\n        'height': value.height,\n        'width': value.width,\n        'duration': value.duration,\n    };\n}\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * The version of the OpenAPI document: 0.17.1\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { exists, mapValues } from '../runtime';\n/**\n * \n * @export\n * @interface TokenAttribute\n */\nexport interface TokenAttribute {\n    /**\n     * The key or kind of trait.\n     * @type {string}\n     * @memberof TokenAttribute\n     */\n    traitType?: string;\n    /**\n     * A distinct attribute belonging to a particular type of trait.\n     * @type {string}\n     * @memberof TokenAttribute\n     */\n    value?: string;\n}\n\n/**\n * Check if a given object implements the TokenAttribute interface.\n */\nexport function instanceOfTokenAttribute(value: object): boolean {\n    let isInstance = true;\n\n    return isInstance;\n}\n\nexport function TokenAttributeFromJSON(json: any): TokenAttribute {\n    return TokenAttributeFromJSONTyped(json, false);\n}\n\nexport function TokenAttributeFromJSONTyped(json: any, ignoreDiscriminator: boolean): TokenAttribute {\n    if ((json === undefined) || (json === null)) {\n        return json;\n    }\n    return {\n        \n        'traitType': !exists(json, 'traitType') ? undefined : json['traitType'],\n        'value': !exists(json, 'value') ? undefined : json['value'],\n    };\n}\n\nexport function TokenAttributeToJSON(value?: TokenAttribute | null): any {\n    if (value === undefined) {\n        return undefined;\n    }\n    if (value === null) {\n        return null;\n    }\n    return {\n        \n        'traitType': value.traitType,\n        'value': value.value,\n    };\n}\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * The version of the OpenAPI document: 0.17.1\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { exists, mapValues } from '../runtime';\nimport type { CurrencyInfo } from './CurrencyInfo';\nimport {\n    CurrencyInfoFromJSON,\n    CurrencyInfoFromJSONTyped,\n    CurrencyInfoToJSON,\n} from './CurrencyInfo';\n\n/**\n * \n * @export\n * @interface TransactionLogLine\n */\nexport interface TransactionLogLine {\n    /**\n     * When the value is true, it indicates that a token has been burned, and this transaction corresponds to the burn.\n     * @type {boolean}\n     * @memberof TransactionLogLine\n     */\n    burned?: boolean | null;\n    /**\n     * When the value is true, it indicates this is the transaction representing a token minting.\n     * @type {boolean}\n     * @memberof TransactionLogLine\n     */\n    mint?: boolean | null;\n    /**\n     * Index of the log in the transaction.\n     * @type {number}\n     * @memberof TransactionLogLine\n     */\n    logIndex?: number;\n    /**\n     * \n     * @type {string}\n     * @memberof TransactionLogLine\n     */\n    fromAddress?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof TransactionLogLine\n     */\n    toAddress?: string;\n    /**\n     * \n     * @type {CurrencyInfo}\n     * @memberof TransactionLogLine\n     */\n    price?: CurrencyInfo;\n}\n\n/**\n * Check if a given object implements the TransactionLogLine interface.\n */\nexport function instanceOfTransactionLogLine(value: object): boolean {\n    let isInstance = true;\n\n    return isInstance;\n}\n\nexport function TransactionLogLineFromJSON(json: any): TransactionLogLine {\n    return TransactionLogLineFromJSONTyped(json, false);\n}\n\nexport function TransactionLogLineFromJSONTyped(json: any, ignoreDiscriminator: boolean): TransactionLogLine {\n    if ((json === undefined) || (json === null)) {\n        return json;\n    }\n    return {\n        \n        'burned': !exists(json, 'burned') ? undefined : json['burned'],\n        'mint': !exists(json, 'mint') ? undefined : json['mint'],\n        'logIndex': !exists(json, 'logIndex') ? undefined : json['logIndex'],\n        'fromAddress': !exists(json, 'fromAddress') ? undefined : json['fromAddress'],\n        'toAddress': !exists(json, 'toAddress') ? undefined : json['toAddress'],\n        'price': !exists(json, 'price') ? undefined : CurrencyInfoFromJSON(json['price']),\n    };\n}\n\nexport function TransactionLogLineToJSON(value?: TransactionLogLine | null): any {\n    if (value === undefined) {\n        return undefined;\n    }\n    if (value === null) {\n        return null;\n    }\n    return {\n        \n        'burned': value.burned,\n        'mint': value.mint,\n        'logIndex': value.logIndex,\n        'fromAddress': value.fromAddress,\n        'toAddress': value.toAddress,\n        'price': CurrencyInfoToJSON(value.price),\n    };\n}\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * The version of the OpenAPI document: 0.17.1\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { exists, mapValues } from '../runtime';\nimport type { CurrencyInfo } from './CurrencyInfo';\nimport {\n    CurrencyInfoFromJSON,\n    CurrencyInfoFromJSONTyped,\n    CurrencyInfoToJSON,\n} from './CurrencyInfo';\nimport type { TransactionLogLine } from './TransactionLogLine';\nimport {\n    TransactionLogLineFromJSON,\n    TransactionLogLineFromJSONTyped,\n    TransactionLogLineToJSON,\n} from './TransactionLogLine';\n\n/**\n * \n * @export\n * @interface Transaction\n */\nexport interface Transaction {\n    /**\n     * Block number of the transaction.\n     * @type {number}\n     * @memberof Transaction\n     */\n    blockNumber?: number;\n    /**\n     * Index of the transaction in the block.\n     * @type {number}\n     * @memberof Transaction\n     */\n    transactionIndex?: number;\n    /**\n     * \n     * @type {CurrencyInfo}\n     * @memberof Transaction\n     */\n    gasFee?: CurrencyInfo;\n    /**\n     * Timestamp of the transaction in RFC 3339.\n     * @type {Date}\n     * @memberof Transaction\n     */\n    timestamp?: Date | null;\n    /**\n     * Log lines related to the transaction.\n     * @type {Array<TransactionLogLine>}\n     * @memberof Transaction\n     */\n    logLine?: Array<TransactionLogLine>;\n}\n\n/**\n * Check if a given object implements the Transaction interface.\n */\nexport function instanceOfTransaction(value: object): boolean {\n    let isInstance = true;\n\n    return isInstance;\n}\n\nexport function TransactionFromJSON(json: any): Transaction {\n    return TransactionFromJSONTyped(json, false);\n}\n\nexport function TransactionFromJSONTyped(json: any, ignoreDiscriminator: boolean): Transaction {\n    if ((json === undefined) || (json === null)) {\n        return json;\n    }\n    return {\n        \n        'blockNumber': !exists(json, 'blockNumber') ? undefined : json['blockNumber'],\n        'transactionIndex': !exists(json, 'transactionIndex') ? undefined : json['transactionIndex'],\n        'gasFee': !exists(json, 'gasFee') ? undefined : CurrencyInfoFromJSON(json['gasFee']),\n        'timestamp': !exists(json, 'timestamp') ? undefined : (json['timestamp'] === null ? null : new Date(json['timestamp'])),\n        'logLine': !exists(json, 'logLine') ? undefined : ((json['logLine'] as Array<any>).map(TransactionLogLineFromJSON)),\n    };\n}\n\nexport function TransactionToJSON(value?: Transaction | null): any {\n    if (value === undefined) {\n        return undefined;\n    }\n    if (value === null) {\n        return null;\n    }\n    return {\n        \n        'blockNumber': value.blockNumber,\n        'transactionIndex': value.transactionIndex,\n        'gasFee': CurrencyInfoToJSON(value.gasFee),\n        'timestamp': value.timestamp === undefined ? undefined : (value.timestamp === null ? null : value.timestamp.toISOString()),\n        'logLine': value.logLine === undefined ? undefined : ((value.logLine as Array<any>).map(TransactionLogLineToJSON)),\n    };\n}\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * The version of the OpenAPI document: 0.17.1\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { exists, mapValues } from '../runtime';\n/**\n * \n * @export\n * @interface OpenSeaContract\n */\nexport interface OpenSeaContract {\n    /**\n     * The type of contract.\n     * @type {string}\n     * @memberof OpenSeaContract\n     */\n    assetContractType?: OpenSeaContractAssetContractTypeEnum;\n    /**\n     * The NFT Version\n     * @type {string}\n     * @memberof OpenSeaContract\n     */\n    nftVersion?: string;\n    /**\n     * The OpenSea Version\n     * @type {string}\n     * @memberof OpenSeaContract\n     */\n    openSeaVersion?: string;\n    /**\n     * \n     * @type {boolean}\n     * @memberof OpenSeaContract\n     */\n    defaultToFiat?: boolean;\n    /**\n     * Total fee levied on buyers by this contract, in basis points\n     * @type {number}\n     * @memberof OpenSeaContract\n     */\n    buyerFeeBasisPoints?: number;\n    /**\n     * Total fee levied on sellers by this contract, in basis points\n     * @type {number}\n     * @memberof OpenSeaContract\n     */\n    sellerFeeBasisPoints?: number;\n}\n\n\n/**\n * @export\n */\nexport const OpenSeaContractAssetContractTypeEnum = {\n    Nft: 'NFT',\n    Sft: 'SFT',\n    Unknown: 'unknown'\n} as const;\nexport type OpenSeaContractAssetContractTypeEnum = typeof OpenSeaContractAssetContractTypeEnum[keyof typeof OpenSeaContractAssetContractTypeEnum];\n\n\n/**\n * Check if a given object implements the OpenSeaContract interface.\n */\nexport function instanceOfOpenSeaContract(value: object): boolean {\n    let isInstance = true;\n\n    return isInstance;\n}\n\nexport function OpenSeaContractFromJSON(json: any): OpenSeaContract {\n    return OpenSeaContractFromJSONTyped(json, false);\n}\n\nexport function OpenSeaContractFromJSONTyped(json: any, ignoreDiscriminator: boolean): OpenSeaContract {\n    if ((json === undefined) || (json === null)) {\n        return json;\n    }\n    return {\n        \n        'assetContractType': !exists(json, 'assetContractType') ? undefined : json['assetContractType'],\n        'nftVersion': !exists(json, 'nftVersion') ? undefined : json['nftVersion'],\n        'openSeaVersion': !exists(json, 'openSeaVersion') ? undefined : json['openSeaVersion'],\n        'defaultToFiat': !exists(json, 'defaultToFiat') ? undefined : json['defaultToFiat'],\n        'buyerFeeBasisPoints': !exists(json, 'buyerFeeBasisPoints') ? undefined : json['buyerFeeBasisPoints'],\n        'sellerFeeBasisPoints': !exists(json, 'sellerFeeBasisPoints') ? undefined : json['sellerFeeBasisPoints'],\n    };\n}\n\nexport function OpenSeaContractToJSON(value?: OpenSeaContract | null): any {\n    if (value === undefined) {\n        return undefined;\n    }\n    if (value === null) {\n        return null;\n    }\n    return {\n        \n        'assetContractType': value.assetContractType,\n        'nftVersion': value.nftVersion,\n        'openSeaVersion': value.openSeaVersion,\n        'defaultToFiat': value.defaultToFiat,\n        'buyerFeeBasisPoints': value.buyerFeeBasisPoints,\n        'sellerFeeBasisPoints': value.sellerFeeBasisPoints,\n    };\n}\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * The version of the OpenAPI document: 0.17.1\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { exists, mapValues } from '../runtime';\nimport type { BlockchainInfo } from './BlockchainInfo';\nimport {\n    BlockchainInfoFromJSON,\n    BlockchainInfoFromJSONTyped,\n    BlockchainInfoToJSON,\n} from './BlockchainInfo';\nimport type { NonFungibleToken } from './NonFungibleToken';\nimport {\n    NonFungibleTokenFromJSON,\n    NonFungibleTokenFromJSONTyped,\n    NonFungibleTokenToJSON,\n} from './NonFungibleToken';\nimport type { OpenSeaContract } from './OpenSeaContract';\nimport {\n    OpenSeaContractFromJSON,\n    OpenSeaContractFromJSONTyped,\n    OpenSeaContractToJSON,\n} from './OpenSeaContract';\n\n/**\n * \n * @export\n * @interface Token\n */\nexport interface Token {\n    /**\n     * \n     * @type {BlockchainInfo}\n     * @memberof Token\n     */\n    blockchain: BlockchainInfo;\n    /**\n     * Address of the contract that minted this NFT.\n     * @type {string}\n     * @memberof Token\n     */\n    contractAddress: string;\n    /**\n     * \n     * @type {string}\n     * @memberof Token\n     */\n    tokenStandard?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof Token\n     */\n    symbol?: string;\n    /**\n     * \n     * @type {NonFungibleToken}\n     * @memberof Token\n     */\n    nft?: NonFungibleToken;\n    /**\n     * \n     * @type {OpenSeaContract}\n     * @memberof Token\n     */\n    openSeaContract?: OpenSeaContract;\n}\n\n/**\n * Check if a given object implements the Token interface.\n */\nexport function instanceOfToken(value: object): boolean {\n    let isInstance = true;\n    isInstance = isInstance && \"blockchain\" in value;\n    isInstance = isInstance && \"contractAddress\" in value;\n\n    return isInstance;\n}\n\nexport function TokenFromJSON(json: any): Token {\n    return TokenFromJSONTyped(json, false);\n}\n\nexport function TokenFromJSONTyped(json: any, ignoreDiscriminator: boolean): Token {\n    if ((json === undefined) || (json === null)) {\n        return json;\n    }\n    return {\n        \n        'blockchain': BlockchainInfoFromJSON(json['blockchain']),\n        'contractAddress': json['contractAddress'],\n        'tokenStandard': !exists(json, 'tokenStandard') ? undefined : json['tokenStandard'],\n        'symbol': !exists(json, 'symbol') ? undefined : json['symbol'],\n        'nft': !exists(json, 'nft') ? undefined : NonFungibleTokenFromJSON(json['nft']),\n        'openSeaContract': !exists(json, 'openSeaContract') ? undefined : OpenSeaContractFromJSON(json['openSeaContract']),\n    };\n}\n\nexport function TokenToJSON(value?: Token | null): any {\n    if (value === undefined) {\n        return undefined;\n    }\n    if (value === null) {\n        return null;\n    }\n    return {\n        \n        'blockchain': BlockchainInfoToJSON(value.blockchain),\n        'contractAddress': value.contractAddress,\n        'tokenStandard': value.tokenStandard,\n        'symbol': value.symbol,\n        'nft': NonFungibleTokenToJSON(value.nft),\n        'openSeaContract': OpenSeaContractToJSON(value.openSeaContract),\n    };\n}\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * The version of the OpenAPI document: 0.17.1\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { exists, mapValues } from '../runtime';\nimport type { Collection } from './Collection';\nimport {\n    CollectionFromJSON,\n    CollectionFromJSONTyped,\n    CollectionToJSON,\n} from './Collection';\nimport type { CurrencyInfo } from './CurrencyInfo';\nimport {\n    CurrencyInfoFromJSON,\n    CurrencyInfoFromJSONTyped,\n    CurrencyInfoToJSON,\n} from './CurrencyInfo';\nimport type { Token } from './Token';\nimport {\n    TokenFromJSON,\n    TokenFromJSONTyped,\n    TokenToJSON,\n} from './Token';\n\n/**\n * \n * @export\n * @interface OwnedCollection\n */\nexport interface OwnedCollection {\n    /**\n     * A sample of the tokens owned by this wallet.\n     * @type {Array<Token>}\n     * @memberof OwnedCollection\n     */\n    tokens?: Array<Token>;\n    /**\n     * \n     * @type {Collection}\n     * @memberof OwnedCollection\n     */\n    collection?: Collection;\n    /**\n     * \n     * @type {CurrencyInfo}\n     * @memberof OwnedCollection\n     */\n    totalSpent?: CurrencyInfo;\n}\n\n/**\n * Check if a given object implements the OwnedCollection interface.\n */\nexport function instanceOfOwnedCollection(value: object): boolean {\n    let isInstance = true;\n\n    return isInstance;\n}\n\nexport function OwnedCollectionFromJSON(json: any): OwnedCollection {\n    return OwnedCollectionFromJSONTyped(json, false);\n}\n\nexport function OwnedCollectionFromJSONTyped(json: any, ignoreDiscriminator: boolean): OwnedCollection {\n    if ((json === undefined) || (json === null)) {\n        return json;\n    }\n    return {\n        \n        'tokens': !exists(json, 'tokens') ? undefined : ((json['tokens'] as Array<any>).map(TokenFromJSON)),\n        'collection': !exists(json, 'collection') ? undefined : CollectionFromJSON(json['collection']),\n        'totalSpent': !exists(json, 'totalSpent') ? undefined : CurrencyInfoFromJSON(json['totalSpent']),\n    };\n}\n\nexport function OwnedCollectionToJSON(value?: OwnedCollection | null): any {\n    if (value === undefined) {\n        return undefined;\n    }\n    if (value === null) {\n        return null;\n    }\n    return {\n        \n        'tokens': value.tokens === undefined ? undefined : ((value.tokens as Array<any>).map(TokenToJSON)),\n        'collection': CollectionToJSON(value.collection),\n        'totalSpent': CurrencyInfoToJSON(value.totalSpent),\n    };\n}\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * The version of the OpenAPI document: 0.17.1\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { exists, mapValues } from '../runtime';\nimport type { CurrencyInfo } from './CurrencyInfo';\nimport {\n    CurrencyInfoFromJSON,\n    CurrencyInfoFromJSONTyped,\n    CurrencyInfoToJSON,\n} from './CurrencyInfo';\nimport type { ENS } from './ENS';\nimport {\n    ENSFromJSON,\n    ENSFromJSONTyped,\n    ENSToJSON,\n} from './ENS';\nimport type { OwnedCollection } from './OwnedCollection';\nimport {\n    OwnedCollectionFromJSON,\n    OwnedCollectionFromJSONTyped,\n    OwnedCollectionToJSON,\n} from './OwnedCollection';\nimport type { SocialMedia } from './SocialMedia';\nimport {\n    SocialMediaFromJSON,\n    SocialMediaFromJSONTyped,\n    SocialMediaToJSON,\n} from './SocialMedia';\nimport type { Token } from './Token';\nimport {\n    TokenFromJSON,\n    TokenFromJSONTyped,\n    TokenToJSON,\n} from './Token';\nimport type { Transaction } from './Transaction';\nimport {\n    TransactionFromJSON,\n    TransactionFromJSONTyped,\n    TransactionToJSON,\n} from './Transaction';\n\n/**\n * \n * @export\n * @interface Wallet\n */\nexport interface Wallet {\n    /**\n     * The total balance in a fiat currency (e.g. USD) for the wallet.\n     * @type {Array<CurrencyInfo>}\n     * @memberof Wallet\n     */\n    totalBalance?: Array<CurrencyInfo>;\n    /**\n     * The balance of fungible tokens from smart contracts or blockchains. Certain non-standard ERC-20 tokens (e.g. stETH) may occasionally have stale balances, for example interest payments can be slow to update.\n     * @type {Array<CurrencyInfo>}\n     * @memberof Wallet\n     */\n    balances?: Array<CurrencyInfo>;\n    /**\n     * \n     * @type {string}\n     * @memberof Wallet\n     */\n    address: string;\n    /**\n     * \n     * @type {Array<ENS>}\n     * @memberof Wallet\n     */\n    ens?: Array<ENS>;\n    /**\n     * \n     * @type {Array<SocialMedia>}\n     * @memberof Wallet\n     */\n    socialMedia?: Array<SocialMedia>;\n    /**\n     * A sample of the most recently transferred tokens owned by this wallet.\n     * @type {Array<Token>}\n     * @memberof Wallet\n     */\n    recentTokens?: Array<Token>;\n    /**\n     * A sample of the most expensive tokens owned by this wallet.\n     * @type {Array<Token>}\n     * @memberof Wallet\n     */\n    topTokens?: Array<Token>;\n    /**\n     * A sample of the collections this wallet owns.\n     * @type {Array<OwnedCollection>}\n     * @memberof Wallet\n     */\n    collections?: Array<OwnedCollection>;\n    /**\n     * A reverse-chronological list of the latest transactions for a wallet.\n     * @type {Array<Transaction>}\n     * @memberof Wallet\n     */\n    history?: Array<Transaction>;\n}\n\n/**\n * Check if a given object implements the Wallet interface.\n */\nexport function instanceOfWallet(value: object): boolean {\n    let isInstance = true;\n    isInstance = isInstance && \"address\" in value;\n\n    return isInstance;\n}\n\nexport function WalletFromJSON(json: any): Wallet {\n    return WalletFromJSONTyped(json, false);\n}\n\nexport function WalletFromJSONTyped(json: any, ignoreDiscriminator: boolean): Wallet {\n    if ((json === undefined) || (json === null)) {\n        return json;\n    }\n    return {\n        \n        'totalBalance': !exists(json, 'totalBalance') ? undefined : ((json['totalBalance'] as Array<any>).map(CurrencyInfoFromJSON)),\n        'balances': !exists(json, 'balances') ? undefined : ((json['balances'] as Array<any>).map(CurrencyInfoFromJSON)),\n        'address': json['address'],\n        'ens': !exists(json, 'ens') ? undefined : ((json['ens'] as Array<any>).map(ENSFromJSON)),\n        'socialMedia': !exists(json, 'socialMedia') ? undefined : ((json['socialMedia'] as Array<any>).map(SocialMediaFromJSON)),\n        'recentTokens': !exists(json, 'recentTokens') ? undefined : ((json['recentTokens'] as Array<any>).map(TokenFromJSON)),\n        'topTokens': !exists(json, 'topTokens') ? undefined : ((json['topTokens'] as Array<any>).map(TokenFromJSON)),\n        'collections': !exists(json, 'collections') ? undefined : ((json['collections'] as Array<any>).map(OwnedCollectionFromJSON)),\n        'history': !exists(json, 'history') ? undefined : ((json['history'] as Array<any>).map(TransactionFromJSON)),\n    };\n}\n\nexport function WalletToJSON(value?: Wallet | null): any {\n    if (value === undefined) {\n        return undefined;\n    }\n    if (value === null) {\n        return null;\n    }\n    return {\n        \n        'totalBalance': value.totalBalance === undefined ? undefined : ((value.totalBalance as Array<any>).map(CurrencyInfoToJSON)),\n        'balances': value.balances === undefined ? undefined : ((value.balances as Array<any>).map(CurrencyInfoToJSON)),\n        'address': value.address,\n        'ens': value.ens === undefined ? undefined : ((value.ens as Array<any>).map(ENSToJSON)),\n        'socialMedia': value.socialMedia === undefined ? undefined : ((value.socialMedia as Array<any>).map(SocialMediaToJSON)),\n        'recentTokens': value.recentTokens === undefined ? undefined : ((value.recentTokens as Array<any>).map(TokenToJSON)),\n        'topTokens': value.topTokens === undefined ? undefined : ((value.topTokens as Array<any>).map(TokenToJSON)),\n        'collections': value.collections === undefined ? undefined : ((value.collections as Array<any>).map(OwnedCollectionToJSON)),\n        'history': value.history === undefined ? undefined : ((value.history as Array<any>).map(TransactionToJSON)),\n    };\n}\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * The version of the OpenAPI document: 0.17.1\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { exists, mapValues } from '../runtime';\nimport type { Collection } from './Collection';\nimport {\n    CollectionFromJSON,\n    CollectionFromJSONTyped,\n    CollectionToJSON,\n} from './Collection';\nimport type { Media } from './Media';\nimport {\n    MediaFromJSON,\n    MediaFromJSONTyped,\n    MediaToJSON,\n} from './Media';\nimport type { MediaPreview } from './MediaPreview';\nimport {\n    MediaPreviewFromJSON,\n    MediaPreviewFromJSONTyped,\n    MediaPreviewToJSON,\n} from './MediaPreview';\nimport type { TokenAttribute } from './TokenAttribute';\nimport {\n    TokenAttributeFromJSON,\n    TokenAttributeFromJSONTyped,\n    TokenAttributeToJSON,\n} from './TokenAttribute';\nimport type { Transaction } from './Transaction';\nimport {\n    TransactionFromJSON,\n    TransactionFromJSONTyped,\n    TransactionToJSON,\n} from './Transaction';\nimport type { Wallet } from './Wallet';\nimport {\n    WalletFromJSON,\n    WalletFromJSONTyped,\n    WalletToJSON,\n} from './Wallet';\n\n/**\n * \n * @export\n * @interface NonFungibleToken\n */\nexport interface NonFungibleToken {\n    /**\n     * ID of this particular token.\n     * @type {string}\n     * @memberof NonFungibleToken\n     */\n    tokenID: string;\n    /**\n     * \n     * @type {string}\n     * @memberof NonFungibleToken\n     */\n    title?: string;\n    /**\n     * \n     * @type {string}\n     * @memberof NonFungibleToken\n     */\n    contractTitle?: string;\n    /**\n     * A description of a contract may contain markup such as HTML or Markdown.\n     * @type {string}\n     * @memberof NonFungibleToken\n     */\n    description?: string;\n    /**\n     * \n     * @type {Media}\n     * @memberof NonFungibleToken\n     */\n    media?: Media;\n    /**\n     * Transformed media assets that are resized and transcoded in to friendlier formats for web and mobile delivery.\n     * @type {Array<MediaPreview>}\n     * @memberof NonFungibleToken\n     */\n    previews?: Array<MediaPreview>;\n    /**\n     * \n     * @type {Wallet}\n     * @memberof NonFungibleToken\n     */\n    owner?: Wallet;\n    /**\n     * \n     * @type {Array<TokenAttribute>}\n     * @memberof NonFungibleToken\n     */\n    attributes?: Array<TokenAttribute>;\n    /**\n     * \n     * @type {Collection}\n     * @memberof NonFungibleToken\n     */\n    collection?: Collection;\n    /**\n     * \n     * @type {Transaction}\n     * @memberof NonFungibleToken\n     */\n    purchase?: Transaction;\n    /**\n     * A rough heuristic indicating the underlying technology and hypothetical durability of an asset. \"On-Chain\" assets store metadata and the asset media (e.g. SVG file, source code or MIDI) on a blockchain. \"Distributed\" assets are stored on decentralized protocols such as IPFS. \"Web\" assets are stored on services such as Amazon's S3. Each technology has different tradeoffs, in particular certain projects need more flexibility than is provided by on-chain data.\"\n     * @type {string}\n     * @memberof NonFungibleToken\n     */\n    durability?: NonFungibleTokenDurabilityEnum;\n    /**\n     * The project name of the NFT.\n     * @type {string}\n     * @memberof NonFungibleToken\n     */\n    projectName?: string;\n}\n\n\n/**\n * @export\n */\nexport const NonFungibleTokenDurabilityEnum = {\n    OnChain: 'On-Chain',\n    Decentralized: 'Decentralized',\n    Web: 'Web',\n    Unknown: 'Unknown'\n} as const;\nexport type NonFungibleTokenDurabilityEnum = typeof NonFungibleTokenDurabilityEnum[keyof typeof NonFungibleTokenDurabilityEnum];\n\n\n/**\n * Check if a given object implements the NonFungibleToken interface.\n */\nexport function instanceOfNonFungibleToken(value: object): boolean {\n    let isInstance = true;\n    isInstance = isInstance && \"tokenID\" in value;\n\n    return isInstance;\n}\n\nexport function NonFungibleTokenFromJSON(json: any): NonFungibleToken {\n    return NonFungibleTokenFromJSONTyped(json, false);\n}\n\nexport function NonFungibleTokenFromJSONTyped(json: any, ignoreDiscriminator: boolean): NonFungibleToken {\n    if ((json === undefined) || (json === null)) {\n        return json;\n    }\n    return {\n        \n        'tokenID': json['tokenID'],\n        'title': !exists(json, 'title') ? undefined : json['title'],\n        'contractTitle': !exists(json, 'contractTitle') ? undefined : json['contractTitle'],\n        'description': !exists(json, 'description') ? undefined : json['description'],\n        'media': !exists(json, 'media') ? undefined : MediaFromJSON(json['media']),\n        'previews': !exists(json, 'previews') ? undefined : ((json['previews'] as Array<any>).map(MediaPreviewFromJSON)),\n        'owner': !exists(json, 'owner') ? undefined : WalletFromJSON(json['owner']),\n        'attributes': !exists(json, 'attributes') ? undefined : ((json['attributes'] as Array<any>).map(TokenAttributeFromJSON)),\n        'collection': !exists(json, 'collection') ? undefined : CollectionFromJSON(json['collection']),\n        'purchase': !exists(json, 'purchase') ? undefined : TransactionFromJSON(json['purchase']),\n        'durability': !exists(json, 'durability') ? undefined : json['durability'],\n        'projectName': !exists(json, 'projectName') ? undefined : json['projectName'],\n    };\n}\n\nexport function NonFungibleTokenToJSON(value?: NonFungibleToken | null): any {\n    if (value === undefined) {\n        return undefined;\n    }\n    if (value === null) {\n        return null;\n    }\n    return {\n        \n        'tokenID': value.tokenID,\n        'title': value.title,\n        'contractTitle': value.contractTitle,\n        'description': value.description,\n        'media': MediaToJSON(value.media),\n        'previews': value.previews === undefined ? undefined : ((value.previews as Array<any>).map(MediaPreviewToJSON)),\n        'owner': WalletToJSON(value.owner),\n        'attributes': value.attributes === undefined ? undefined : ((value.attributes as Array<any>).map(TokenAttributeToJSON)),\n        'collection': CollectionToJSON(value.collection),\n        'purchase': TransactionToJSON(value.purchase),\n        'durability': value.durability,\n        'projectName': value.projectName,\n    };\n}\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * The version of the OpenAPI document: 0.17.1\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { exists, mapValues } from '../runtime';\nimport type { Collection } from './Collection';\nimport {\n    CollectionFromJSON,\n    CollectionFromJSONTyped,\n    CollectionToJSON,\n} from './Collection';\nimport type { Token } from './Token';\nimport {\n    TokenFromJSON,\n    TokenFromJSONTyped,\n    TokenToJSON,\n} from './Token';\nimport type { Wallet } from './Wallet';\nimport {\n    WalletFromJSON,\n    WalletFromJSONTyped,\n    WalletToJSON,\n} from './Wallet';\n\n/**\n * \n * @export\n * @interface SearchDocument\n */\nexport interface SearchDocument {\n    /**\n     * \n     * @type {Token}\n     * @memberof SearchDocument\n     */\n    token?: Token;\n    /**\n     * \n     * @type {Wallet}\n     * @memberof SearchDocument\n     */\n    wallet?: Wallet;\n    /**\n     * \n     * @type {Collection}\n     * @memberof SearchDocument\n     */\n    collection?: Collection;\n}\n\n/**\n * Check if a given object implements the SearchDocument interface.\n */\nexport function instanceOfSearchDocument(value: object): boolean {\n    let isInstance = true;\n\n    return isInstance;\n}\n\nexport function SearchDocumentFromJSON(json: any): SearchDocument {\n    return SearchDocumentFromJSONTyped(json, false);\n}\n\nexport function SearchDocumentFromJSONTyped(json: any, ignoreDiscriminator: boolean): SearchDocument {\n    if ((json === undefined) || (json === null)) {\n        return json;\n    }\n    return {\n        \n        'token': !exists(json, 'token') ? undefined : TokenFromJSON(json['token']),\n        'wallet': !exists(json, 'wallet') ? undefined : WalletFromJSON(json['wallet']),\n        'collection': !exists(json, 'collection') ? undefined : CollectionFromJSON(json['collection']),\n    };\n}\n\nexport function SearchDocumentToJSON(value?: SearchDocument | null): any {\n    if (value === undefined) {\n        return undefined;\n    }\n    if (value === null) {\n        return null;\n    }\n    return {\n        \n        'token': TokenToJSON(value.token),\n        'wallet': WalletToJSON(value.wallet),\n        'collection': CollectionToJSON(value.collection),\n    };\n}\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * The version of the OpenAPI document: 0.17.1\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { exists, mapValues } from '../runtime';\nimport type { Token } from './Token';\nimport {\n    TokenFromJSON,\n    TokenFromJSONTyped,\n    TokenToJSON,\n} from './Token';\nimport type { Transaction } from './Transaction';\nimport {\n    TransactionFromJSON,\n    TransactionFromJSONTyped,\n    TransactionToJSON,\n} from './Transaction';\n\n/**\n * \n * @export\n * @interface TokenEvents\n */\nexport interface TokenEvents {\n    /**\n     * Metadata for the token specified in the request.\n     * @type {Array<Token>}\n     * @memberof TokenEvents\n     */\n    token?: Array<Token>;\n    /**\n     * A list of the events for a token.\n     * @type {Array<Transaction>}\n     * @memberof TokenEvents\n     */\n    events?: Array<Transaction>;\n}\n\n/**\n * Check if a given object implements the TokenEvents interface.\n */\nexport function instanceOfTokenEvents(value: object): boolean {\n    let isInstance = true;\n\n    return isInstance;\n}\n\nexport function TokenEventsFromJSON(json: any): TokenEvents {\n    return TokenEventsFromJSONTyped(json, false);\n}\n\nexport function TokenEventsFromJSONTyped(json: any, ignoreDiscriminator: boolean): TokenEvents {\n    if ((json === undefined) || (json === null)) {\n        return json;\n    }\n    return {\n        \n        'token': !exists(json, 'token') ? undefined : ((json['token'] as Array<any>).map(TokenFromJSON)),\n        'events': !exists(json, 'events') ? undefined : ((json['events'] as Array<any>).map(TransactionFromJSON)),\n    };\n}\n\nexport function TokenEventsToJSON(value?: TokenEvents | null): any {\n    if (value === undefined) {\n        return undefined;\n    }\n    if (value === null) {\n        return null;\n    }\n    return {\n        \n        'token': value.token === undefined ? undefined : ((value.token as Array<any>).map(TokenToJSON)),\n        'events': value.events === undefined ? undefined : ((value.events as Array<any>).map(TransactionToJSON)),\n    };\n}\n\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * The version of the OpenAPI document: 0.17.1\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { exists, mapValues } from '../runtime';\n/**\n * \n * @export\n * @interface TokenGate\n */\nexport interface TokenGate {\n    /**\n     * \n     * @type {boolean}\n     * @memberof TokenGate\n     */\n    hasToken: boolean;\n}\n\n/**\n * Check if a given object implements the TokenGate interface.\n */\nexport function instanceOfTokenGate(value: object): boolean {\n    let isInstance = true;\n    isInstance = isInstance && \"hasToken\" in value;\n\n    return isInstance;\n}\n\nexport function TokenGateFromJSON(json: any): TokenGate {\n    return TokenGateFromJSONTyped(json, false);\n}\n\nexport function TokenGateFromJSONTyped(json: any, ignoreDiscriminator: boolean): TokenGate {\n    if ((json === undefined) || (json === null)) {\n        return json;\n    }\n    return {\n        \n        'hasToken': json['hasToken'],\n    };\n}\n\nexport function TokenGateToJSON(value?: TokenGate | null): any {\n    if (value === undefined) {\n        return undefined;\n    }\n    if (value === null) {\n        return null;\n    }\n    return {\n        \n        'hasToken': value.hasToken,\n    };\n}\n\n","/* tslint:disable */\n/* eslint-disable */\nexport * from './BlockchainInfo';\nexport * from './Collection';\nexport * from './CurrencyInfo';\nexport * from './ENS';\nexport * from './ErrorMessage';\nexport * from './Media';\nexport * from './MediaPreview';\nexport * from './MediaVersion';\nexport * from './NonFungibleToken';\nexport * from './OpenSeaContract';\nexport * from './OwnedCollection';\nexport * from './SearchDocument';\nexport * from './SocialMedia';\nexport * from './Token';\nexport * from './TokenAttribute';\nexport * from './TokenEvents';\nexport * from './TokenGate';\nexport * from './Transaction';\nexport * from './TransactionLogLine';\nexport * from './URL';\nexport * from './Wallet';\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * The version of the OpenAPI document: 0.17.1\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nimport * as runtime from '../runtime';\nimport type {\n  Collection,\n  ErrorMessage,\n  Token,\n  Wallet,\n} from '../models';\nimport {\n    CollectionFromJSON,\n    CollectionToJSON,\n    ErrorMessageFromJSON,\n    ErrorMessageToJSON,\n    TokenFromJSON,\n    TokenToJSON,\n    WalletFromJSON,\n    WalletToJSON,\n} from '../models';\n\n/**\n * \n */\nexport class AlphaApi extends runtime.BaseAPI {\n\n    /**\n     * Returns trending and interesting collections on Ethereum. Useful for powering discovery experiences and providing an on-ramp to exploring creative blockchain data.\n     */\n    async getTopCollectionsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Collection>>> {\n        const queryParameters: any = {};\n\n        const headerParameters: runtime.HTTPHeaders = {};\n\n        if (this.configuration && this.configuration.apiKey) {\n            queryParameters[\"apikey\"] = this.configuration.apiKey(\"apikey\"); // apikey authentication\n        }\n\n        const response = await this.request({\n            path: `/api/v1-alpha/collections/top`,\n            method: 'GET',\n            headers: headerParameters,\n            query: queryParameters,\n        }, initOverrides);\n\n        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CollectionFromJSON));\n    }\n\n    /**\n     * Returns trending and interesting collections on Ethereum. Useful for powering discovery experiences and providing an on-ramp to exploring creative blockchain data.\n     */\n    async getTopCollections(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Collection>> {\n        const response = await this.getTopCollectionsRaw(initOverrides);\n        return await response.value();\n    }\n\n    /**\n     * Returns trending and interesting NFTs and SFTs on Ethereum. Useful for powering discovery experiences and providing an on-ramp to exploring creative blockchain data.\n     */\n    async getTopTokensRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Token>>> {\n        const queryParameters: any = {};\n\n        const headerParameters: runtime.HTTPHeaders = {};\n\n        if (this.configuration && this.configuration.apiKey) {\n            queryParameters[\"apikey\"] = this.configuration.apiKey(\"apikey\"); // apikey authentication\n        }\n\n        const response = await this.request({\n            path: `/api/v1-alpha/tokens/top`,\n            method: 'GET',\n            headers: headerParameters,\n            query: queryParameters,\n        }, initOverrides);\n\n        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TokenFromJSON));\n    }\n\n    /**\n     * Returns trending and interesting NFTs and SFTs on Ethereum. Useful for powering discovery experiences and providing an on-ramp to exploring creative blockchain data.\n     */\n    async getTopTokens(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Token>> {\n        const response = await this.getTopTokensRaw(initOverrides);\n        return await response.value();\n    }\n\n    /**\n     * Returns trending and interesting wallets on Ethereum. Useful for powering discovery experiences and providing an on-ramp to exploring creative blockchain data.\n     */\n    async getTopWalletsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Wallet>>> {\n        const queryParameters: any = {};\n\n        const headerParameters: runtime.HTTPHeaders = {};\n\n        if (this.configuration && this.configuration.apiKey) {\n            queryParameters[\"apikey\"] = this.configuration.apiKey(\"apikey\"); // apikey authentication\n        }\n\n        const response = await this.request({\n            path: `/api/v1-alpha/wallets/top`,\n            method: 'GET',\n            headers: headerParameters,\n            query: queryParameters,\n        }, initOverrides);\n\n        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(WalletFromJSON));\n    }\n\n    /**\n     * Returns trending and interesting wallets on Ethereum. Useful for powering discovery experiences and providing an on-ramp to exploring creative blockchain data.\n     */\n    async getTopWallets(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Wallet>> {\n        const response = await this.getTopWalletsRaw(initOverrides);\n        return await response.value();\n    }\n\n}\n","/* tslint:disable */\n/* eslint-disable */\n/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * The version of the OpenAPI document: 0.17.1\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\n\nimport * as runtime from '../runtime';\nimport type {\n  BlockchainInfo,\n  Collection,\n  CurrencyInfo,\n  ErrorMessage,\n  SearchDocument,\n  Token,\n  TokenEvents,\n  TokenGate,\n  Transaction,\n  Wallet,\n} from '../models';\nimport {\n    BlockchainInfoFromJSON,\n    BlockchainInfoToJSON,\n    CollectionFromJSON,\n    CollectionToJSON,\n    CurrencyInfoFromJSON,\n    CurrencyInfoToJSON,\n    ErrorMessageFromJSON,\n    ErrorMessageToJSON,\n    SearchDocumentFromJSON,\n    SearchDocumentToJSON,\n    TokenFromJSON,\n    TokenToJSON,\n    TokenEventsFromJSON,\n    TokenEventsToJSON,\n    TokenGateFromJSON,\n    TokenGateToJSON,\n    TransactionFromJSON,\n    TransactionToJSON,\n    WalletFromJSON,\n    WalletToJSON,\n} from '../models';\n\nexport interface GetCollectionRequest {\n    contractAddress: string;\n    chainID?: string;\n}\n\nexport interface GetContractTokensRequest {\n    contractAddress: string;\n    chainID?: string;\n    limit?: number;\n}\n\nexport interface GetContractTokensByContractAndIDRequest {\n    contractAddresses: string;\n    tokenIdentifiers: string;\n    chainID?: string;\n    limit?: number;\n}\n\nexport interface GetContractTransactionHistoryRequest {\n    contractAddress: string;\n    cursor?: string;\n    chainID?: string;\n    limit?: number;\n}\n\nexport interface GetSearchResultsRequest {\n    query: string;\n    cursor?: string;\n}\n\nexport interface GetSoldTokensRequest {\n    walletAddress: string;\n    chainID?: string;\n    cursor?: string;\n    limit?: number;\n}\n\nexport interface GetTokenRequest {\n    contractAddress: string;\n    tokenID: string;\n    chainID?: string;\n}\n\nexport interface GetTokenGateRequest {\n    tokenID: string;\n    contractAddress: string;\n    walletAddress: string;\n    chainID?: string;\n}\n\nexport interface GetTokenTransfersRequest {\n    contractAddress: string;\n    tokenID: string;\n    chainID?: string;\n    limit?: number;\n}\n\nexport interface GetTokensBySearchQueryRequest {\n    query: string;\n    cursor?: string;\n}\n\nexport interface GetWalletRequest {\n    walletAddress: string;\n    chainID?: string;\n}\n\nexport interface GetWalletBalancesRequest {\n    walletAddress: string;\n    limit?: number;\n}\n\nexport interface GetWalletMintsRequest {\n    walletAddress: string;\n    chainID?: string;\n    cursor?: string;\n    limit?: number;\n}\n\nexport interface GetWalletTokensRequest {\n    walletAddress: string;\n    cursor?: string;\n    chainID?: string;\n    limit?: number;\n}\n\nexport interface GetWalletTransactionsRequest {\n    walletAddress: string;\n    cursor?: string;\n    limit?: number;\n    chainID?: string;\n    tokenType?: GetWalletTransactionsTokenTypeEnum;\n}\n\n/**\n * \n */\nexport class DefaultApi extends runtime.BaseAPI {\n\n    /**\n     * Lists all supported blockchains.\n     */\n    async getBlockchainsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<BlockchainInfo>>> {\n        const queryParameters: any = {};\n\n        const headerParameters: runtime.HTTPHeaders = {};\n\n        if (this.configuration && this.configuration.apiKey) {\n            queryParameters[\"apikey\"] = this.configuration.apiKey(\"apikey\"); // apikey authentication\n        }\n\n        const response = await this.request({\n            path: `/api/v1/blockchains`,\n            method: 'GET',\n            headers: headerParameters,\n            query: queryParameters,\n        }, initOverrides);\n\n        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BlockchainInfoFromJSON));\n    }\n\n    /**\n     * Lists all supported blockchains.\n     */\n    async getBlockchains(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<BlockchainInfo>> {\n        const response = await this.getBlockchainsRaw(initOverrides);\n        return await response.value();\n    }\n\n    /**\n     * Get a collection by its contract address.\n     */\n    async getCollectionRaw(requestParameters: GetCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Collection>>> {\n        if (requestParameters.contractAddress === null || requestParameters.contractAddress === undefined) {\n            throw new runtime.RequiredError('contractAddress','Required parameter requestParameters.contractAddress was null or undefined when calling getCollection.');\n        }\n\n        const queryParameters: any = {};\n\n        if (requestParameters.chainID !== undefined) {\n            queryParameters['chainID'] = requestParameters.chainID;\n        }\n\n        const headerParameters: runtime.HTTPHeaders = {};\n\n        if (this.configuration && this.configuration.apiKey) {\n            queryParameters[\"apikey\"] = this.configuration.apiKey(\"apikey\"); // apikey authentication\n        }\n\n        const response = await this.request({\n            path: `/api/v1/collections/{contractAddress}`.replace(`{${\"contractAddress\"}}`, encodeURIComponent(String(requestParameters.contractAddress))),\n            method: 'GET',\n            headers: headerParameters,\n            query: queryParameters,\n        }, initOverrides);\n\n        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CollectionFromJSON));\n    }\n\n    /**\n     * Get a collection by its contract address.\n     */\n    async getCollection(requestParameters: GetCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Collection>> {\n        const response = await this.getCollectionRaw(requestParameters, initOverrides);\n        return await response.value();\n    }\n\n    /**\n     * Get tokens by contract address.\n     */\n    async getContractTokensRaw(requestParameters: GetContractTokensRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Token>>> {\n        if (requestParameters.contractAddress === null || requestParameters.contractAddress === undefined) {\n            throw new runtime.RequiredError('contractAddress','Required parameter requestParameters.contractAddress was null or undefined when calling getContractTokens.');\n        }\n\n        const queryParameters: any = {};\n\n        if (requestParameters.chainID !== undefined) {\n            queryParameters['chainID'] = requestParameters.chainID;\n        }\n\n        if (requestParameters.limit !== undefined) {\n            queryParameters['limit'] = requestParameters.limit;\n        }\n\n        const headerParameters: runtime.HTTPHeaders = {};\n\n        if (this.configuration && this.configuration.apiKey) {\n            queryParameters[\"apikey\"] = this.configuration.apiKey(\"apikey\"); // apikey authentication\n        }\n\n        const response = await this.request({\n            path: `/api/v1/tokens/{contractAddress}`.replace(`{${\"contractAddress\"}}`, encodeURIComponent(String(requestParameters.contractAddress))),\n            method: 'GET',\n            headers: headerParameters,\n            query: queryParameters,\n        }, initOverrides);\n\n        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TokenFromJSON));\n    }\n\n    /**\n     * Get tokens by contract address.\n     */\n    async getContractTokens(requestParameters: GetContractTokensRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Token>> {\n        const response = await this.getContractTokensRaw(requestParameters, initOverrides);\n        return await response.value();\n    }\n\n    /**\n     * Get tokens by a pair of contract addresses and token IDs. The input are two ordered arrays. The first element of contractAddresses should be related to the 1st element of the tokenID, etc. In the below example two tokens are being requested, token 3481 from the \\\"goblintown\\\" contract (i.e. 0xbce3781ae7ca1a5e050bd9c4c77369867ebc307e) and token 50603 from the Otherdeed contract (i.e. 0x34d85c9cdeb23fa97cb08333b511ac86e1c4e258).\n     */\n    async getContractTokensByContractAndIDRaw(requestParameters: GetContractTokensByContractAndIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Token>>> {\n        if (requestParameters.contractAddresses === null || requestParameters.contractAddresses === undefined) {\n            throw new runtime.RequiredError('contractAddresses','Required parameter requestParameters.contractAddresses was null or undefined when calling getContractTokensByContractAndID.');\n        }\n\n        if (requestParameters.tokenIdentifiers === null || requestParameters.tokenIdentifiers === undefined) {\n            throw new runtime.RequiredError('tokenIdentifiers','Required parameter requestParameters.tokenIdentifiers was null or undefined when calling getContractTokensByContractAndID.');\n        }\n\n        const queryParameters: any = {};\n\n        if (requestParameters.contractAddresses !== undefined) {\n            queryParameters['contractAddresses'] = requestParameters.contractAddresses;\n        }\n\n        if (requestParameters.tokenIdentifiers !== undefined) {\n            queryParameters['tokenIdentifiers'] = requestParameters.tokenIdentifiers;\n        }\n\n        if (requestParameters.chainID !== undefined) {\n            queryParameters['chainID'] = requestParameters.chainID;\n        }\n\n        if (requestParameters.limit !== undefined) {\n            queryParameters['limit'] = requestParameters.limit;\n        }\n\n        const headerParameters: runtime.HTTPHeaders = {};\n\n        if (this.configuration && this.configuration.apiKey) {\n            queryParameters[\"apikey\"] = this.configuration.apiKey(\"apikey\"); // apikey authentication\n        }\n\n        const response = await this.request({\n            path: `/api/v1/token-batch`,\n            method: 'GET',\n            headers: headerParameters,\n            query: queryParameters,\n        }, initOverrides);\n\n        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TokenFromJSON));\n    }\n\n    /**\n     * Get tokens by a pair of contract addresses and token IDs. The input are two ordered arrays. The first element of contractAddresses should be related to the 1st element of the tokenID, etc. In the below example two tokens are being requested, token 3481 from the \\\"goblintown\\\" contract (i.e. 0xbce3781ae7ca1a5e050bd9c4c77369867ebc307e) and token 50603 from the Otherdeed contract (i.e. 0x34d85c9cdeb23fa97cb08333b511ac86e1c4e258).\n     */\n    async getContractTokensByContractAndID(requestParameters: GetContractTokensByContractAndIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Token>> {\n        const response = await this.getContractTokensByContractAndIDRaw(requestParameters, initOverrides);\n        return await response.value();\n    }\n\n    /**\n     * Get the transaction history for a collection\n     */\n    async getContractTransactionHistoryRaw(requestParameters: GetContractTransactionHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Transaction>>> {\n        if (requestParameters.contractAddress === null || requestParameters.contractAddress === undefined) {\n            throw new runtime.RequiredError('contractAddress','Required parameter requestParameters.contractAddress was null or undefined when calling getContractTransactionHistory.');\n        }\n\n        const queryParameters: any = {};\n\n        if (requestParameters.cursor !== undefined) {\n            queryParameters['cursor'] = requestParameters.cursor;\n        }\n\n        if (requestParameters.chainID !== undefined) {\n            queryParameters['chainID'] = requestParameters.chainID;\n        }\n\n        if (requestParameters.limit !== undefined) {\n            queryParameters['limit'] = requestParameters.limit;\n        }\n\n        const headerParameters: runtime.HTTPHeaders = {};\n\n        if (this.configuration && this.configuration.apiKey) {\n            queryParameters[\"apikey\"] = this.configuration.apiKey(\"apikey\"); // apikey authentication\n        }\n\n        const response = await this.request({\n            path: `/api/v1/collections/{contractAddress}/transactions/history`.replace(`{${\"contractAddress\"}}`, encodeURIComponent(String(requestParameters.contractAddress))),\n            method: 'GET',\n            headers: headerParameters,\n            query: queryParameters,\n        }, initOverrides);\n\n        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TransactionFromJSON));\n    }\n\n    /**\n     * Get the transaction history for a collection\n     */\n    async getContractTransactionHistory(requestParameters: GetContractTransactionHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Transaction>> {\n        const response = await this.getContractTransactionHistoryRaw(requestParameters, initOverrides);\n        return await response.value();\n    }\n\n    /**\n     * Get search results such as wallets, tokens, and collections by a search query.\n     */\n    async getSearchResultsRaw(requestParameters: GetSearchResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SearchDocument>>> {\n        if (requestParameters.query === null || requestParameters.query === undefined) {\n            throw new runtime.RequiredError('query','Required parameter requestParameters.query was null or undefined when calling getSearchResults.');\n        }\n\n        const queryParameters: any = {};\n\n        if (requestParameters.cursor !== undefined) {\n            queryParameters['cursor'] = requestParameters.cursor;\n        }\n\n        const headerParameters: runtime.HTTPHeaders = {};\n\n        if (this.configuration && this.configuration.apiKey) {\n            queryParameters[\"apikey\"] = this.configuration.apiKey(\"apikey\"); // apikey authentication\n        }\n\n        const response = await this.request({\n            path: `/api/v1/search/{query}`.replace(`{${\"query\"}}`, encodeURIComponent(String(requestParameters.query))),\n            method: 'GET',\n            headers: headerParameters,\n            query: queryParameters,\n        }, initOverrides);\n\n        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SearchDocumentFromJSON));\n    }\n\n    /**\n     * Get search results such as wallets, tokens, and collections by a search query.\n     */\n    async getSearchResults(requestParameters: GetSearchResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SearchDocument>> {\n        const response = await this.getSearchResultsRaw(requestParameters, initOverrides);\n        return await response.value();\n    }\n\n    /**\n     * Returns a list of tokens sold by a wallet.\n     */\n    async getSoldTokensRaw(requestParameters: GetSoldTokensRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Token>>> {\n        if (requestParameters.walletAddress === null || requestParameters.walletAddress === undefined) {\n            throw new runtime.RequiredError('walletAddress','Required parameter requestParameters.walletAddress was null or undefined when calling getSoldTokens.');\n        }\n\n        const queryParameters: any = {};\n\n        if (requestParameters.chainID !== undefined) {\n            queryParameters['chainID'] = requestParameters.chainID;\n        }\n\n        if (requestParameters.cursor !== undefined) {\n            queryParameters['cursor'] = requestParameters.cursor;\n        }\n\n        if (requestParameters.limit !== undefined) {\n            queryParameters['limit'] = requestParameters.limit;\n        }\n\n        const headerParameters: runtime.HTTPHeaders = {};\n\n        if (this.configuration && this.configuration.apiKey) {\n            queryParameters[\"apikey\"] = this.configuration.apiKey(\"apikey\"); // apikey authentication\n        }\n\n        const response = await this.request({\n            path: `/api/v1/wallets/{walletAddress}/sold-tokens`.replace(`{${\"walletAddress\"}}`, encodeURIComponent(String(requestParameters.walletAddress))),\n            method: 'GET',\n            headers: headerParameters,\n            query: queryParameters,\n        }, initOverrides);\n\n        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TokenFromJSON));\n    }\n\n    /**\n     * Returns a list of tokens sold by a wallet.\n     */\n    async getSoldTokens(requestParameters: GetSoldTokensRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Token>> {\n        const response = await this.getSoldTokensRaw(requestParameters, initOverrides);\n        return await response.value();\n    }\n\n    /**\n     * Get a token by its contract address and token ID.\n     */\n    async getTokenRaw(requestParameters: GetTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Token>>> {\n        if (requestParameters.contractAddress === null || requestParameters.contractAddress === undefined) {\n            throw new runtime.RequiredError('contractAddress','Required parameter requestParameters.contractAddress was null or undefined when calling getToken.');\n        }\n\n        if (requestParameters.tokenID === null || requestParameters.tokenID === undefined) {\n            throw new runtime.RequiredError('tokenID','Required parameter requestParameters.tokenID was null or undefined when calling getToken.');\n        }\n\n        const queryParameters: any = {};\n\n        if (requestParameters.chainID !== undefined) {\n            queryParameters['chainID'] = requestParameters.chainID;\n        }\n\n        const headerParameters: runtime.HTTPHeaders = {};\n\n        if (this.configuration && this.configuration.apiKey) {\n            queryParameters[\"apikey\"] = this.configuration.apiKey(\"apikey\"); // apikey authentication\n        }\n\n        const response = await this.request({\n            path: `/api/v1/tokens/{contractAddress}/{tokenID}`.replace(`{${\"contractAddress\"}}`, encodeURIComponent(String(requestParameters.contractAddress))).replace(`{${\"tokenID\"}}`, encodeURIComponent(String(requestParameters.tokenID))),\n            method: 'GET',\n            headers: headerParameters,\n            query: queryParameters,\n        }, initOverrides);\n\n        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TokenFromJSON));\n    }\n\n    /**\n     * Get a token by its contract address and token ID.\n     */\n    async getToken(requestParameters: GetTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Token>> {\n        const response = await this.getTokenRaw(requestParameters, initOverrides);\n        return await response.value();\n    }\n\n    /**\n     * Determine if a wallet has a given token from a contract.\n     */\n    async getTokenGateRaw(requestParameters: GetTokenGateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TokenGate>> {\n        if (requestParameters.tokenID === null || requestParameters.tokenID === undefined) {\n            throw new runtime.RequiredError('tokenID','Required parameter requestParameters.tokenID was null or undefined when calling getTokenGate.');\n        }\n\n        if (requestParameters.contractAddress === null || requestParameters.contractAddress === undefined) {\n            throw new runtime.RequiredError('contractAddress','Required parameter requestParameters.contractAddress was null or undefined when calling getTokenGate.');\n        }\n\n        if (requestParameters.walletAddress === null || requestParameters.walletAddress === undefined) {\n            throw new runtime.RequiredError('walletAddress','Required parameter requestParameters.walletAddress was null or undefined when calling getTokenGate.');\n        }\n\n        const queryParameters: any = {};\n\n        if (requestParameters.chainID !== undefined) {\n            queryParameters['chainID'] = requestParameters.chainID;\n        }\n\n        const headerParameters: runtime.HTTPHeaders = {};\n\n        if (this.configuration && this.configuration.apiKey) {\n            queryParameters[\"apikey\"] = this.configuration.apiKey(\"apikey\"); // apikey authentication\n        }\n\n        const response = await this.request({\n            path: `/api/v1/wallets/{walletAddress}/gate/{contractAddress}/{tokenID}`.replace(`{${\"tokenID\"}}`, encodeURIComponent(String(requestParameters.tokenID))).replace(`{${\"contractAddress\"}}`, encodeURIComponent(String(requestParameters.contractAddress))).replace(`{${\"walletAddress\"}}`, encodeURIComponent(String(requestParameters.walletAddress))),\n            method: 'GET',\n            headers: headerParameters,\n            query: queryParameters,\n        }, initOverrides);\n\n        return new runtime.JSONApiResponse(response, (jsonValue) => TokenGateFromJSON(jsonValue));\n    }\n\n    /**\n     * Determine if a wallet has a given token from a contract.\n     */\n    async getTokenGate(requestParameters: GetTokenGateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TokenGate> {\n        const response = await this.getTokenGateRaw(requestParameters, initOverrides);\n        return await response.value();\n    }\n\n    /**\n     * Returns a list of transfer transactions on a specified token.\n     */\n    async getTokenTransfersRaw(requestParameters: GetTokenTransfersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TokenEvents>> {\n        if (requestParameters.contractAddress === null || requestParameters.contractAddress === undefined) {\n            throw new runtime.RequiredError('contractAddress','Required parameter requestParameters.contractAddress was null or undefined when calling getTokenTransfers.');\n        }\n\n        if (requestParameters.tokenID === null || requestParameters.tokenID === undefined) {\n            throw new runtime.RequiredError('tokenID','Required parameter requestParameters.tokenID was null or undefined when calling getTokenTransfers.');\n        }\n\n        const queryParameters: any = {};\n\n        if (requestParameters.chainID !== undefined) {\n            queryParameters['chainID'] = requestParameters.chainID;\n        }\n\n        if (requestParameters.limit !== undefined) {\n            queryParameters['limit'] = requestParameters.limit;\n        }\n\n        const headerParameters: runtime.HTTPHeaders = {};\n\n        if (this.configuration && this.configuration.apiKey) {\n            queryParameters[\"apikey\"] = this.configuration.apiKey(\"apikey\"); // apikey authentication\n        }\n\n        const response = await this.request({\n            path: `/api/v1/tokens/{contractAddress}/{tokenID}/transfers`.replace(`{${\"contractAddress\"}}`, encodeURIComponent(String(requestParameters.contractAddress))).replace(`{${\"tokenID\"}}`, encodeURIComponent(String(requestParameters.tokenID))),\n            method: 'GET',\n            headers: headerParameters,\n            query: queryParameters,\n        }, initOverrides);\n\n        return new runtime.JSONApiResponse(response, (jsonValue) => TokenEventsFromJSON(jsonValue));\n    }\n\n    /**\n     * Returns a list of transfer transactions on a specified token.\n     */\n    async getTokenTransfers(requestParameters: GetTokenTransfersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TokenEvents> {\n        const response = await this.getTokenTransfersRaw(requestParameters, initOverrides);\n        return await response.value();\n    }\n\n    /**\n     * Get tokens by a search query.\n     */\n    async getTokensBySearchQueryRaw(requestParameters: GetTokensBySearchQueryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Token>>> {\n        if (requestParameters.query === null || requestParameters.query === undefined) {\n            throw new runtime.RequiredError('query','Required parameter requestParameters.query was null or undefined when calling getTokensBySearchQuery.');\n        }\n\n        const queryParameters: any = {};\n\n        if (requestParameters.cursor !== undefined) {\n            queryParameters['cursor'] = requestParameters.cursor;\n        }\n\n        const headerParameters: runtime.HTTPHeaders = {};\n\n        if (this.configuration && this.configuration.apiKey) {\n            queryParameters[\"apikey\"] = this.configuration.apiKey(\"apikey\"); // apikey authentication\n        }\n\n        const response = await this.request({\n            path: `/api/v1/tokens/search/{query}`.replace(`{${\"query\"}}`, encodeURIComponent(String(requestParameters.query))),\n            method: 'GET',\n            headers: headerParameters,\n            query: queryParameters,\n        }, initOverrides);\n\n        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TokenFromJSON));\n    }\n\n    /**\n     * Get tokens by a search query.\n     */\n    async getTokensBySearchQuery(requestParameters: GetTokensBySearchQueryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Token>> {\n        const response = await this.getTokensBySearchQueryRaw(requestParameters, initOverrides);\n        return await response.value();\n    }\n\n    /**\n     * Get a wallet by a wallet address\n     */\n    async getWalletRaw(requestParameters: GetWalletRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Wallet>>> {\n        if (requestParameters.walletAddress === null || requestParameters.walletAddress === undefined) {\n            throw new runtime.RequiredError('walletAddress','Required parameter requestParameters.walletAddress was null or undefined when calling getWallet.');\n        }\n\n        const queryParameters: any = {};\n\n        if (requestParameters.chainID !== undefined) {\n            queryParameters['chainID'] = requestParameters.chainID;\n        }\n\n        const headerParameters: runtime.HTTPHeaders = {};\n\n        if (this.configuration && this.configuration.apiKey) {\n            queryParameters[\"apikey\"] = this.configuration.apiKey(\"apikey\"); // apikey authentication\n        }\n\n        const response = await this.request({\n            path: `/api/v1/wallets/{walletAddress}`.replace(`{${\"walletAddress\"}}`, encodeURIComponent(String(requestParameters.walletAddress))),\n            method: 'GET',\n            headers: headerParameters,\n            query: queryParameters,\n        }, initOverrides);\n\n        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(WalletFromJSON));\n    }\n\n    /**\n     * Get a wallet by a wallet address\n     */\n    async getWallet(requestParameters: GetWalletRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Wallet>> {\n        const response = await this.getWalletRaw(requestParameters, initOverrides);\n        return await response.value();\n    }\n\n    /**\n     * Returns a list of balances for tokens this wallet currently owns.\n     */\n    async getWalletBalancesRaw(requestParameters: GetWalletBalancesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<CurrencyInfo>>> {\n        if (requestParameters.walletAddress === null || requestParameters.walletAddress === undefined) {\n            throw new runtime.RequiredError('walletAddress','Required parameter requestParameters.walletAddress was null or undefined when calling getWalletBalances.');\n        }\n\n        const queryParameters: any = {};\n\n        if (requestParameters.limit !== undefined) {\n            queryParameters['limit'] = requestParameters.limit;\n        }\n\n        const headerParameters: runtime.HTTPHeaders = {};\n\n        if (this.configuration && this.configuration.apiKey) {\n            queryParameters[\"apikey\"] = this.configuration.apiKey(\"apikey\"); // apikey authentication\n        }\n\n        const response = await this.request({\n            path: `/api/v1/wallets/{walletAddress}/balances`.replace(`{${\"walletAddress\"}}`, encodeURIComponent(String(requestParameters.walletAddress))),\n            method: 'GET',\n            headers: headerParameters,\n            query: queryParameters,\n        }, initOverrides);\n\n        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CurrencyInfoFromJSON));\n    }\n\n    /**\n     * Returns a list of balances for tokens this wallet currently owns.\n     */\n    async getWalletBalances(requestParameters: GetWalletBalancesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<CurrencyInfo>> {\n        const response = await this.getWalletBalancesRaw(requestParameters, initOverrides);\n        return await response.value();\n    }\n\n    /**\n     * Returns a list of tokens minted by a wallet.\n     */\n    async getWalletMintsRaw(requestParameters: GetWalletMintsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Token>>> {\n        if (requestParameters.walletAddress === null || requestParameters.walletAddress === undefined) {\n            throw new runtime.RequiredError('walletAddress','Required parameter requestParameters.walletAddress was null or undefined when calling getWalletMints.');\n        }\n\n        const queryParameters: any = {};\n\n        if (requestParameters.chainID !== undefined) {\n            queryParameters['chainID'] = requestParameters.chainID;\n        }\n\n        if (requestParameters.cursor !== undefined) {\n            queryParameters['cursor'] = requestParameters.cursor;\n        }\n\n        if (requestParameters.limit !== undefined) {\n            queryParameters['limit'] = requestParameters.limit;\n        }\n\n        const headerParameters: runtime.HTTPHeaders = {};\n\n        if (this.configuration && this.configuration.apiKey) {\n            queryParameters[\"apikey\"] = this.configuration.apiKey(\"apikey\"); // apikey authentication\n        }\n\n        const response = await this.request({\n            path: `/api/v1/wallets/{walletAddress}/mints`.replace(`{${\"walletAddress\"}}`, encodeURIComponent(String(requestParameters.walletAddress))),\n            method: 'GET',\n            headers: headerParameters,\n            query: queryParameters,\n        }, initOverrides);\n\n        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TokenFromJSON));\n    }\n\n    /**\n     * Returns a list of tokens minted by a wallet.\n     */\n    async getWalletMints(requestParameters: GetWalletMintsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Token>> {\n        const response = await this.getWalletMintsRaw(requestParameters, initOverrides);\n        return await response.value();\n    }\n\n    /**\n     * Returns a list of tokens owned by a wallet.\n     */\n    async getWalletTokensRaw(requestParameters: GetWalletTokensRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Token>>> {\n        if (requestParameters.walletAddress === null || requestParameters.walletAddress === undefined) {\n            throw new runtime.RequiredError('walletAddress','Required parameter requestParameters.walletAddress was null or undefined when calling getWalletTokens.');\n        }\n\n        const queryParameters: any = {};\n\n        if (requestParameters.cursor !== undefined) {\n            queryParameters['cursor'] = requestParameters.cursor;\n        }\n\n        if (requestParameters.chainID !== undefined) {\n            queryParameters['chainID'] = requestParameters.chainID;\n        }\n\n        if (requestParameters.limit !== undefined) {\n            queryParameters['limit'] = requestParameters.limit;\n        }\n\n        const headerParameters: runtime.HTTPHeaders = {};\n\n        if (this.configuration && this.configuration.apiKey) {\n            queryParameters[\"apikey\"] = this.configuration.apiKey(\"apikey\"); // apikey authentication\n        }\n\n        const response = await this.request({\n            path: `/api/v1/wallets/{walletAddress}/tokens`.replace(`{${\"walletAddress\"}}`, encodeURIComponent(String(requestParameters.walletAddress))),\n            method: 'GET',\n            headers: headerParameters,\n            query: queryParameters,\n        }, initOverrides);\n\n        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TokenFromJSON));\n    }\n\n    /**\n     * Returns a list of tokens owned by a wallet.\n     */\n    async getWalletTokens(requestParameters: GetWalletTokensRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Token>> {\n        const response = await this.getWalletTokensRaw(requestParameters, initOverrides);\n        return await response.value();\n    }\n\n    /**\n     * Returns a list of transactions that have been performed by this wallet. Use token type to restrict to only certain transactions, such as NFTs\n     */\n    async getWalletTransactionsRaw(requestParameters: GetWalletTransactionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Transaction>>> {\n        if (requestParameters.walletAddress === null || requestParameters.walletAddress === undefined) {\n            throw new runtime.RequiredError('walletAddress','Required parameter requestParameters.walletAddress was null or undefined when calling getWalletTransactions.');\n        }\n\n        const queryParameters: any = {};\n\n        if (requestParameters.cursor !== undefined) {\n            queryParameters['cursor'] = requestParameters.cursor;\n        }\n\n        if (requestParameters.limit !== undefined) {\n            queryParameters['limit'] = requestParameters.limit;\n        }\n\n        if (requestParameters.chainID !== undefined) {\n            queryParameters['chainID'] = requestParameters.chainID;\n        }\n\n        if (requestParameters.tokenType !== undefined) {\n            queryParameters['tokenType'] = requestParameters.tokenType;\n        }\n\n        const headerParameters: runtime.HTTPHeaders = {};\n\n        if (this.configuration && this.configuration.apiKey) {\n            queryParameters[\"apikey\"] = this.configuration.apiKey(\"apikey\"); // apikey authentication\n        }\n\n        const response = await this.request({\n            path: `/api/v1/wallets/{walletAddress}/transactions/history`.replace(`{${\"walletAddress\"}}`, encodeURIComponent(String(requestParameters.walletAddress))),\n            method: 'GET',\n            headers: headerParameters,\n            query: queryParameters,\n        }, initOverrides);\n\n        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TransactionFromJSON));\n    }\n\n    /**\n     * Returns a list of transactions that have been performed by this wallet. Use token type to restrict to only certain transactions, such as NFTs\n     */\n    async getWalletTransactions(requestParameters: GetWalletTransactionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Transaction>> {\n        const response = await this.getWalletTransactionsRaw(requestParameters, initOverrides);\n        return await response.value();\n    }\n\n}\n\n/**\n * @export\n */\nexport const GetWalletTransactionsTokenTypeEnum = {\n    Nft: 'NFT',\n    Sft: 'SFT',\n    Unknown: 'unknown'\n} as const;\nexport type GetWalletTransactionsTokenTypeEnum = typeof GetWalletTransactionsTokenTypeEnum[keyof typeof GetWalletTransactionsTokenTypeEnum];\n","/* tslint:disable */\n/* eslint-disable */\nexport * from './AlphaApi';\nexport * from './DefaultApi';\n","/* tslint:disable */\n/* eslint-disable */\nexport * from './runtime';\nexport * from './apis';\nexport * from './models';\n"],"names":[],"version":3,"file":"index.d.ts.map"}