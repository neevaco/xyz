{"mappings":"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","sources":["rxjsStub.ts","http/isomorphic-fetch.ts","http/http.ts","auth/auth.ts","models/AssetGate.ts","models/AutoSuggestion.ts","models/BlockchainInfo.ts","models/MediaPreview.ts","models/CurrencyInfo.ts","models/MediaVersion.ts","models/Media.ts","models/SocialMedia.ts","models/URL.ts","models/Collection.ts","models/CreditEvent.ts","models/ENS.ts","models/ErrorMessage.ts","models/ExchangeEvent.ts","models/TokenAttribute.ts","models/TransactionLogLine.ts","models/Transaction.ts","models/OpenSeaContract.ts","models/Token.ts","models/OwnedCollection.ts","models/Wallet.ts","models/NonFungibleToken.ts","models/SearchDocument.ts","models/TokenEvents.ts","models/all.ts","middleware.ts","servers.ts","configuration.ts","apis/exception.ts","apis/baseapi.ts","models/ObjectSerializer.ts","util.ts","apis/AlphaApi.ts","apis/DefaultApi.ts","types/ObservableAPI.ts","types/PromiseAPI.ts","index.ts"],"sourcesContent":["export class Observable<T> {\n  constructor(private promise: Promise<T>) {}\n\n  toPromise() {\n    return this.promise;\n  }\n\n  pipe<S>(callback: (value: T) => S | Promise<S>): Observable<S> {\n    return new Observable(this.promise.then(callback));\n  }\n}\n\nexport function from<T>(promise: Promise<any>) {\n  return new Observable(promise);\n}\n\nexport function of<T>(value: T) {\n  return new Observable<T>(Promise.resolve(value));\n}\n\nexport function mergeMap<T, S>(callback: (value: T) => Observable<S>) {\n  return (value: T) => callback(value).toPromise();\n}\n\nexport function map(callback: any) {\n  return callback;\n}\n","import {HttpLibrary, RequestContext, ResponseContext} from './http';\nimport { from, Observable } from '../rxjsStub';\nimport \"whatwg-fetch\";\n\nexport class IsomorphicFetchHttpLibrary implements HttpLibrary {\n\n    public send(request: RequestContext): Observable<ResponseContext> {\n        let method = request.getHttpMethod().toString();\n        let body = request.getBody();\n\n        const resultPromise = fetch(request.getUrl(), {\n            method: method,\n            body: body as any,\n            headers: request.getHeaders(),\n            credentials: \"same-origin\"\n        }).then((resp: any) => {\n            const headers: { [name: string]: string } = {};\n            resp.headers.forEach((value: string, name: string) => {\n              headers[name] = value;\n            });\n\n            const body = {\n              text: () => resp.text(),\n              binary: () => resp.blob()\n            };\n            return new ResponseContext(resp.status, headers, body);\n        });\n\n        return from<Promise<ResponseContext>>(resultPromise);\n\n    }\n}\n","import  URLParse from \"url-parse\";\nimport { Observable, from } from '../rxjsStub';\n\nexport * from './isomorphic-fetch';\n\n/**\n * Represents an HTTP method.\n */\nexport enum HttpMethod {\n    GET = \"GET\",\n    HEAD = \"HEAD\",\n    POST = \"POST\",\n    PUT = \"PUT\",\n    DELETE = \"DELETE\",\n    CONNECT = \"CONNECT\",\n    OPTIONS = \"OPTIONS\",\n    TRACE = \"TRACE\",\n    PATCH = \"PATCH\"\n}\n\n/**\n * Represents an HTTP file which will be transferred from or to a server.\n */\nexport type HttpFile = Blob & { readonly name: string };\n\n\nexport class HttpException extends Error {\n    public constructor(msg: string) {\n        super(msg);\n    }\n}\n\n/**\n * Represents the body of an outgoing HTTP request.\n */\nexport type RequestBody = undefined | string | FormData | URLSearchParams;\n\n/**\n * Represents an HTTP request context\n */\nexport class RequestContext {\n    private headers: { [key: string]: string } = {};\n    private body: RequestBody = undefined;\n    private url: URLParse;\n\n    /**\n     * Creates the request context using a http method and request resource url\n     *\n     * @param url url of the requested resource\n     * @param httpMethod http method\n     */\n    public constructor(url: string, private httpMethod: HttpMethod) {\n        this.url = new URLParse(url, true);\n    }\n\n    /*\n     * Returns the url set in the constructor including the query string\n     *\n     */\n    public getUrl(): string {\n        return this.url.toString();\n    }\n\n    /**\n     * Replaces the url set in the constructor with this url.\n     *\n     */\n    public setUrl(url: string) {\n        this.url = new URLParse(url, true);\n    }\n\n    /**\n     * Sets the body of the http request either as a string or FormData\n     *\n     * Note that setting a body on a HTTP GET, HEAD, DELETE, CONNECT or TRACE\n     * request is discouraged.\n     * https://httpwg.org/http-core/draft-ietf-httpbis-semantics-latest.html#rfc.section.7.3.1\n     *\n     * @param body the body of the request\n     */\n    public setBody(body: RequestBody) {\n        this.body = body;\n    }\n\n    public getHttpMethod(): HttpMethod {\n        return this.httpMethod;\n    }\n\n    public getHeaders(): { [key: string]: string } {\n        return this.headers;\n    }\n\n    public getBody(): RequestBody {\n        return this.body;\n    }\n\n    public setQueryParam(name: string, value: string) {\n        let queryObj = this.url.query;\n        queryObj[name] = value;\n        this.url.set(\"query\", queryObj);\n    }\n\n    /**\n     * Sets a cookie with the name and value. NO check  for duplicate cookies is performed\n     *\n     */\n    public addCookie(name: string, value: string): void {\n        if (!this.headers[\"Cookie\"]) {\n            this.headers[\"Cookie\"] = \"\";\n        }\n        this.headers[\"Cookie\"] += name + \"=\" + value + \"; \";\n    }\n\n    public setHeaderParam(key: string, value: string): void  {\n        this.headers[key] = value;\n    }\n}\n\nexport interface ResponseBody {\n    text(): Promise<string>;\n    binary(): Promise<Blob>;\n}\n\n/**\n * Helper class to generate a `ResponseBody` from binary data\n */\nexport class SelfDecodingBody implements ResponseBody {\n    constructor(private dataSource: Promise<Blob>) {}\n\n    binary(): Promise<Blob> {\n        return this.dataSource;\n    }\n\n    async text(): Promise<string> {\n        const data: Blob = await this.dataSource;\n        // @ts-ignore\n        if (data.text) {\n            // @ts-ignore\n            return data.text();\n        }\n\n        return new Promise<string>((resolve, reject) => {\n            const reader = new FileReader();\n            reader.addEventListener(\"load\", () => resolve(reader.result as string));\n            reader.addEventListener(\"error\", () => reject(reader.error));\n            reader.readAsText(data);\n        });\n    }\n}\n\nexport class ResponseContext {\n    public constructor(\n        public httpStatusCode: number,\n        public headers: { [key: string]: string },\n        public body: ResponseBody\n    ) {}\n\n    /**\n     * Parse header value in the form `value; param1=\"value1\"`\n     *\n     * E.g. for Content-Type or Content-Disposition\n     * Parameter names are converted to lower case\n     * The first parameter is returned with the key `\"\"`\n     */\n    public getParsedHeader(headerName: string): { [parameter: string]: string } {\n        const result: { [parameter: string]: string } = {};\n        if (!this.headers[headerName]) {\n            return result;\n        }\n\n        const parameters = this.headers[headerName].split(\";\");\n        for (const parameter of parameters) {\n            let [key, value] = parameter.split(\"=\", 2);\n            key = key.toLowerCase().trim();\n            if (value === undefined) {\n                result[\"\"] = key;\n            } else {\n                value = value.trim();\n                if (value.startsWith('\"') && value.endsWith('\"')) {\n                    value = value.substring(1, value.length - 1);\n                }\n                result[key] = value;\n            }\n        }\n        return result;\n    }\n\n    public async getBodyAsFile(): Promise<HttpFile> {\n        const data = await this.body.binary();\n        const fileName = this.getParsedHeader(\"content-disposition\")[\"filename\"] || \"\";\n        const contentType = this.headers[\"content-type\"] || \"\";\n        try {\n            return new File([data], fileName, { type: contentType });\n        } catch (error) {\n            /** Fallback for when the File constructor is not available */\n            return Object.assign(data, {\n                name: fileName,\n                type: contentType\n            });\n        }\n    }\n\n    /**\n     * Use a heuristic to get a body of unknown data structure.\n     * Return as string if possible, otherwise as binary.\n     */\n    public getBodyAsAny(): Promise<string | Blob | undefined> {\n        try {\n            return this.body.text();\n        } catch {}\n\n        try {\n            return this.body.binary();\n        } catch {}\n\n        return Promise.resolve(undefined);\n    }\n}\n\nexport interface HttpLibrary {\n    send(request: RequestContext): Observable<ResponseContext>;\n}\n\nexport interface PromiseHttpLibrary {\n    send(request: RequestContext): Promise<ResponseContext>;\n}\n\nexport function wrapHttpLibrary(promiseHttpLibrary: PromiseHttpLibrary): HttpLibrary {\n  return {\n    send(request: RequestContext): Observable<ResponseContext> {\n      return from(promiseHttpLibrary.send(request));\n    }\n  }\n}\n","import { RequestContext } from \"../http/http\";\n\n/**\n * Interface authentication schemes.\n */\nexport interface SecurityAuthentication {\n    /*\n     * @return returns the name of the security authentication as specified in OAI\n     */\n    getName(): string;\n\n    /**\n     * Applies the authentication scheme to the request context\n     *\n     * @params context the request context which should use this authentication scheme\n     */\n    applySecurityAuthentication(context: RequestContext): void | Promise<void>;\n}\n\nexport interface TokenProvider {\n  getToken(): Promise<string> | string;\n}\n\n/**\n * Applies apiKey authentication to the request context.\n */\nexport class ApikeyAuthentication implements SecurityAuthentication {\n    /**\n     * Configures this api key authentication with the necessary properties\n     *\n     * @param apiKey: The api key to be used for every request\n     */\n    public constructor(private apiKey: string) {}\n\n    public getName(): string {\n        return \"apikey\";\n    }\n\n    public applySecurityAuthentication(context: RequestContext) {\n        context.setQueryParam(\"apikey\", this.apiKey);\n    }\n}\n\n\nexport type AuthMethods = {\n    \"default\"?: SecurityAuthentication,\n    \"apikey\"?: SecurityAuthentication\n}\n\nexport type ApiKeyConfiguration = string;\nexport type HttpBasicConfiguration = { \"username\": string, \"password\": string };\nexport type HttpBearerConfiguration = { tokenProvider: TokenProvider };\nexport type OAuth2Configuration = { accessToken: string };\n\nexport type AuthMethodsConfiguration = {\n    \"default\"?: SecurityAuthentication,\n    \"apikey\"?: ApiKeyConfiguration\n}\n\n/**\n * Creates the authentication methods from a swagger description.\n *\n */\nexport function configureAuthMethods(config: AuthMethodsConfiguration | undefined): AuthMethods {\n    let authMethods: AuthMethods = {}\n\n    if (!config) {\n        return authMethods;\n    }\n    authMethods[\"default\"] = config[\"default\"]\n\n    if (config[\"apikey\"]) {\n        authMethods[\"apikey\"] = new ApikeyAuthentication(\n            config[\"apikey\"]\n        );\n    }\n\n    return authMethods;\n}","/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * OpenAPI spec version: 0.23.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { HttpFile } from '../http/http';\n\nexport class AssetGate {\n    /**\n    * True when the given wallet owns any token from a given contract.\n    */\n    'hasContract': boolean;\n    /**\n    * Only true when the given wallet owns a particular token from a given contract.\n    */\n    'hasToken': boolean;\n\n    static readonly discriminator: string | undefined = undefined;\n\n    static readonly attributeTypeMap: Array<{name: string, baseName: string, type: string, format: string}> = [\n        {\n            \"name\": \"hasContract\",\n            \"baseName\": \"hasContract\",\n            \"type\": \"boolean\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"hasToken\",\n            \"baseName\": \"hasToken\",\n            \"type\": \"boolean\",\n            \"format\": \"\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return AssetGate.attributeTypeMap;\n    }\n\n    public constructor() {\n    }\n}\n\n","/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * OpenAPI spec version: 0.23.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { HttpFile } from '../http/http';\n\nexport class AutoSuggestion {\n    /**\n    * A URL-encoded string that can be used in conjunction with the search endpoint\n    */\n    'query'?: string;\n    /**\n    * The suggestion result's title fully spelled out\n    */\n    'title'?: string;\n    /**\n    * The type of result the suggestion is based on, e.g. Bored Ape Yacht Club would be a collection.\n    */\n    'type'?: AutoSuggestionTypeEnum;\n\n    static readonly discriminator: string | undefined = undefined;\n\n    static readonly attributeTypeMap: Array<{name: string, baseName: string, type: string, format: string}> = [\n        {\n            \"name\": \"query\",\n            \"baseName\": \"query\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"title\",\n            \"baseName\": \"title\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"type\",\n            \"baseName\": \"type\",\n            \"type\": \"AutoSuggestionTypeEnum\",\n            \"format\": \"\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return AutoSuggestion.attributeTypeMap;\n    }\n\n    public constructor() {\n    }\n}\n\n\nexport type AutoSuggestionTypeEnum = \"query\" | \"collection\" | \"wallet\" | \"token\" ;\n\n","/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * OpenAPI spec version: 0.23.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { HttpFile } from '../http/http';\n\nexport class BlockchainInfo {\n    /**\n    * A CAIP-2 compliant chain ID. This ID is designed to provide a unique identifier for a given chain.\n    */\n    'chainID'?: string;\n    /**\n    * The name of a given chain. This is often a canonical name since a protocol may have multiple chains.\n    */\n    'name'?: string;\n    /**\n    * An ID used for a chain in a given ecosystem. This ID is not canonical and may collide with other chains. Do not use this value as a unique identifier.\n    */\n    'shortChainID'?: string;\n    /**\n    * The short-hand name for a given chain. Multiple chains (e.g. mainnet and a testnet) may have the same name.\n    */\n    'shortName'?: string;\n\n    static readonly discriminator: string | undefined = undefined;\n\n    static readonly attributeTypeMap: Array<{name: string, baseName: string, type: string, format: string}> = [\n        {\n            \"name\": \"chainID\",\n            \"baseName\": \"chainID\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"name\",\n            \"baseName\": \"name\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"shortChainID\",\n            \"baseName\": \"shortChainID\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"shortName\",\n            \"baseName\": \"shortName\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return BlockchainInfo.attributeTypeMap;\n    }\n\n    public constructor() {\n    }\n}\n\n","/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * OpenAPI spec version: 0.23.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { HttpFile } from '../http/http';\n\nexport class MediaPreview {\n    /**\n    * URI for the image asset.\n    */\n    'URI'?: string;\n    /**\n    * If a video, length of video in ISO 8601 duration format.\n    */\n    'duration'?: string;\n    'format'?: string;\n    /**\n    * The image's approximate height in pixels.\n    */\n    'height'?: number;\n    'kind'?: MediaPreviewKindEnum;\n    /**\n    * The image's approximate width in pixels.\n    */\n    'width'?: number;\n\n    static readonly discriminator: string | undefined = undefined;\n\n    static readonly attributeTypeMap: Array<{name: string, baseName: string, type: string, format: string}> = [\n        {\n            \"name\": \"URI\",\n            \"baseName\": \"URI\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"duration\",\n            \"baseName\": \"duration\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"format\",\n            \"baseName\": \"format\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"height\",\n            \"baseName\": \"height\",\n            \"type\": \"number\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"kind\",\n            \"baseName\": \"kind\",\n            \"type\": \"MediaPreviewKindEnum\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"width\",\n            \"baseName\": \"width\",\n            \"type\": \"number\",\n            \"format\": \"\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return MediaPreview.attributeTypeMap;\n    }\n\n    public constructor() {\n    }\n}\n\n\nexport type MediaPreviewKindEnum = \"video\" | \"image\" | \"raw\" | \"audio\" ;\n\n","/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * OpenAPI spec version: 0.23.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { MediaPreview } from './MediaPreview';\nimport { HttpFile } from '../http/http';\n\nexport class CurrencyInfo {\n    'contractAddress'?: string;\n    /**\n    * The base value for a given token. For Ethereum this would be 18. This would yield an equation such as 890000000000000000wei / 10^18 = 0.89 ETH.\n    */\n    'decimals'?: number;\n    /**\n    * The total value of this token in fiat currency.\n    */\n    'fiat'?: Array<CurrencyInfo>;\n    'name'?: string;\n    /**\n    * A formatted, human-friendly representation of the transaction value, e.g. the value in Ether, possibly with localized thousands separator and radix character.\n    */\n    'pretty'?: string;\n    'symbol'?: string;\n    /**\n    * Logo images associated with the token for a given currency.\n    */\n    'symbolLogos'?: Array<MediaPreview>;\n    /**\n    * Transaction value as a float representing the amount of tokens, e.g. 0.89 would be 89% of a token.\n    */\n    'tokenValue'?: number;\n    /**\n    * Transaction value as a string-encoded bigint in the base unit for a given blockchain (e.g. wei for Ethereum) or fiat currency (e.g. US Dollars).\n    */\n    'value'?: string;\n\n    static readonly discriminator: string | undefined = undefined;\n\n    static readonly attributeTypeMap: Array<{name: string, baseName: string, type: string, format: string}> = [\n        {\n            \"name\": \"contractAddress\",\n            \"baseName\": \"contractAddress\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"decimals\",\n            \"baseName\": \"decimals\",\n            \"type\": \"number\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"fiat\",\n            \"baseName\": \"fiat\",\n            \"type\": \"Array<CurrencyInfo>\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"name\",\n            \"baseName\": \"name\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"pretty\",\n            \"baseName\": \"pretty\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"symbol\",\n            \"baseName\": \"symbol\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"symbolLogos\",\n            \"baseName\": \"symbolLogos\",\n            \"type\": \"Array<MediaPreview>\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"tokenValue\",\n            \"baseName\": \"tokenValue\",\n            \"type\": \"number\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"value\",\n            \"baseName\": \"value\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return CurrencyInfo.attributeTypeMap;\n    }\n\n    public constructor() {\n    }\n}\n\n","/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * OpenAPI spec version: 0.23.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { HttpFile } from '../http/http';\n\nexport class MediaVersion {\n    /**\n    * If a video, length of video in ISO 8601 duration format.\n    */\n    'duration'?: string;\n    'format'?: string;\n    'height'?: number;\n    'kind'?: MediaVersionKindEnum;\n    'numBytes'?: number;\n    'width'?: number;\n\n    static readonly discriminator: string | undefined = undefined;\n\n    static readonly attributeTypeMap: Array<{name: string, baseName: string, type: string, format: string}> = [\n        {\n            \"name\": \"duration\",\n            \"baseName\": \"duration\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"format\",\n            \"baseName\": \"format\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"height\",\n            \"baseName\": \"height\",\n            \"type\": \"number\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"kind\",\n            \"baseName\": \"kind\",\n            \"type\": \"MediaVersionKindEnum\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"numBytes\",\n            \"baseName\": \"numBytes\",\n            \"type\": \"number\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"width\",\n            \"baseName\": \"width\",\n            \"type\": \"number\",\n            \"format\": \"\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return MediaVersion.attributeTypeMap;\n    }\n\n    public constructor() {\n    }\n}\n\n\nexport type MediaVersionKindEnum = \"video\" | \"image\" | \"raw\" | \"audio\" ;\n\n","/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * OpenAPI spec version: 0.23.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { MediaVersion } from './MediaVersion';\nimport { HttpFile } from '../http/http';\n\nexport class Media {\n    /**\n    * URI for the image asset.\n    */\n    'URI'?: string;\n    'key': string;\n    'version'?: Array<MediaVersion>;\n\n    static readonly discriminator: string | undefined = undefined;\n\n    static readonly attributeTypeMap: Array<{name: string, baseName: string, type: string, format: string}> = [\n        {\n            \"name\": \"URI\",\n            \"baseName\": \"URI\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"key\",\n            \"baseName\": \"key\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"version\",\n            \"baseName\": \"version\",\n            \"type\": \"Array<MediaVersion>\",\n            \"format\": \"\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return Media.attributeTypeMap;\n    }\n\n    public constructor() {\n    }\n}\n\n","/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * OpenAPI spec version: 0.23.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { HttpFile } from '../http/http';\n\nexport class SocialMedia {\n    'network'?: string;\n    'username'?: string;\n\n    static readonly discriminator: string | undefined = undefined;\n\n    static readonly attributeTypeMap: Array<{name: string, baseName: string, type: string, format: string}> = [\n        {\n            \"name\": \"network\",\n            \"baseName\": \"network\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"username\",\n            \"baseName\": \"username\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return SocialMedia.attributeTypeMap;\n    }\n\n    public constructor() {\n    }\n}\n\n","/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * OpenAPI spec version: 0.23.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { HttpFile } from '../http/http';\n\nexport class URL {\n    /**\n    * Human-readable name of the site.\n    */\n    'name'?: string;\n    'url'?: string;\n\n    static readonly discriminator: string | undefined = undefined;\n\n    static readonly attributeTypeMap: Array<{name: string, baseName: string, type: string, format: string}> = [\n        {\n            \"name\": \"name\",\n            \"baseName\": \"name\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"url\",\n            \"baseName\": \"url\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return URL.attributeTypeMap;\n    }\n\n    public constructor() {\n    }\n}\n\n","/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * OpenAPI spec version: 0.23.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { BlockchainInfo } from './BlockchainInfo';\nimport { CurrencyInfo } from './CurrencyInfo';\nimport { Media } from './Media';\nimport { SocialMedia } from './SocialMedia';\nimport { URL } from './URL';\nimport { HttpFile } from '../http/http';\n\nexport class Collection {\n    'bannerImage'?: Media;\n    'blockchain': BlockchainInfo;\n    /**\n    * Address of the contract that minted this NFT.\n    */\n    'contractAddress': string;\n    /**\n    * Timestamp of creation of this contract in RFC 3339.\n    */\n    'createdDate'?: Date;\n    'description'?: string;\n    'featuredImage'?: Media;\n    'floorPrice'?: CurrencyInfo;\n    'name'?: string;\n    'shortDescription'?: string;\n    'slug'?: string;\n    'socialMedia'?: Array<SocialMedia>;\n    'symbol'?: string;\n    'urls'?: Array<URL>;\n\n    static readonly discriminator: string | undefined = undefined;\n\n    static readonly attributeTypeMap: Array<{name: string, baseName: string, type: string, format: string}> = [\n        {\n            \"name\": \"bannerImage\",\n            \"baseName\": \"bannerImage\",\n            \"type\": \"Media\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"blockchain\",\n            \"baseName\": \"blockchain\",\n            \"type\": \"BlockchainInfo\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"contractAddress\",\n            \"baseName\": \"contractAddress\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"createdDate\",\n            \"baseName\": \"createdDate\",\n            \"type\": \"Date\",\n            \"format\": \"date-time\"\n        },\n        {\n            \"name\": \"description\",\n            \"baseName\": \"description\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"featuredImage\",\n            \"baseName\": \"featuredImage\",\n            \"type\": \"Media\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"floorPrice\",\n            \"baseName\": \"floorPrice\",\n            \"type\": \"CurrencyInfo\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"name\",\n            \"baseName\": \"name\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"shortDescription\",\n            \"baseName\": \"shortDescription\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"slug\",\n            \"baseName\": \"slug\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"socialMedia\",\n            \"baseName\": \"socialMedia\",\n            \"type\": \"Array<SocialMedia>\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"symbol\",\n            \"baseName\": \"symbol\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"urls\",\n            \"baseName\": \"urls\",\n            \"type\": \"Array<URL>\",\n            \"format\": \"\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return Collection.attributeTypeMap;\n    }\n\n    public constructor() {\n    }\n}\n\n","/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * OpenAPI spec version: 0.23.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { HttpFile } from '../http/http';\n\nexport class CreditEvent {\n    /**\n    * Human-readable, machine parsable, event descriptions for credit-related contract events\n    */\n    'event'?: CreditEventEventEnum;\n    /**\n    * Brand or identifier closely associated with a contract\n    */\n    'protocol'?: string;\n\n    static readonly discriminator: string | undefined = undefined;\n\n    static readonly attributeTypeMap: Array<{name: string, baseName: string, type: string, format: string}> = [\n        {\n            \"name\": \"event\",\n            \"baseName\": \"event\",\n            \"type\": \"CreditEventEventEnum\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"protocol\",\n            \"baseName\": \"protocol\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return CreditEvent.attributeTypeMap;\n    }\n\n    public constructor() {\n    }\n}\n\n\nexport type CreditEventEventEnum = \"Supply\" | \"Withdraw\" | \"Borrow\" | \"Repay\" | \"Accrue Interest\" | \"Flash Loan\" ;\n\n","/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * OpenAPI spec version: 0.23.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { HttpFile } from '../http/http';\n\nexport class ENS {\n    /**\n    * Date the ENS registration expires.\n    */\n    'expires'?: Date;\n    /**\n    * A wallet address can have multiple ENS records. The primary ENS name represents a \\\"cross-platform web3 username and profile.\\\" A wallet address can only have one primary name, and it can change at any time.\n    */\n    'isPrimary'?: boolean;\n    /**\n    * The ENS or domain name.\n    */\n    'name'?: string;\n    /**\n    * The address the ENS record points to.\n    */\n    'pointsTo'?: string;\n\n    static readonly discriminator: string | undefined = undefined;\n\n    static readonly attributeTypeMap: Array<{name: string, baseName: string, type: string, format: string}> = [\n        {\n            \"name\": \"expires\",\n            \"baseName\": \"expires\",\n            \"type\": \"Date\",\n            \"format\": \"date-time\"\n        },\n        {\n            \"name\": \"isPrimary\",\n            \"baseName\": \"isPrimary\",\n            \"type\": \"boolean\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"name\",\n            \"baseName\": \"name\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"pointsTo\",\n            \"baseName\": \"pointsTo\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return ENS.attributeTypeMap;\n    }\n\n    public constructor() {\n    }\n}\n\n","/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * OpenAPI spec version: 0.23.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { HttpFile } from '../http/http';\n\nexport class ErrorMessage {\n    'error': string;\n\n    static readonly discriminator: string | undefined = undefined;\n\n    static readonly attributeTypeMap: Array<{name: string, baseName: string, type: string, format: string}> = [\n        {\n            \"name\": \"error\",\n            \"baseName\": \"error\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return ErrorMessage.attributeTypeMap;\n    }\n\n    public constructor() {\n    }\n}\n\n","/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * OpenAPI spec version: 0.23.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { HttpFile } from '../http/http';\n\nexport class ExchangeEvent {\n    /**\n    * Human-readable, machine parsable, event descriptions for token exchange-related contract events\n    */\n    'event'?: ExchangeEventEventEnum;\n    /**\n    * Brand or identifier closely associated with a contract\n    */\n    'protocol'?: string;\n\n    static readonly discriminator: string | undefined = undefined;\n\n    static readonly attributeTypeMap: Array<{name: string, baseName: string, type: string, format: string}> = [\n        {\n            \"name\": \"event\",\n            \"baseName\": \"event\",\n            \"type\": \"ExchangeEventEventEnum\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"protocol\",\n            \"baseName\": \"protocol\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return ExchangeEvent.attributeTypeMap;\n    }\n\n    public constructor() {\n    }\n}\n\n\nexport type ExchangeEventEventEnum = \"Swap\" | \"Mint\" | \"Burn\" | \"Collect Fees\" | \"Create Pool\" ;\n\n","/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * OpenAPI spec version: 0.23.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { HttpFile } from '../http/http';\n\nexport class TokenAttribute {\n    /**\n    * The key or kind of trait.\n    */\n    'traitType'?: string;\n    /**\n    * A distinct attribute belonging to a particular type of trait.\n    */\n    'value'?: string;\n\n    static readonly discriminator: string | undefined = undefined;\n\n    static readonly attributeTypeMap: Array<{name: string, baseName: string, type: string, format: string}> = [\n        {\n            \"name\": \"traitType\",\n            \"baseName\": \"traitType\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"value\",\n            \"baseName\": \"value\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return TokenAttribute.attributeTypeMap;\n    }\n\n    public constructor() {\n    }\n}\n\n","/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * OpenAPI spec version: 0.23.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { CurrencyInfo } from './CurrencyInfo';\nimport { HttpFile } from '../http/http';\n\nexport class TransactionLogLine {\n    /**\n    * When the value is true, it indicates that a token has been burned, and this transaction corresponds to the burn.\n    */\n    'burned'?: boolean;\n    'fromAddress'?: string;\n    /**\n    * Index of the log in the transaction.\n    */\n    'logIndex'?: number;\n    /**\n    * When the value is true, it indicates this is the transaction representing a token minting.\n    */\n    'mint'?: boolean;\n    'price'?: CurrencyInfo;\n    'toAddress'?: string;\n\n    static readonly discriminator: string | undefined = undefined;\n\n    static readonly attributeTypeMap: Array<{name: string, baseName: string, type: string, format: string}> = [\n        {\n            \"name\": \"burned\",\n            \"baseName\": \"burned\",\n            \"type\": \"boolean\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"fromAddress\",\n            \"baseName\": \"fromAddress\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"logIndex\",\n            \"baseName\": \"logIndex\",\n            \"type\": \"number\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"mint\",\n            \"baseName\": \"mint\",\n            \"type\": \"boolean\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"price\",\n            \"baseName\": \"price\",\n            \"type\": \"CurrencyInfo\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"toAddress\",\n            \"baseName\": \"toAddress\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return TransactionLogLine.attributeTypeMap;\n    }\n\n    public constructor() {\n    }\n}\n\n","/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * OpenAPI spec version: 0.23.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { CurrencyInfo } from './CurrencyInfo';\nimport { TransactionLogLine } from './TransactionLogLine';\nimport { HttpFile } from '../http/http';\n\nexport class Transaction {\n    /**\n    * Block number of the transaction.\n    */\n    'blockNumber'?: number;\n    'gasFee'?: CurrencyInfo;\n    /**\n    * Log lines related to the transaction.\n    */\n    'logLine'?: Array<TransactionLogLine>;\n    /**\n    * Timestamp of the transaction in RFC 3339.\n    */\n    'timestamp'?: Date;\n    /**\n    * A token ID if the transaction was related to an NFT\n    */\n    'tokenID'?: string;\n    /**\n    * TransactionHash for this transaction.\n    */\n    'transactionHash'?: string;\n    /**\n    * Index of the transaction in the block.\n    */\n    'transactionIndex'?: number;\n\n    static readonly discriminator: string | undefined = undefined;\n\n    static readonly attributeTypeMap: Array<{name: string, baseName: string, type: string, format: string}> = [\n        {\n            \"name\": \"blockNumber\",\n            \"baseName\": \"blockNumber\",\n            \"type\": \"number\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"gasFee\",\n            \"baseName\": \"gasFee\",\n            \"type\": \"CurrencyInfo\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"logLine\",\n            \"baseName\": \"logLine\",\n            \"type\": \"Array<TransactionLogLine>\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"timestamp\",\n            \"baseName\": \"timestamp\",\n            \"type\": \"Date\",\n            \"format\": \"date-time\"\n        },\n        {\n            \"name\": \"tokenID\",\n            \"baseName\": \"tokenID\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"transactionHash\",\n            \"baseName\": \"transactionHash\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"transactionIndex\",\n            \"baseName\": \"transactionIndex\",\n            \"type\": \"number\",\n            \"format\": \"\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return Transaction.attributeTypeMap;\n    }\n\n    public constructor() {\n    }\n}\n\n","/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * OpenAPI spec version: 0.23.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { HttpFile } from '../http/http';\n\nexport class OpenSeaContract {\n    'assetContractType'?: OpenSeaContractAssetContractTypeEnum;\n    /**\n    * Total fee levied on buyers by this contract, in basis points\n    */\n    'buyerFeeBasisPoints'?: number;\n    'defaultToFiat'?: boolean;\n    /**\n    * The NFT Version\n    */\n    'nftVersion'?: string;\n    /**\n    * The OpenSea Version\n    */\n    'openSeaVersion'?: string;\n    /**\n    * Total fee levied on sellers by this contract, in basis points\n    */\n    'sellerFeeBasisPoints'?: number;\n\n    static readonly discriminator: string | undefined = undefined;\n\n    static readonly attributeTypeMap: Array<{name: string, baseName: string, type: string, format: string}> = [\n        {\n            \"name\": \"assetContractType\",\n            \"baseName\": \"assetContractType\",\n            \"type\": \"OpenSeaContractAssetContractTypeEnum\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"buyerFeeBasisPoints\",\n            \"baseName\": \"buyerFeeBasisPoints\",\n            \"type\": \"number\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"defaultToFiat\",\n            \"baseName\": \"defaultToFiat\",\n            \"type\": \"boolean\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"nftVersion\",\n            \"baseName\": \"nftVersion\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"openSeaVersion\",\n            \"baseName\": \"openSeaVersion\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"sellerFeeBasisPoints\",\n            \"baseName\": \"sellerFeeBasisPoints\",\n            \"type\": \"number\",\n            \"format\": \"\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return OpenSeaContract.attributeTypeMap;\n    }\n\n    public constructor() {\n    }\n}\n\n\nexport type OpenSeaContractAssetContractTypeEnum = \"NFT\" | \"SFT\" | \"unknown\" ;\n\n","/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * OpenAPI spec version: 0.23.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { BlockchainInfo } from './BlockchainInfo';\nimport { NonFungibleToken } from './NonFungibleToken';\nimport { OpenSeaContract } from './OpenSeaContract';\nimport { HttpFile } from '../http/http';\n\nexport class Token {\n    'blockchain': BlockchainInfo;\n    /**\n    * Address of the contract that minted this NFT.\n    */\n    'contractAddress': string;\n    'nft'?: NonFungibleToken;\n    'openSeaContract'?: OpenSeaContract;\n    'symbol'?: string;\n    'tokenStandard'?: string;\n\n    static readonly discriminator: string | undefined = undefined;\n\n    static readonly attributeTypeMap: Array<{name: string, baseName: string, type: string, format: string}> = [\n        {\n            \"name\": \"blockchain\",\n            \"baseName\": \"blockchain\",\n            \"type\": \"BlockchainInfo\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"contractAddress\",\n            \"baseName\": \"contractAddress\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"nft\",\n            \"baseName\": \"nft\",\n            \"type\": \"NonFungibleToken\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"openSeaContract\",\n            \"baseName\": \"openSeaContract\",\n            \"type\": \"OpenSeaContract\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"symbol\",\n            \"baseName\": \"symbol\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"tokenStandard\",\n            \"baseName\": \"tokenStandard\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return Token.attributeTypeMap;\n    }\n\n    public constructor() {\n    }\n}\n\n","/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * OpenAPI spec version: 0.23.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { Collection } from './Collection';\nimport { CurrencyInfo } from './CurrencyInfo';\nimport { Token } from './Token';\nimport { HttpFile } from '../http/http';\n\nexport class OwnedCollection {\n    'collection'?: Collection;\n    /**\n    * A sample of the tokens owned by this wallet.\n    */\n    'tokens'?: Array<Token>;\n    'totalSpent'?: CurrencyInfo;\n\n    static readonly discriminator: string | undefined = undefined;\n\n    static readonly attributeTypeMap: Array<{name: string, baseName: string, type: string, format: string}> = [\n        {\n            \"name\": \"collection\",\n            \"baseName\": \"collection\",\n            \"type\": \"Collection\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"tokens\",\n            \"baseName\": \"tokens\",\n            \"type\": \"Array<Token>\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"totalSpent\",\n            \"baseName\": \"totalSpent\",\n            \"type\": \"CurrencyInfo\",\n            \"format\": \"\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return OwnedCollection.attributeTypeMap;\n    }\n\n    public constructor() {\n    }\n}\n\n","/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * OpenAPI spec version: 0.23.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { CurrencyInfo } from './CurrencyInfo';\nimport { ENS } from './ENS';\nimport { OwnedCollection } from './OwnedCollection';\nimport { SocialMedia } from './SocialMedia';\nimport { Token } from './Token';\nimport { Transaction } from './Transaction';\nimport { HttpFile } from '../http/http';\n\nexport class Wallet {\n    'address': string;\n    /**\n    * The balance of fungible tokens from smart contracts or blockchains. Certain non-standard ERC-20 tokens (e.g. stETH) may occasionally have stale balances, for example interest payments can be slow to update.\n    */\n    'balances'?: Array<CurrencyInfo>;\n    /**\n    * A sample of the collections this wallet owns.\n    */\n    'collections'?: Array<OwnedCollection>;\n    'ens'?: Array<ENS>;\n    /**\n    * A reverse-chronological list of the latest transactions for a wallet.\n    */\n    'history'?: Array<Transaction>;\n    /**\n    * A sample of the most recently transferred tokens owned by this wallet.\n    */\n    'recentTokens'?: Array<Token>;\n    'socialMedia'?: Array<SocialMedia>;\n    /**\n    * A sample of the most expensive tokens owned by this wallet.\n    */\n    'topTokens'?: Array<Token>;\n    /**\n    * The total balance in a fiat currency (e.g. USD) for the wallet.\n    */\n    'totalBalance'?: Array<CurrencyInfo>;\n\n    static readonly discriminator: string | undefined = undefined;\n\n    static readonly attributeTypeMap: Array<{name: string, baseName: string, type: string, format: string}> = [\n        {\n            \"name\": \"address\",\n            \"baseName\": \"address\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"balances\",\n            \"baseName\": \"balances\",\n            \"type\": \"Array<CurrencyInfo>\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"collections\",\n            \"baseName\": \"collections\",\n            \"type\": \"Array<OwnedCollection>\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"ens\",\n            \"baseName\": \"ens\",\n            \"type\": \"Array<ENS>\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"history\",\n            \"baseName\": \"history\",\n            \"type\": \"Array<Transaction>\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"recentTokens\",\n            \"baseName\": \"recentTokens\",\n            \"type\": \"Array<Token>\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"socialMedia\",\n            \"baseName\": \"socialMedia\",\n            \"type\": \"Array<SocialMedia>\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"topTokens\",\n            \"baseName\": \"topTokens\",\n            \"type\": \"Array<Token>\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"totalBalance\",\n            \"baseName\": \"totalBalance\",\n            \"type\": \"Array<CurrencyInfo>\",\n            \"format\": \"\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return Wallet.attributeTypeMap;\n    }\n\n    public constructor() {\n    }\n}\n\n","/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * OpenAPI spec version: 0.23.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { Collection } from './Collection';\nimport { Media } from './Media';\nimport { MediaPreview } from './MediaPreview';\nimport { TokenAttribute } from './TokenAttribute';\nimport { Transaction } from './Transaction';\nimport { Wallet } from './Wallet';\nimport { HttpFile } from '../http/http';\n\nexport class NonFungibleToken {\n    'attributes'?: Array<TokenAttribute>;\n    'collection'?: Collection;\n    'contractTitle'?: string;\n    /**\n    * A description of a contract may contain markup such as HTML or Markdown.\n    */\n    'description'?: string;\n    /**\n    * A rough heuristic indicating the underlying technology and hypothetical durability of an asset. \\\"On-Chain\\\" assets store metadata and the asset media (e.g. SVG file, source code or MIDI) on a blockchain. \\\"Distributed\\\" assets are stored on decentralized protocols such as IPFS. \\\"Web\\\" assets are stored on services such as Amazon's S3. Each technology has different tradeoffs, in particular certain projects need more flexibility than is provided by on-chain data.\\\"\n    */\n    'durability'?: NonFungibleTokenDurabilityEnum;\n    'media'?: Media;\n    'owner'?: Wallet;\n    /**\n    * Transformed media assets that are resized and transcoded in to friendlier formats for web and mobile delivery.\n    */\n    'previews'?: Array<MediaPreview>;\n    /**\n    * The project name of the NFT.\n    */\n    'projectName'?: string;\n    'purchase'?: Transaction;\n    'title'?: string;\n    /**\n    * ID of this particular token.\n    */\n    'tokenID': string;\n\n    static readonly discriminator: string | undefined = undefined;\n\n    static readonly attributeTypeMap: Array<{name: string, baseName: string, type: string, format: string}> = [\n        {\n            \"name\": \"attributes\",\n            \"baseName\": \"attributes\",\n            \"type\": \"Array<TokenAttribute>\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"collection\",\n            \"baseName\": \"collection\",\n            \"type\": \"Collection\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"contractTitle\",\n            \"baseName\": \"contractTitle\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"description\",\n            \"baseName\": \"description\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"durability\",\n            \"baseName\": \"durability\",\n            \"type\": \"NonFungibleTokenDurabilityEnum\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"media\",\n            \"baseName\": \"media\",\n            \"type\": \"Media\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"owner\",\n            \"baseName\": \"owner\",\n            \"type\": \"Wallet\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"previews\",\n            \"baseName\": \"previews\",\n            \"type\": \"Array<MediaPreview>\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"projectName\",\n            \"baseName\": \"projectName\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"purchase\",\n            \"baseName\": \"purchase\",\n            \"type\": \"Transaction\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"title\",\n            \"baseName\": \"title\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"tokenID\",\n            \"baseName\": \"tokenID\",\n            \"type\": \"string\",\n            \"format\": \"\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return NonFungibleToken.attributeTypeMap;\n    }\n\n    public constructor() {\n    }\n}\n\n\nexport type NonFungibleTokenDurabilityEnum = \"On-Chain\" | \"Decentralized\" | \"Web\" | \"Unknown\" ;\n\n","/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * OpenAPI spec version: 0.23.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { Collection } from './Collection';\nimport { Token } from './Token';\nimport { Wallet } from './Wallet';\nimport { HttpFile } from '../http/http';\n\nexport class SearchDocument {\n    'collection'?: Collection;\n    'token'?: Token;\n    'wallet'?: Wallet;\n\n    static readonly discriminator: string | undefined = undefined;\n\n    static readonly attributeTypeMap: Array<{name: string, baseName: string, type: string, format: string}> = [\n        {\n            \"name\": \"collection\",\n            \"baseName\": \"collection\",\n            \"type\": \"Collection\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"token\",\n            \"baseName\": \"token\",\n            \"type\": \"Token\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"wallet\",\n            \"baseName\": \"wallet\",\n            \"type\": \"Wallet\",\n            \"format\": \"\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return SearchDocument.attributeTypeMap;\n    }\n\n    public constructor() {\n    }\n}\n\n","/**\n * n.xyz REST API\n * REST API for blockchain data.\n *\n * OpenAPI spec version: 0.23.0\n * \n *\n * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).\n * https://openapi-generator.tech\n * Do not edit the class manually.\n */\n\nimport { Token } from './Token';\nimport { Transaction } from './Transaction';\nimport { HttpFile } from '../http/http';\n\nexport class TokenEvents {\n    /**\n    * A list of the events for a token.\n    */\n    'events'?: Array<Transaction>;\n    /**\n    * Metadata for the token specified in the request.\n    */\n    'token'?: Array<Token>;\n\n    static readonly discriminator: string | undefined = undefined;\n\n    static readonly attributeTypeMap: Array<{name: string, baseName: string, type: string, format: string}> = [\n        {\n            \"name\": \"events\",\n            \"baseName\": \"events\",\n            \"type\": \"Array<Transaction>\",\n            \"format\": \"\"\n        },\n        {\n            \"name\": \"token\",\n            \"baseName\": \"token\",\n            \"type\": \"Array<Token>\",\n            \"format\": \"\"\n        }    ];\n\n    static getAttributeTypeMap() {\n        return TokenEvents.attributeTypeMap;\n    }\n\n    public constructor() {\n    }\n}\n\n","export * from './AssetGate'\nexport * from './AutoSuggestion'\nexport * from './BlockchainInfo'\nexport * from './Collection'\nexport * from './CreditEvent'\nexport * from './CurrencyInfo'\nexport * from './ENS'\nexport * from './ErrorMessage'\nexport * from './ExchangeEvent'\nexport * from './Media'\nexport * from './MediaPreview'\nexport * from './MediaVersion'\nexport * from './NonFungibleToken'\nexport * from './OpenSeaContract'\nexport * from './OwnedCollection'\nexport * from './SearchDocument'\nexport * from './SocialMedia'\nexport * from './Token'\nexport * from './TokenAttribute'\nexport * from './TokenEvents'\nexport * from './Transaction'\nexport * from './TransactionLogLine'\nexport * from './URL'\nexport * from './Wallet'\n","import {RequestContext, ResponseContext} from './http/http';\nimport { Observable, from } from './rxjsStub';\n\n/**\n * Defines the contract for a middleware intercepting requests before\n * they are sent (but after the RequestContext was created)\n * and before the ResponseContext is unwrapped.\n *\n */\nexport interface Middleware {\n    /**\n     * Modifies the request before the request is sent.\n     *\n     * @param context RequestContext of a request which is about to be sent to the server\n     * @returns an observable of the updated request context\n     *\n     */\n    pre(context: RequestContext): Observable<RequestContext>;\n    /**\n     * Modifies the returned response before it is deserialized.\n     *\n     * @param context ResponseContext of a sent request\n     * @returns an observable of the modified response context\n     */\n    post(context: ResponseContext): Observable<ResponseContext>;\n}\n\nexport class PromiseMiddlewareWrapper implements Middleware {\n\n    public constructor(private middleware: PromiseMiddleware) {\n\n    }\n\n    pre(context: RequestContext): Observable<RequestContext> {\n        return from(this.middleware.pre(context));\n    }\n\n    post(context: ResponseContext): Observable<ResponseContext> {\n        return from(this.middleware.post(context));\n    }\n\n}\n\n/**\n * Defines the contract for a middleware intercepting requests before\n * they are sent (but after the RequestContext was created)\n * and before the ResponseContext is unwrapped.\n *\n */\nexport interface PromiseMiddleware {\n    /**\n     * Modifies the request before the request is sent.\n     *\n     * @param context RequestContext of a request which is about to be sent to the server\n     * @returns an observable of the updated request context\n     *\n     */\n    pre(context: RequestContext): Promise<RequestContext>;\n        /**\n     * Modifies the returned response before it is deserialized.\n     *\n     * @param context ResponseContext of a sent request\n     * @returns an observable of the modified response context\n     */\n    post(context: ResponseContext): Promise<ResponseContext>;\n}\n","import { RequestContext, HttpMethod } from \"./http/http\";\n\nexport interface BaseServerConfiguration {\n    makeRequestContext(endpoint: string, httpMethod: HttpMethod): RequestContext;\n}\n\n/**\n *\n * Represents the configuration of a server including its\n * url template and variable configuration based on the url.\n *\n */\nexport class ServerConfiguration<T extends { [key: string]: string }> implements BaseServerConfiguration {\n    public constructor(private url: string, private variableConfiguration: T) {}\n\n    /**\n     * Sets the value of the variables of this server.\n     *\n     * @param variableConfiguration a partial variable configuration for the variables contained in the url\n     */\n    public setVariables(variableConfiguration: Partial<T>) {\n        Object.assign(this.variableConfiguration, variableConfiguration);\n    }\n\n    public getConfiguration(): T {\n        return this.variableConfiguration\n    }\n\n    private getUrl() {\n        let replacedUrl = this.url;\n        for (const key in this.variableConfiguration) {\n            var re = new RegExp(\"{\" + key + \"}\",\"g\");\n            replacedUrl = replacedUrl.replace(re, this.variableConfiguration[key]);\n        }\n        return replacedUrl\n    }\n\n    /**\n     * Creates a new request context for this server using the url with variables\n     * replaced with their respective values and the endpoint of the request appended.\n     *\n     * @param endpoint the endpoint to be queried on the server\n     * @param httpMethod httpMethod to be used\n     *\n     */\n    public makeRequestContext(endpoint: string, httpMethod: HttpMethod): RequestContext {\n        return new RequestContext(this.getUrl() + endpoint, httpMethod);\n    }\n}\n\nexport const server1 = new ServerConfiguration<{  }>(\"https://api.n.xyz\", {  })\n\nexport const servers = [server1];\n","import { HttpLibrary } from \"./http/http\";\nimport { Middleware, PromiseMiddleware, PromiseMiddlewareWrapper } from \"./middleware\";\nimport { IsomorphicFetchHttpLibrary as DefaultHttpLibrary } from \"./http/isomorphic-fetch\";\nimport { BaseServerConfiguration, server1 } from \"./servers\";\nimport { configureAuthMethods, AuthMethods, AuthMethodsConfiguration } from \"./auth/auth\";\n\nexport interface Configuration {\n    readonly baseServer: BaseServerConfiguration;\n    readonly httpApi: HttpLibrary;\n    readonly middleware: Middleware[];\n    readonly authMethods: AuthMethods;\n}\n\n\n/**\n * Interface with which a configuration object can be configured.\n */\nexport interface ConfigurationParameters {\n    /**\n     * Default server to use\n     */\n    baseServer?: BaseServerConfiguration;\n    /**\n     * HTTP library to use e.g. IsomorphicFetch\n     */\n    httpApi?: HttpLibrary;\n    /**\n     * The middlewares which will be applied to requests and responses\n     */\n    middleware?: Middleware[];\n    /**\n     * Configures all middlewares using the promise api instead of observables (which Middleware uses)\n     */\n    promiseMiddleware?: PromiseMiddleware[];\n    /**\n     * Configuration for the available authentication methods\n     */\n    authMethods?: AuthMethodsConfiguration\n}\n\n/**\n * Configuration factory function\n *\n * If a property is not included in conf, a default is used:\n *    - baseServer: server1\n *    - httpApi: IsomorphicFetchHttpLibrary\n *    - middleware: []\n *    - promiseMiddleware: []\n *    - authMethods: {}\n *\n * @param conf partial configuration\n */\nexport function createConfiguration(conf: ConfigurationParameters = {}): Configuration {\n    const configuration: Configuration = {\n        baseServer: conf.baseServer !== undefined ? conf.baseServer : server1,\n        httpApi: conf.httpApi || new DefaultHttpLibrary(),\n        middleware: conf.middleware || [],\n        authMethods: configureAuthMethods(conf.authMethods)\n    };\n    if (conf.promiseMiddleware) {\n        conf.promiseMiddleware.forEach(\n            m => configuration.middleware.push(new PromiseMiddlewareWrapper(m))\n        );\n    }\n    return configuration;\n}","/**\n * Represents an error caused by an api call i.e. it has attributes for a HTTP status code\n * and the returned body object.\n *\n * Example\n * API returns a ErrorMessageObject whenever HTTP status code is not in [200, 299]\n * => ApiException(404, someErrorMessageObject)\n *\n */\nexport class ApiException<T> extends Error {\n    public constructor(public code: number, message: string, public body: T, public headers: { [key: string]: string; }) {\n        super(\"HTTP-Code: \" + code + \"\\nMessage: \" + message + \"\\nBody: \" + JSON.stringify(body) + \"\\nHeaders: \" +\n        JSON.stringify(headers))\n    }\n}\n","import { Configuration } from '../configuration'\n\n/**\n *\n * @export\n */\nexport const COLLECTION_FORMATS = {\n    csv: \",\",\n    ssv: \" \",\n    tsv: \"\\t\",\n    pipes: \"|\",\n};\n\n\n/**\n *\n * @export\n * @class BaseAPI\n */\nexport class BaseAPIRequestFactory {\n\n    constructor(protected configuration: Configuration) {\n    }\n};\n\n/**\n *\n * @export\n * @class RequiredError\n * @extends {Error}\n */\nexport class RequiredError extends Error {\n    name: \"RequiredError\" = \"RequiredError\";\n    constructor(public api: string, public method: string, public field: string) {\n        super(\"Required parameter \" + field + \" was null or undefined when calling \" + api + \".\" + method + \".\");\n    }\n}\n","export * from './AssetGate';\nexport * from './AutoSuggestion';\nexport * from './BlockchainInfo';\nexport * from './Collection';\nexport * from './CreditEvent';\nexport * from './CurrencyInfo';\nexport * from './ENS';\nexport * from './ErrorMessage';\nexport * from './ExchangeEvent';\nexport * from './Media';\nexport * from './MediaPreview';\nexport * from './MediaVersion';\nexport * from './NonFungibleToken';\nexport * from './OpenSeaContract';\nexport * from './OwnedCollection';\nexport * from './SearchDocument';\nexport * from './SocialMedia';\nexport * from './Token';\nexport * from './TokenAttribute';\nexport * from './TokenEvents';\nexport * from './Transaction';\nexport * from './TransactionLogLine';\nexport * from './URL';\nexport * from './Wallet';\n\nimport { AssetGate } from './AssetGate';\nimport { AutoSuggestion  , AutoSuggestionTypeEnum   } from './AutoSuggestion';\nimport { BlockchainInfo } from './BlockchainInfo';\nimport { Collection } from './Collection';\nimport { CreditEvent, CreditEventEventEnum    } from './CreditEvent';\nimport { CurrencyInfo } from './CurrencyInfo';\nimport { ENS } from './ENS';\nimport { ErrorMessage } from './ErrorMessage';\nimport { ExchangeEvent, ExchangeEventEventEnum    } from './ExchangeEvent';\nimport { Media } from './Media';\nimport { MediaPreview    , MediaPreviewKindEnum    } from './MediaPreview';\nimport { MediaVersion   , MediaVersionKindEnum     } from './MediaVersion';\nimport { NonFungibleToken    , NonFungibleTokenDurabilityEnum          } from './NonFungibleToken';\nimport { OpenSeaContract, OpenSeaContractAssetContractTypeEnum        } from './OpenSeaContract';\nimport { OwnedCollection } from './OwnedCollection';\nimport { SearchDocument } from './SearchDocument';\nimport { SocialMedia } from './SocialMedia';\nimport { Token } from './Token';\nimport { TokenAttribute } from './TokenAttribute';\nimport { TokenEvents } from './TokenEvents';\nimport { Transaction } from './Transaction';\nimport { TransactionLogLine } from './TransactionLogLine';\nimport { URL } from './URL';\nimport { Wallet } from './Wallet';\n\n/* tslint:disable:no-unused-variable */\nlet primitives = [\n                    \"string\",\n                    \"boolean\",\n                    \"double\",\n                    \"integer\",\n                    \"long\",\n                    \"float\",\n                    \"number\",\n                    \"any\"\n                 ];\n\nconst supportedMediaTypes: { [mediaType: string]: number } = {\n  \"application/json\": Infinity,\n  \"application/octet-stream\": 0,\n  \"application/x-www-form-urlencoded\": 0\n}\n\n\nlet enumsMap: Set<string> = new Set<string>([\n    \"AutoSuggestionTypeEnum\",\n    \"CreditEventEventEnum\",\n    \"ExchangeEventEventEnum\",\n    \"MediaPreviewKindEnum\",\n    \"MediaVersionKindEnum\",\n    \"NonFungibleTokenDurabilityEnum\",\n    \"OpenSeaContractAssetContractTypeEnum\",\n]);\n\nlet typeMap: {[index: string]: any} = {\n    \"AssetGate\": AssetGate,\n    \"AutoSuggestion\": AutoSuggestion,\n    \"BlockchainInfo\": BlockchainInfo,\n    \"Collection\": Collection,\n    \"CreditEvent\": CreditEvent,\n    \"CurrencyInfo\": CurrencyInfo,\n    \"ENS\": ENS,\n    \"ErrorMessage\": ErrorMessage,\n    \"ExchangeEvent\": ExchangeEvent,\n    \"Media\": Media,\n    \"MediaPreview\": MediaPreview,\n    \"MediaVersion\": MediaVersion,\n    \"NonFungibleToken\": NonFungibleToken,\n    \"OpenSeaContract\": OpenSeaContract,\n    \"OwnedCollection\": OwnedCollection,\n    \"SearchDocument\": SearchDocument,\n    \"SocialMedia\": SocialMedia,\n    \"Token\": Token,\n    \"TokenAttribute\": TokenAttribute,\n    \"TokenEvents\": TokenEvents,\n    \"Transaction\": Transaction,\n    \"TransactionLogLine\": TransactionLogLine,\n    \"URL\": URL,\n    \"Wallet\": Wallet,\n}\n\nexport class ObjectSerializer {\n    public static findCorrectType(data: any, expectedType: string) {\n        if (data == undefined) {\n            return expectedType;\n        } else if (primitives.indexOf(expectedType.toLowerCase()) !== -1) {\n            return expectedType;\n        } else if (expectedType === \"Date\") {\n            return expectedType;\n        } else {\n            if (enumsMap.has(expectedType)) {\n                return expectedType;\n            }\n\n            if (!typeMap[expectedType]) {\n                return expectedType; // w/e we don't know the type\n            }\n\n            // Check the discriminator\n            let discriminatorProperty = typeMap[expectedType].discriminator;\n            if (discriminatorProperty == null) {\n                return expectedType; // the type does not have a discriminator. use it.\n            } else {\n                if (data[discriminatorProperty]) {\n                    var discriminatorType = data[discriminatorProperty];\n                    if(typeMap[discriminatorType]){\n                        return discriminatorType; // use the type given in the discriminator\n                    } else {\n                        return expectedType; // discriminator did not map to a type\n                    }\n                } else {\n                    return expectedType; // discriminator was not present (or an empty string)\n                }\n            }\n        }\n    }\n\n    public static serialize(data: any, type: string, format: string) {\n        if (data == undefined) {\n            return data;\n        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {\n            return data;\n        } else if (type.lastIndexOf(\"Array<\", 0) === 0) { // string.startsWith pre es6\n            let subType: string = type.replace(\"Array<\", \"\"); // Array<Type> => Type>\n            subType = subType.substring(0, subType.length - 1); // Type> => Type\n            let transformedData: any[] = [];\n            for (let index in data) {\n                let date = data[index];\n                transformedData.push(ObjectSerializer.serialize(date, subType, format));\n            }\n            return transformedData;\n        } else if (type === \"Date\") {\n            if (format == \"date\") {\n                let month = data.getMonth()+1\n                month = month < 10 ? \"0\" + month.toString() : month.toString()\n                let day = data.getDate();\n                day = day < 10 ? \"0\" + day.toString() : day.toString();\n\n                return data.getFullYear() + \"-\" + month + \"-\" + day;\n            } else {\n                return data.toISOString();\n            }\n        } else {\n            if (enumsMap.has(type)) {\n                return data;\n            }\n            if (!typeMap[type]) { // in case we dont know the type\n                return data;\n            }\n\n            // Get the actual type of this object\n            type = this.findCorrectType(data, type);\n\n            // get the map for the correct type.\n            let attributeTypes = typeMap[type].getAttributeTypeMap();\n            let instance: {[index: string]: any} = {};\n            for (let index in attributeTypes) {\n                let attributeType = attributeTypes[index];\n                instance[attributeType.baseName] = ObjectSerializer.serialize(data[attributeType.name], attributeType.type, attributeType.format);\n            }\n            return instance;\n        }\n    }\n\n    public static deserialize(data: any, type: string, format: string) {\n        // polymorphism may change the actual type.\n        type = ObjectSerializer.findCorrectType(data, type);\n        if (data == undefined) {\n            return data;\n        } else if (primitives.indexOf(type.toLowerCase()) !== -1) {\n            return data;\n        } else if (type.lastIndexOf(\"Array<\", 0) === 0) { // string.startsWith pre es6\n            let subType: string = type.replace(\"Array<\", \"\"); // Array<Type> => Type>\n            subType = subType.substring(0, subType.length - 1); // Type> => Type\n            let transformedData: any[] = [];\n            for (let index in data) {\n                let date = data[index];\n                transformedData.push(ObjectSerializer.deserialize(date, subType, format));\n            }\n            return transformedData;\n        } else if (type === \"Date\") {\n            return new Date(data);\n        } else {\n            if (enumsMap.has(type)) {// is Enum\n                return data;\n            }\n\n            if (!typeMap[type]) { // dont know the type\n                return data;\n            }\n            let instance = new typeMap[type]();\n            let attributeTypes = typeMap[type].getAttributeTypeMap();\n            for (let index in attributeTypes) {\n                let attributeType = attributeTypes[index];\n                let value = ObjectSerializer.deserialize(data[attributeType.baseName], attributeType.type, attributeType.format);\n                if (value !== undefined) {\n                    instance[attributeType.name] = value;\n                }\n            }\n            return instance;\n        }\n    }\n\n\n    /**\n     * Normalize media type\n     *\n     * We currently do not handle any media types attributes, i.e. anything\n     * after a semicolon. All content is assumed to be UTF-8 compatible.\n     */\n    public static normalizeMediaType(mediaType: string | undefined): string | undefined {\n        if (mediaType === undefined) {\n            return undefined;\n        }\n        return mediaType.split(\";\")[0].trim().toLowerCase();\n    }\n\n    /**\n     * From a list of possible media types, choose the one we can handle best.\n     *\n     * The order of the given media types does not have any impact on the choice\n     * made.\n     */\n    public static getPreferredMediaType(mediaTypes: Array<string>): string {\n        /** According to OAS 3 we should default to json */\n        if (!mediaTypes) {\n            return \"application/json\";\n        }\n\n        const normalMediaTypes = mediaTypes.map(this.normalizeMediaType);\n        let selectedMediaType: string | undefined = undefined;\n        let selectedRank: number = -Infinity;\n        for (const mediaType of normalMediaTypes) {\n            if (supportedMediaTypes[mediaType!] > selectedRank) {\n                selectedMediaType = mediaType;\n                selectedRank = supportedMediaTypes[mediaType!];\n            }\n        }\n\n        if (selectedMediaType === undefined) {\n            throw new Error(\"None of the given media types are supported: \" + mediaTypes.join(\", \"));\n        }\n\n        return selectedMediaType!;\n    }\n\n    /**\n     * Convert data to a string according the given media type\n     */\n    public static stringify(data: any, mediaType: string): string {\n        if (mediaType === \"application/json\") {\n            return JSON.stringify(data);\n        }\n\n        throw new Error(\"The mediaType \" + mediaType + \" is not supported by ObjectSerializer.stringify.\");\n    }\n\n    /**\n     * Parse data from a string according to the given media type\n     */\n    public static parse(rawData: string, mediaType: string | undefined) {\n        if (mediaType === undefined) {\n            throw new Error(\"Cannot parse content. No Content-Type defined.\");\n        }\n\n        if (mediaType === \"application/json\") {\n            return JSON.parse(rawData);\n        }\n\n        if (mediaType === \"text/html\") {\n            return rawData;\n        }\n\n        throw new Error(\"The mediaType \" + mediaType + \" is not supported by ObjectSerializer.parse.\");\n    }\n}\n","/**\n * Returns if a specific http code is in a given code range\n * where the code range is defined as a combination of digits\n * and \"X\" (the letter X) with a length of 3\n *\n * @param codeRange string with length 3 consisting of digits and \"X\" (the letter X)\n * @param code the http status code to be checked against the code range\n */\nexport function isCodeInRange(codeRange: string, code: number): boolean {\n    // This is how the default value is encoded in OAG\n    if (codeRange === \"0\") {\n        return true;\n    }\n    if (codeRange == code.toString()) {\n        return true;\n    } else {\n        const codeString = code.toString();\n        if (codeString.length != codeRange.length) {\n            return false;\n        }\n        for (let i = 0; i < codeString.length; i++) {\n            if (codeRange.charAt(i) != \"X\" && codeRange.charAt(i) != codeString.charAt(i)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n/**\n* Returns if it can consume form\n*\n* @param consumes array\n*/\nexport function canConsumeForm(contentTypes: string[]): boolean {\n    return contentTypes.indexOf('multipart/form-data') !== -1\n}\n","// TODO: better import syntax?\nimport {BaseAPIRequestFactory, RequiredError} from './baseapi';\nimport {Configuration} from '../configuration';\nimport {RequestContext, HttpMethod, ResponseContext, HttpFile} from '../http/http';\nimport {ObjectSerializer} from '../models/ObjectSerializer';\nimport {ApiException} from './exception';\nimport {canConsumeForm, isCodeInRange} from '../util';\nimport {SecurityAuthentication} from '../auth/auth';\n\n\nimport { Collection } from '../models/Collection';\nimport { ErrorMessage } from '../models/ErrorMessage';\nimport { Token } from '../models/Token';\nimport { Wallet } from '../models/Wallet';\n\n/**\n * no description\n */\nexport class AlphaApiRequestFactory extends BaseAPIRequestFactory {\n\n    /**\n     * Returns trending and interesting collections on Ethereum. Useful for powering discovery experiences and providing an on-ramp to exploring creative blockchain data.\n     */\n    public async getTopCollections(_options?: Configuration): Promise<RequestContext> {\n        let _config = _options || this.configuration;\n\n        // Path Params\n        const localVarPath = '/api/v1-alpha/collections/top';\n\n        // Make Request Context\n        const requestContext = _config.baseServer.makeRequestContext(localVarPath, HttpMethod.GET);\n        requestContext.setHeaderParam(\"Accept\", \"application/json, */*;q=0.8\")\n\n\n        let authMethod: SecurityAuthentication | undefined;\n        // Apply auth methods\n        authMethod = _config.authMethods[\"apikey\"]\n        if (authMethod?.applySecurityAuthentication) {\n            await authMethod?.applySecurityAuthentication(requestContext);\n        }\n        \n        const defaultAuth: SecurityAuthentication | undefined = _options?.authMethods?.default || this.configuration?.authMethods?.default\n        if (defaultAuth?.applySecurityAuthentication) {\n            await defaultAuth?.applySecurityAuthentication(requestContext);\n        }\n\n        return requestContext;\n    }\n\n    /**\n     * Returns trending and interesting NFTs and SFTs on Ethereum. Useful for powering discovery experiences and providing an on-ramp to exploring creative blockchain data.\n     */\n    public async getTopTokens(_options?: Configuration): Promise<RequestContext> {\n        let _config = _options || this.configuration;\n\n        // Path Params\n        const localVarPath = '/api/v1-alpha/tokens/top';\n\n        // Make Request Context\n        const requestContext = _config.baseServer.makeRequestContext(localVarPath, HttpMethod.GET);\n        requestContext.setHeaderParam(\"Accept\", \"application/json, */*;q=0.8\")\n\n\n        let authMethod: SecurityAuthentication | undefined;\n        // Apply auth methods\n        authMethod = _config.authMethods[\"apikey\"]\n        if (authMethod?.applySecurityAuthentication) {\n            await authMethod?.applySecurityAuthentication(requestContext);\n        }\n        \n        const defaultAuth: SecurityAuthentication | undefined = _options?.authMethods?.default || this.configuration?.authMethods?.default\n        if (defaultAuth?.applySecurityAuthentication) {\n            await defaultAuth?.applySecurityAuthentication(requestContext);\n        }\n\n        return requestContext;\n    }\n\n    /**\n     * Returns trending and interesting wallets on Ethereum. Useful for powering discovery experiences and providing an on-ramp to exploring creative blockchain data.\n     */\n    public async getTopWallets(_options?: Configuration): Promise<RequestContext> {\n        let _config = _options || this.configuration;\n\n        // Path Params\n        const localVarPath = '/api/v1-alpha/wallets/top';\n\n        // Make Request Context\n        const requestContext = _config.baseServer.makeRequestContext(localVarPath, HttpMethod.GET);\n        requestContext.setHeaderParam(\"Accept\", \"application/json, */*;q=0.8\")\n\n\n        let authMethod: SecurityAuthentication | undefined;\n        // Apply auth methods\n        authMethod = _config.authMethods[\"apikey\"]\n        if (authMethod?.applySecurityAuthentication) {\n            await authMethod?.applySecurityAuthentication(requestContext);\n        }\n        \n        const defaultAuth: SecurityAuthentication | undefined = _options?.authMethods?.default || this.configuration?.authMethods?.default\n        if (defaultAuth?.applySecurityAuthentication) {\n            await defaultAuth?.applySecurityAuthentication(requestContext);\n        }\n\n        return requestContext;\n    }\n\n}\n\nexport class AlphaApiResponseProcessor {\n\n    /**\n     * Unwraps the actual response sent by the server from the response context and deserializes the response content\n     * to the expected objects\n     *\n     * @params response Response returned by the server for a request to getTopCollections\n     * @throws ApiException if the response code was not in [200, 299]\n     */\n     public async getTopCollections(response: ResponseContext): Promise<Array<Collection> > {\n        const contentType = ObjectSerializer.normalizeMediaType(response.headers[\"content-type\"]);\n        if (isCodeInRange(\"200\", response.httpStatusCode)) {\n            const body: Array<Collection> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<Collection>\", \"\"\n            ) as Array<Collection>;\n            return body;\n        }\n        if (isCodeInRange(\"0\", response.httpStatusCode)) {\n            const body: ErrorMessage = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"ErrorMessage\", \"\"\n            ) as ErrorMessage;\n            throw new ApiException<ErrorMessage>(response.httpStatusCode, \"An error message for unexpected requests.\", body, response.headers);\n        }\n\n        // Work around for missing responses in specification, e.g. for petstore.yaml\n        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {\n            const body: Array<Collection> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<Collection>\", \"\"\n            ) as Array<Collection>;\n            return body;\n        }\n\n        throw new ApiException<string | Blob | undefined>(response.httpStatusCode, \"Unknown API Status Code!\", await response.getBodyAsAny(), response.headers);\n    }\n\n    /**\n     * Unwraps the actual response sent by the server from the response context and deserializes the response content\n     * to the expected objects\n     *\n     * @params response Response returned by the server for a request to getTopTokens\n     * @throws ApiException if the response code was not in [200, 299]\n     */\n     public async getTopTokens(response: ResponseContext): Promise<Array<Token> > {\n        const contentType = ObjectSerializer.normalizeMediaType(response.headers[\"content-type\"]);\n        if (isCodeInRange(\"200\", response.httpStatusCode)) {\n            const body: Array<Token> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<Token>\", \"\"\n            ) as Array<Token>;\n            return body;\n        }\n        if (isCodeInRange(\"0\", response.httpStatusCode)) {\n            const body: ErrorMessage = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"ErrorMessage\", \"\"\n            ) as ErrorMessage;\n            throw new ApiException<ErrorMessage>(response.httpStatusCode, \"An error message for unexpected requests.\", body, response.headers);\n        }\n\n        // Work around for missing responses in specification, e.g. for petstore.yaml\n        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {\n            const body: Array<Token> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<Token>\", \"\"\n            ) as Array<Token>;\n            return body;\n        }\n\n        throw new ApiException<string | Blob | undefined>(response.httpStatusCode, \"Unknown API Status Code!\", await response.getBodyAsAny(), response.headers);\n    }\n\n    /**\n     * Unwraps the actual response sent by the server from the response context and deserializes the response content\n     * to the expected objects\n     *\n     * @params response Response returned by the server for a request to getTopWallets\n     * @throws ApiException if the response code was not in [200, 299]\n     */\n     public async getTopWallets(response: ResponseContext): Promise<Array<Wallet> > {\n        const contentType = ObjectSerializer.normalizeMediaType(response.headers[\"content-type\"]);\n        if (isCodeInRange(\"200\", response.httpStatusCode)) {\n            const body: Array<Wallet> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<Wallet>\", \"\"\n            ) as Array<Wallet>;\n            return body;\n        }\n        if (isCodeInRange(\"0\", response.httpStatusCode)) {\n            const body: ErrorMessage = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"ErrorMessage\", \"\"\n            ) as ErrorMessage;\n            throw new ApiException<ErrorMessage>(response.httpStatusCode, \"An error message for unexpected requests.\", body, response.headers);\n        }\n\n        // Work around for missing responses in specification, e.g. for petstore.yaml\n        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {\n            const body: Array<Wallet> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<Wallet>\", \"\"\n            ) as Array<Wallet>;\n            return body;\n        }\n\n        throw new ApiException<string | Blob | undefined>(response.httpStatusCode, \"Unknown API Status Code!\", await response.getBodyAsAny(), response.headers);\n    }\n\n}\n","// TODO: better import syntax?\nimport {BaseAPIRequestFactory, RequiredError} from './baseapi';\nimport {Configuration} from '../configuration';\nimport {RequestContext, HttpMethod, ResponseContext, HttpFile} from '../http/http';\nimport {ObjectSerializer} from '../models/ObjectSerializer';\nimport {ApiException} from './exception';\nimport {canConsumeForm, isCodeInRange} from '../util';\nimport {SecurityAuthentication} from '../auth/auth';\n\n\nimport { AssetGate } from '../models/AssetGate';\nimport { AutoSuggestion } from '../models/AutoSuggestion';\nimport { BlockchainInfo } from '../models/BlockchainInfo';\nimport { Collection } from '../models/Collection';\nimport { CurrencyInfo } from '../models/CurrencyInfo';\nimport { ErrorMessage } from '../models/ErrorMessage';\nimport { SearchDocument } from '../models/SearchDocument';\nimport { Token } from '../models/Token';\nimport { TokenEvents } from '../models/TokenEvents';\nimport { Transaction } from '../models/Transaction';\nimport { Wallet } from '../models/Wallet';\n\n/**\n * no description\n */\nexport class DefaultApiRequestFactory extends BaseAPIRequestFactory {\n\n    /**\n     * Lists all supported blockchains.\n     */\n    public async getBlockchains(_options?: Configuration): Promise<RequestContext> {\n        let _config = _options || this.configuration;\n\n        // Path Params\n        const localVarPath = '/api/v1/blockchains';\n\n        // Make Request Context\n        const requestContext = _config.baseServer.makeRequestContext(localVarPath, HttpMethod.GET);\n        requestContext.setHeaderParam(\"Accept\", \"application/json, */*;q=0.8\")\n\n\n        let authMethod: SecurityAuthentication | undefined;\n        // Apply auth methods\n        authMethod = _config.authMethods[\"apikey\"]\n        if (authMethod?.applySecurityAuthentication) {\n            await authMethod?.applySecurityAuthentication(requestContext);\n        }\n        \n        const defaultAuth: SecurityAuthentication | undefined = _options?.authMethods?.default || this.configuration?.authMethods?.default\n        if (defaultAuth?.applySecurityAuthentication) {\n            await defaultAuth?.applySecurityAuthentication(requestContext);\n        }\n\n        return requestContext;\n    }\n\n    /**\n     * Get a collection by its contract address.\n     * @param contractAddress A hex address for a blockchain contract.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     */\n    public async getCollection(contractAddress: string, chainID?: string, _options?: Configuration): Promise<RequestContext> {\n        let _config = _options || this.configuration;\n\n        // verify required parameter 'contractAddress' is not null or undefined\n        if (contractAddress === null || contractAddress === undefined) {\n            throw new RequiredError(\"DefaultApi\", \"getCollection\", \"contractAddress\");\n        }\n\n\n\n        // Path Params\n        const localVarPath = '/api/v1/collections/{contractAddress}'\n            .replace('{' + 'contractAddress' + '}', encodeURIComponent(String(contractAddress)));\n\n        // Make Request Context\n        const requestContext = _config.baseServer.makeRequestContext(localVarPath, HttpMethod.GET);\n        requestContext.setHeaderParam(\"Accept\", \"application/json, */*;q=0.8\")\n\n        // Query Params\n        if (chainID !== undefined) {\n            requestContext.setQueryParam(\"chainID\", ObjectSerializer.serialize(chainID, \"string\", \"\"));\n        }\n\n\n        let authMethod: SecurityAuthentication | undefined;\n        // Apply auth methods\n        authMethod = _config.authMethods[\"apikey\"]\n        if (authMethod?.applySecurityAuthentication) {\n            await authMethod?.applySecurityAuthentication(requestContext);\n        }\n        \n        const defaultAuth: SecurityAuthentication | undefined = _options?.authMethods?.default || this.configuration?.authMethods?.default\n        if (defaultAuth?.applySecurityAuthentication) {\n            await defaultAuth?.applySecurityAuthentication(requestContext);\n        }\n\n        return requestContext;\n    }\n\n    /**\n     * Determine if a wallet has any token from a contract.\n     * @param contractAddress A hex address for a blockchain contract.\n     * @param walletAddress A hex string referencing a public wallet address.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     */\n    public async getContractGate(contractAddress: string, walletAddress: string, chainID?: string, _options?: Configuration): Promise<RequestContext> {\n        let _config = _options || this.configuration;\n\n        // verify required parameter 'contractAddress' is not null or undefined\n        if (contractAddress === null || contractAddress === undefined) {\n            throw new RequiredError(\"DefaultApi\", \"getContractGate\", \"contractAddress\");\n        }\n\n\n        // verify required parameter 'walletAddress' is not null or undefined\n        if (walletAddress === null || walletAddress === undefined) {\n            throw new RequiredError(\"DefaultApi\", \"getContractGate\", \"walletAddress\");\n        }\n\n\n\n        // Path Params\n        const localVarPath = '/api/v1/wallets/{walletAddress}/gate/{contractAddress}'\n            .replace('{' + 'contractAddress' + '}', encodeURIComponent(String(contractAddress)))\n            .replace('{' + 'walletAddress' + '}', encodeURIComponent(String(walletAddress)));\n\n        // Make Request Context\n        const requestContext = _config.baseServer.makeRequestContext(localVarPath, HttpMethod.GET);\n        requestContext.setHeaderParam(\"Accept\", \"application/json, */*;q=0.8\")\n\n        // Query Params\n        if (chainID !== undefined) {\n            requestContext.setQueryParam(\"chainID\", ObjectSerializer.serialize(chainID, \"string\", \"\"));\n        }\n\n\n        let authMethod: SecurityAuthentication | undefined;\n        // Apply auth methods\n        authMethod = _config.authMethods[\"apikey\"]\n        if (authMethod?.applySecurityAuthentication) {\n            await authMethod?.applySecurityAuthentication(requestContext);\n        }\n        \n        const defaultAuth: SecurityAuthentication | undefined = _options?.authMethods?.default || this.configuration?.authMethods?.default\n        if (defaultAuth?.applySecurityAuthentication) {\n            await defaultAuth?.applySecurityAuthentication(requestContext);\n        }\n\n        return requestContext;\n    }\n\n    /**\n     * Get tokens by contract address.\n     * @param contractAddress A hex address for a blockchain contract.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     * @param limit Limits the number of results in a single response.\n     */\n    public async getContractTokens(contractAddress: string, chainID?: string, limit?: number, _options?: Configuration): Promise<RequestContext> {\n        let _config = _options || this.configuration;\n\n        // verify required parameter 'contractAddress' is not null or undefined\n        if (contractAddress === null || contractAddress === undefined) {\n            throw new RequiredError(\"DefaultApi\", \"getContractTokens\", \"contractAddress\");\n        }\n\n\n\n\n        // Path Params\n        const localVarPath = '/api/v1/tokens/{contractAddress}'\n            .replace('{' + 'contractAddress' + '}', encodeURIComponent(String(contractAddress)));\n\n        // Make Request Context\n        const requestContext = _config.baseServer.makeRequestContext(localVarPath, HttpMethod.GET);\n        requestContext.setHeaderParam(\"Accept\", \"application/json, */*;q=0.8\")\n\n        // Query Params\n        if (chainID !== undefined) {\n            requestContext.setQueryParam(\"chainID\", ObjectSerializer.serialize(chainID, \"string\", \"\"));\n        }\n\n        // Query Params\n        if (limit !== undefined) {\n            requestContext.setQueryParam(\"limit\", ObjectSerializer.serialize(limit, \"number\", \"\"));\n        }\n\n\n        let authMethod: SecurityAuthentication | undefined;\n        // Apply auth methods\n        authMethod = _config.authMethods[\"apikey\"]\n        if (authMethod?.applySecurityAuthentication) {\n            await authMethod?.applySecurityAuthentication(requestContext);\n        }\n        \n        const defaultAuth: SecurityAuthentication | undefined = _options?.authMethods?.default || this.configuration?.authMethods?.default\n        if (defaultAuth?.applySecurityAuthentication) {\n            await defaultAuth?.applySecurityAuthentication(requestContext);\n        }\n\n        return requestContext;\n    }\n\n    /**\n     * Returns tokens from a batch lookup.\n     * @param contractAddresses A comma-separated hex address for a blockchain contract, the order of values should match the order in tokenIdentifiers.\n     * @param tokenIdentifiers A comma-separated token ID, the order of values should match the order in contractAddresses.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     * @param limit Limits the number of results in a single response.\n     */\n    public async getContractTokensByContractAndID(contractAddresses: string, tokenIdentifiers: string, chainID?: string, limit?: number, _options?: Configuration): Promise<RequestContext> {\n        let _config = _options || this.configuration;\n\n        // verify required parameter 'contractAddresses' is not null or undefined\n        if (contractAddresses === null || contractAddresses === undefined) {\n            throw new RequiredError(\"DefaultApi\", \"getContractTokensByContractAndID\", \"contractAddresses\");\n        }\n\n\n        // verify required parameter 'tokenIdentifiers' is not null or undefined\n        if (tokenIdentifiers === null || tokenIdentifiers === undefined) {\n            throw new RequiredError(\"DefaultApi\", \"getContractTokensByContractAndID\", \"tokenIdentifiers\");\n        }\n\n\n\n\n        // Path Params\n        const localVarPath = '/api/v1/token-batch';\n\n        // Make Request Context\n        const requestContext = _config.baseServer.makeRequestContext(localVarPath, HttpMethod.GET);\n        requestContext.setHeaderParam(\"Accept\", \"application/json, */*;q=0.8\")\n\n        // Query Params\n        if (contractAddresses !== undefined) {\n            requestContext.setQueryParam(\"contractAddresses\", ObjectSerializer.serialize(contractAddresses, \"string\", \"\"));\n        }\n\n        // Query Params\n        if (tokenIdentifiers !== undefined) {\n            requestContext.setQueryParam(\"tokenIdentifiers\", ObjectSerializer.serialize(tokenIdentifiers, \"string\", \"\"));\n        }\n\n        // Query Params\n        if (chainID !== undefined) {\n            requestContext.setQueryParam(\"chainID\", ObjectSerializer.serialize(chainID, \"string\", \"\"));\n        }\n\n        // Query Params\n        if (limit !== undefined) {\n            requestContext.setQueryParam(\"limit\", ObjectSerializer.serialize(limit, \"number\", \"\"));\n        }\n\n\n        let authMethod: SecurityAuthentication | undefined;\n        // Apply auth methods\n        authMethod = _config.authMethods[\"apikey\"]\n        if (authMethod?.applySecurityAuthentication) {\n            await authMethod?.applySecurityAuthentication(requestContext);\n        }\n        \n        const defaultAuth: SecurityAuthentication | undefined = _options?.authMethods?.default || this.configuration?.authMethods?.default\n        if (defaultAuth?.applySecurityAuthentication) {\n            await defaultAuth?.applySecurityAuthentication(requestContext);\n        }\n\n        return requestContext;\n    }\n\n    /**\n     * Get the transaction history for a collection\n     * @param contractAddress A hex address for a blockchain contract.\n     * @param cursor Cursor to support API pagination.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     * @param limit Limits the number of results in a single response.\n     */\n    public async getContractTransactionHistory(contractAddress: string, cursor?: string, chainID?: string, limit?: number, _options?: Configuration): Promise<RequestContext> {\n        let _config = _options || this.configuration;\n\n        // verify required parameter 'contractAddress' is not null or undefined\n        if (contractAddress === null || contractAddress === undefined) {\n            throw new RequiredError(\"DefaultApi\", \"getContractTransactionHistory\", \"contractAddress\");\n        }\n\n\n\n\n\n        // Path Params\n        const localVarPath = '/api/v1/collections/{contractAddress}/transactions/history'\n            .replace('{' + 'contractAddress' + '}', encodeURIComponent(String(contractAddress)));\n\n        // Make Request Context\n        const requestContext = _config.baseServer.makeRequestContext(localVarPath, HttpMethod.GET);\n        requestContext.setHeaderParam(\"Accept\", \"application/json, */*;q=0.8\")\n\n        // Query Params\n        if (cursor !== undefined) {\n            requestContext.setQueryParam(\"cursor\", ObjectSerializer.serialize(cursor, \"string\", \"\"));\n        }\n\n        // Query Params\n        if (chainID !== undefined) {\n            requestContext.setQueryParam(\"chainID\", ObjectSerializer.serialize(chainID, \"string\", \"\"));\n        }\n\n        // Query Params\n        if (limit !== undefined) {\n            requestContext.setQueryParam(\"limit\", ObjectSerializer.serialize(limit, \"number\", \"\"));\n        }\n\n\n        let authMethod: SecurityAuthentication | undefined;\n        // Apply auth methods\n        authMethod = _config.authMethods[\"apikey\"]\n        if (authMethod?.applySecurityAuthentication) {\n            await authMethod?.applySecurityAuthentication(requestContext);\n        }\n        \n        const defaultAuth: SecurityAuthentication | undefined = _options?.authMethods?.default || this.configuration?.authMethods?.default\n        if (defaultAuth?.applySecurityAuthentication) {\n            await defaultAuth?.applySecurityAuthentication(requestContext);\n        }\n\n        return requestContext;\n    }\n\n    /**\n     * Get search results such as wallets, tokens, and collections by a search query.\n     * @param query A search query that returns matching results\n     * @param cursor Cursor to support API pagination.\n     */\n    public async getSearchResults(query: string, cursor?: string, _options?: Configuration): Promise<RequestContext> {\n        let _config = _options || this.configuration;\n\n        // verify required parameter 'query' is not null or undefined\n        if (query === null || query === undefined) {\n            throw new RequiredError(\"DefaultApi\", \"getSearchResults\", \"query\");\n        }\n\n\n\n        // Path Params\n        const localVarPath = '/api/v1/search/{query}'\n            .replace('{' + 'query' + '}', encodeURIComponent(String(query)));\n\n        // Make Request Context\n        const requestContext = _config.baseServer.makeRequestContext(localVarPath, HttpMethod.GET);\n        requestContext.setHeaderParam(\"Accept\", \"application/json, */*;q=0.8\")\n\n        // Query Params\n        if (cursor !== undefined) {\n            requestContext.setQueryParam(\"cursor\", ObjectSerializer.serialize(cursor, \"string\", \"\"));\n        }\n\n\n        let authMethod: SecurityAuthentication | undefined;\n        // Apply auth methods\n        authMethod = _config.authMethods[\"apikey\"]\n        if (authMethod?.applySecurityAuthentication) {\n            await authMethod?.applySecurityAuthentication(requestContext);\n        }\n        \n        const defaultAuth: SecurityAuthentication | undefined = _options?.authMethods?.default || this.configuration?.authMethods?.default\n        if (defaultAuth?.applySecurityAuthentication) {\n            await defaultAuth?.applySecurityAuthentication(requestContext);\n        }\n\n        return requestContext;\n    }\n\n    /**\n     * Returns a list of tokens sold by a wallet.\n     * @param walletAddress A hex string referencing a public wallet address.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     * @param cursor Cursor to support API pagination.\n     * @param limit Limits the number of results in a single response.\n     */\n    public async getSoldTokens(walletAddress: string, chainID?: string, cursor?: string, limit?: number, _options?: Configuration): Promise<RequestContext> {\n        let _config = _options || this.configuration;\n\n        // verify required parameter 'walletAddress' is not null or undefined\n        if (walletAddress === null || walletAddress === undefined) {\n            throw new RequiredError(\"DefaultApi\", \"getSoldTokens\", \"walletAddress\");\n        }\n\n\n\n\n\n        // Path Params\n        const localVarPath = '/api/v1/wallets/{walletAddress}/sold-tokens'\n            .replace('{' + 'walletAddress' + '}', encodeURIComponent(String(walletAddress)));\n\n        // Make Request Context\n        const requestContext = _config.baseServer.makeRequestContext(localVarPath, HttpMethod.GET);\n        requestContext.setHeaderParam(\"Accept\", \"application/json, */*;q=0.8\")\n\n        // Query Params\n        if (chainID !== undefined) {\n            requestContext.setQueryParam(\"chainID\", ObjectSerializer.serialize(chainID, \"string\", \"\"));\n        }\n\n        // Query Params\n        if (cursor !== undefined) {\n            requestContext.setQueryParam(\"cursor\", ObjectSerializer.serialize(cursor, \"string\", \"\"));\n        }\n\n        // Query Params\n        if (limit !== undefined) {\n            requestContext.setQueryParam(\"limit\", ObjectSerializer.serialize(limit, \"number\", \"\"));\n        }\n\n\n        let authMethod: SecurityAuthentication | undefined;\n        // Apply auth methods\n        authMethod = _config.authMethods[\"apikey\"]\n        if (authMethod?.applySecurityAuthentication) {\n            await authMethod?.applySecurityAuthentication(requestContext);\n        }\n        \n        const defaultAuth: SecurityAuthentication | undefined = _options?.authMethods?.default || this.configuration?.authMethods?.default\n        if (defaultAuth?.applySecurityAuthentication) {\n            await defaultAuth?.applySecurityAuthentication(requestContext);\n        }\n\n        return requestContext;\n    }\n\n    /**\n     * Get autocomplete-style search suggestions for results.\n     * @param query A query or partial query that can be used to retrieve suggested results. For example \\&quot;bored a\\&quot; would return a suggestion for \\&quot;bored ape.\\&quot;\n     */\n    public async getSuggestionsResults(query?: string, _options?: Configuration): Promise<RequestContext> {\n        let _config = _options || this.configuration;\n\n\n        // Path Params\n        const localVarPath = '/api/v1/suggestions';\n\n        // Make Request Context\n        const requestContext = _config.baseServer.makeRequestContext(localVarPath, HttpMethod.GET);\n        requestContext.setHeaderParam(\"Accept\", \"application/json, */*;q=0.8\")\n\n        // Query Params\n        if (query !== undefined) {\n            requestContext.setQueryParam(\"query\", ObjectSerializer.serialize(query, \"string\", \"\"));\n        }\n\n\n        let authMethod: SecurityAuthentication | undefined;\n        // Apply auth methods\n        authMethod = _config.authMethods[\"apikey\"]\n        if (authMethod?.applySecurityAuthentication) {\n            await authMethod?.applySecurityAuthentication(requestContext);\n        }\n        \n        const defaultAuth: SecurityAuthentication | undefined = _options?.authMethods?.default || this.configuration?.authMethods?.default\n        if (defaultAuth?.applySecurityAuthentication) {\n            await defaultAuth?.applySecurityAuthentication(requestContext);\n        }\n\n        return requestContext;\n    }\n\n    /**\n     * Get a token by its contract address and token ID.\n     * @param contractAddress A hex address for a blockchain contract.\n     * @param tokenID An arbitrary ID defined by a contract to uniquely identify a cryptographic asset such as an NFT.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     */\n    public async getToken(contractAddress: string, tokenID: string, chainID?: string, _options?: Configuration): Promise<RequestContext> {\n        let _config = _options || this.configuration;\n\n        // verify required parameter 'contractAddress' is not null or undefined\n        if (contractAddress === null || contractAddress === undefined) {\n            throw new RequiredError(\"DefaultApi\", \"getToken\", \"contractAddress\");\n        }\n\n\n        // verify required parameter 'tokenID' is not null or undefined\n        if (tokenID === null || tokenID === undefined) {\n            throw new RequiredError(\"DefaultApi\", \"getToken\", \"tokenID\");\n        }\n\n\n\n        // Path Params\n        const localVarPath = '/api/v1/tokens/{contractAddress}/{tokenID}'\n            .replace('{' + 'contractAddress' + '}', encodeURIComponent(String(contractAddress)))\n            .replace('{' + 'tokenID' + '}', encodeURIComponent(String(tokenID)));\n\n        // Make Request Context\n        const requestContext = _config.baseServer.makeRequestContext(localVarPath, HttpMethod.GET);\n        requestContext.setHeaderParam(\"Accept\", \"application/json, */*;q=0.8\")\n\n        // Query Params\n        if (chainID !== undefined) {\n            requestContext.setQueryParam(\"chainID\", ObjectSerializer.serialize(chainID, \"string\", \"\"));\n        }\n\n\n        let authMethod: SecurityAuthentication | undefined;\n        // Apply auth methods\n        authMethod = _config.authMethods[\"apikey\"]\n        if (authMethod?.applySecurityAuthentication) {\n            await authMethod?.applySecurityAuthentication(requestContext);\n        }\n        \n        const defaultAuth: SecurityAuthentication | undefined = _options?.authMethods?.default || this.configuration?.authMethods?.default\n        if (defaultAuth?.applySecurityAuthentication) {\n            await defaultAuth?.applySecurityAuthentication(requestContext);\n        }\n\n        return requestContext;\n    }\n\n    /**\n     * Determine if a wallet has a given token from a contract.\n     * @param tokenID An arbitrary ID defined by a contract to uniquely identify a cryptographic asset such as an NFT.\n     * @param contractAddress A hex address for a blockchain contract.\n     * @param walletAddress A hex string referencing a public wallet address.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     */\n    public async getTokenGate(tokenID: string, contractAddress: string, walletAddress: string, chainID?: string, _options?: Configuration): Promise<RequestContext> {\n        let _config = _options || this.configuration;\n\n        // verify required parameter 'tokenID' is not null or undefined\n        if (tokenID === null || tokenID === undefined) {\n            throw new RequiredError(\"DefaultApi\", \"getTokenGate\", \"tokenID\");\n        }\n\n\n        // verify required parameter 'contractAddress' is not null or undefined\n        if (contractAddress === null || contractAddress === undefined) {\n            throw new RequiredError(\"DefaultApi\", \"getTokenGate\", \"contractAddress\");\n        }\n\n\n        // verify required parameter 'walletAddress' is not null or undefined\n        if (walletAddress === null || walletAddress === undefined) {\n            throw new RequiredError(\"DefaultApi\", \"getTokenGate\", \"walletAddress\");\n        }\n\n\n\n        // Path Params\n        const localVarPath = '/api/v1/wallets/{walletAddress}/gate/{contractAddress}/{tokenID}'\n            .replace('{' + 'tokenID' + '}', encodeURIComponent(String(tokenID)))\n            .replace('{' + 'contractAddress' + '}', encodeURIComponent(String(contractAddress)))\n            .replace('{' + 'walletAddress' + '}', encodeURIComponent(String(walletAddress)));\n\n        // Make Request Context\n        const requestContext = _config.baseServer.makeRequestContext(localVarPath, HttpMethod.GET);\n        requestContext.setHeaderParam(\"Accept\", \"application/json, */*;q=0.8\")\n\n        // Query Params\n        if (chainID !== undefined) {\n            requestContext.setQueryParam(\"chainID\", ObjectSerializer.serialize(chainID, \"string\", \"\"));\n        }\n\n\n        let authMethod: SecurityAuthentication | undefined;\n        // Apply auth methods\n        authMethod = _config.authMethods[\"apikey\"]\n        if (authMethod?.applySecurityAuthentication) {\n            await authMethod?.applySecurityAuthentication(requestContext);\n        }\n        \n        const defaultAuth: SecurityAuthentication | undefined = _options?.authMethods?.default || this.configuration?.authMethods?.default\n        if (defaultAuth?.applySecurityAuthentication) {\n            await defaultAuth?.applySecurityAuthentication(requestContext);\n        }\n\n        return requestContext;\n    }\n\n    /**\n     * Returns a list of transfer transactions on a specified token.\n     * @param contractAddress A hex address for a blockchain contract.\n     * @param tokenID An arbitrary ID defined by a contract to uniquely identify a cryptographic asset such as an NFT.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     * @param limit Limits the number of results in a single response.\n     */\n    public async getTokenTransfers(contractAddress: string, tokenID: string, chainID?: string, limit?: number, _options?: Configuration): Promise<RequestContext> {\n        let _config = _options || this.configuration;\n\n        // verify required parameter 'contractAddress' is not null or undefined\n        if (contractAddress === null || contractAddress === undefined) {\n            throw new RequiredError(\"DefaultApi\", \"getTokenTransfers\", \"contractAddress\");\n        }\n\n\n        // verify required parameter 'tokenID' is not null or undefined\n        if (tokenID === null || tokenID === undefined) {\n            throw new RequiredError(\"DefaultApi\", \"getTokenTransfers\", \"tokenID\");\n        }\n\n\n\n\n        // Path Params\n        const localVarPath = '/api/v1/tokens/{contractAddress}/{tokenID}/transfers'\n            .replace('{' + 'contractAddress' + '}', encodeURIComponent(String(contractAddress)))\n            .replace('{' + 'tokenID' + '}', encodeURIComponent(String(tokenID)));\n\n        // Make Request Context\n        const requestContext = _config.baseServer.makeRequestContext(localVarPath, HttpMethod.GET);\n        requestContext.setHeaderParam(\"Accept\", \"application/json, */*;q=0.8\")\n\n        // Query Params\n        if (chainID !== undefined) {\n            requestContext.setQueryParam(\"chainID\", ObjectSerializer.serialize(chainID, \"string\", \"\"));\n        }\n\n        // Query Params\n        if (limit !== undefined) {\n            requestContext.setQueryParam(\"limit\", ObjectSerializer.serialize(limit, \"number\", \"\"));\n        }\n\n\n        let authMethod: SecurityAuthentication | undefined;\n        // Apply auth methods\n        authMethod = _config.authMethods[\"apikey\"]\n        if (authMethod?.applySecurityAuthentication) {\n            await authMethod?.applySecurityAuthentication(requestContext);\n        }\n        \n        const defaultAuth: SecurityAuthentication | undefined = _options?.authMethods?.default || this.configuration?.authMethods?.default\n        if (defaultAuth?.applySecurityAuthentication) {\n            await defaultAuth?.applySecurityAuthentication(requestContext);\n        }\n\n        return requestContext;\n    }\n\n    /**\n     * Get tokens by a search query.\n     * @param query A search query that returns matching results\n     * @param cursor Cursor to support API pagination.\n     */\n    public async getTokensBySearchQuery(query: string, cursor?: string, _options?: Configuration): Promise<RequestContext> {\n        let _config = _options || this.configuration;\n\n        // verify required parameter 'query' is not null or undefined\n        if (query === null || query === undefined) {\n            throw new RequiredError(\"DefaultApi\", \"getTokensBySearchQuery\", \"query\");\n        }\n\n\n\n        // Path Params\n        const localVarPath = '/api/v1/tokens/search/{query}'\n            .replace('{' + 'query' + '}', encodeURIComponent(String(query)));\n\n        // Make Request Context\n        const requestContext = _config.baseServer.makeRequestContext(localVarPath, HttpMethod.GET);\n        requestContext.setHeaderParam(\"Accept\", \"application/json, */*;q=0.8\")\n\n        // Query Params\n        if (cursor !== undefined) {\n            requestContext.setQueryParam(\"cursor\", ObjectSerializer.serialize(cursor, \"string\", \"\"));\n        }\n\n\n        let authMethod: SecurityAuthentication | undefined;\n        // Apply auth methods\n        authMethod = _config.authMethods[\"apikey\"]\n        if (authMethod?.applySecurityAuthentication) {\n            await authMethod?.applySecurityAuthentication(requestContext);\n        }\n        \n        const defaultAuth: SecurityAuthentication | undefined = _options?.authMethods?.default || this.configuration?.authMethods?.default\n        if (defaultAuth?.applySecurityAuthentication) {\n            await defaultAuth?.applySecurityAuthentication(requestContext);\n        }\n\n        return requestContext;\n    }\n\n    /**\n     * Get a wallet by a wallet address\n     * @param walletAddress A hex string referencing a public wallet address.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     */\n    public async getWallet(walletAddress: string, chainID?: string, _options?: Configuration): Promise<RequestContext> {\n        let _config = _options || this.configuration;\n\n        // verify required parameter 'walletAddress' is not null or undefined\n        if (walletAddress === null || walletAddress === undefined) {\n            throw new RequiredError(\"DefaultApi\", \"getWallet\", \"walletAddress\");\n        }\n\n\n\n        // Path Params\n        const localVarPath = '/api/v1/wallets/{walletAddress}'\n            .replace('{' + 'walletAddress' + '}', encodeURIComponent(String(walletAddress)));\n\n        // Make Request Context\n        const requestContext = _config.baseServer.makeRequestContext(localVarPath, HttpMethod.GET);\n        requestContext.setHeaderParam(\"Accept\", \"application/json, */*;q=0.8\")\n\n        // Query Params\n        if (chainID !== undefined) {\n            requestContext.setQueryParam(\"chainID\", ObjectSerializer.serialize(chainID, \"string\", \"\"));\n        }\n\n\n        let authMethod: SecurityAuthentication | undefined;\n        // Apply auth methods\n        authMethod = _config.authMethods[\"apikey\"]\n        if (authMethod?.applySecurityAuthentication) {\n            await authMethod?.applySecurityAuthentication(requestContext);\n        }\n        \n        const defaultAuth: SecurityAuthentication | undefined = _options?.authMethods?.default || this.configuration?.authMethods?.default\n        if (defaultAuth?.applySecurityAuthentication) {\n            await defaultAuth?.applySecurityAuthentication(requestContext);\n        }\n\n        return requestContext;\n    }\n\n    /**\n     * Returns a list of balances for tokens this wallet currently owns.\n     * @param walletAddress A hex string referencing a public wallet address.\n     * @param limit Limits the number of results in a single response.\n     */\n    public async getWalletBalances(walletAddress: string, limit?: number, _options?: Configuration): Promise<RequestContext> {\n        let _config = _options || this.configuration;\n\n        // verify required parameter 'walletAddress' is not null or undefined\n        if (walletAddress === null || walletAddress === undefined) {\n            throw new RequiredError(\"DefaultApi\", \"getWalletBalances\", \"walletAddress\");\n        }\n\n\n\n        // Path Params\n        const localVarPath = '/api/v1/wallets/{walletAddress}/balances'\n            .replace('{' + 'walletAddress' + '}', encodeURIComponent(String(walletAddress)));\n\n        // Make Request Context\n        const requestContext = _config.baseServer.makeRequestContext(localVarPath, HttpMethod.GET);\n        requestContext.setHeaderParam(\"Accept\", \"application/json, */*;q=0.8\")\n\n        // Query Params\n        if (limit !== undefined) {\n            requestContext.setQueryParam(\"limit\", ObjectSerializer.serialize(limit, \"number\", \"\"));\n        }\n\n\n        let authMethod: SecurityAuthentication | undefined;\n        // Apply auth methods\n        authMethod = _config.authMethods[\"apikey\"]\n        if (authMethod?.applySecurityAuthentication) {\n            await authMethod?.applySecurityAuthentication(requestContext);\n        }\n        \n        const defaultAuth: SecurityAuthentication | undefined = _options?.authMethods?.default || this.configuration?.authMethods?.default\n        if (defaultAuth?.applySecurityAuthentication) {\n            await defaultAuth?.applySecurityAuthentication(requestContext);\n        }\n\n        return requestContext;\n    }\n\n    /**\n     * Returns a list of tokens minted by a wallet.\n     * @param walletAddress A hex string referencing a public wallet address.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     * @param cursor Cursor to support API pagination.\n     * @param limit Limits the number of results in a single response.\n     */\n    public async getWalletMints(walletAddress: string, chainID?: string, cursor?: string, limit?: number, _options?: Configuration): Promise<RequestContext> {\n        let _config = _options || this.configuration;\n\n        // verify required parameter 'walletAddress' is not null or undefined\n        if (walletAddress === null || walletAddress === undefined) {\n            throw new RequiredError(\"DefaultApi\", \"getWalletMints\", \"walletAddress\");\n        }\n\n\n\n\n\n        // Path Params\n        const localVarPath = '/api/v1/wallets/{walletAddress}/mints'\n            .replace('{' + 'walletAddress' + '}', encodeURIComponent(String(walletAddress)));\n\n        // Make Request Context\n        const requestContext = _config.baseServer.makeRequestContext(localVarPath, HttpMethod.GET);\n        requestContext.setHeaderParam(\"Accept\", \"application/json, */*;q=0.8\")\n\n        // Query Params\n        if (chainID !== undefined) {\n            requestContext.setQueryParam(\"chainID\", ObjectSerializer.serialize(chainID, \"string\", \"\"));\n        }\n\n        // Query Params\n        if (cursor !== undefined) {\n            requestContext.setQueryParam(\"cursor\", ObjectSerializer.serialize(cursor, \"string\", \"\"));\n        }\n\n        // Query Params\n        if (limit !== undefined) {\n            requestContext.setQueryParam(\"limit\", ObjectSerializer.serialize(limit, \"number\", \"\"));\n        }\n\n\n        let authMethod: SecurityAuthentication | undefined;\n        // Apply auth methods\n        authMethod = _config.authMethods[\"apikey\"]\n        if (authMethod?.applySecurityAuthentication) {\n            await authMethod?.applySecurityAuthentication(requestContext);\n        }\n        \n        const defaultAuth: SecurityAuthentication | undefined = _options?.authMethods?.default || this.configuration?.authMethods?.default\n        if (defaultAuth?.applySecurityAuthentication) {\n            await defaultAuth?.applySecurityAuthentication(requestContext);\n        }\n\n        return requestContext;\n    }\n\n    /**\n     * Returns a list of tokens owned by a wallet.\n     * @param walletAddress A hex string referencing a public wallet address.\n     * @param cursor Cursor to support API pagination.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     * @param limit Limits the number of results in a single response.\n     */\n    public async getWalletTokens(walletAddress: string, cursor?: string, chainID?: string, limit?: number, _options?: Configuration): Promise<RequestContext> {\n        let _config = _options || this.configuration;\n\n        // verify required parameter 'walletAddress' is not null or undefined\n        if (walletAddress === null || walletAddress === undefined) {\n            throw new RequiredError(\"DefaultApi\", \"getWalletTokens\", \"walletAddress\");\n        }\n\n\n\n\n\n        // Path Params\n        const localVarPath = '/api/v1/wallets/{walletAddress}/tokens'\n            .replace('{' + 'walletAddress' + '}', encodeURIComponent(String(walletAddress)));\n\n        // Make Request Context\n        const requestContext = _config.baseServer.makeRequestContext(localVarPath, HttpMethod.GET);\n        requestContext.setHeaderParam(\"Accept\", \"application/json, */*;q=0.8\")\n\n        // Query Params\n        if (cursor !== undefined) {\n            requestContext.setQueryParam(\"cursor\", ObjectSerializer.serialize(cursor, \"string\", \"\"));\n        }\n\n        // Query Params\n        if (chainID !== undefined) {\n            requestContext.setQueryParam(\"chainID\", ObjectSerializer.serialize(chainID, \"string\", \"\"));\n        }\n\n        // Query Params\n        if (limit !== undefined) {\n            requestContext.setQueryParam(\"limit\", ObjectSerializer.serialize(limit, \"number\", \"\"));\n        }\n\n\n        let authMethod: SecurityAuthentication | undefined;\n        // Apply auth methods\n        authMethod = _config.authMethods[\"apikey\"]\n        if (authMethod?.applySecurityAuthentication) {\n            await authMethod?.applySecurityAuthentication(requestContext);\n        }\n        \n        const defaultAuth: SecurityAuthentication | undefined = _options?.authMethods?.default || this.configuration?.authMethods?.default\n        if (defaultAuth?.applySecurityAuthentication) {\n            await defaultAuth?.applySecurityAuthentication(requestContext);\n        }\n\n        return requestContext;\n    }\n\n    /**\n     * Returns transactions related to a wallet.\n     * @param walletAddress A hex string referencing a public wallet address.\n     * @param cursor Cursor to support API pagination.\n     * @param limit Limits the number of results in a single response.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     * @param tokenType An indicator that be used to filter to only a subet of tokens, for example only NFTs. To select ERC-20, sidechain and L1 transactions, use the \\&quot;fungible.\\&quot; To select only NFTs or semi-fungible tokens (SFTs), use the respective enum.\n     */\n    public async getWalletTransactions(walletAddress: string, cursor?: string, limit?: number, chainID?: string, tokenType?: 'native' | 'fungible' | 'NFT' | 'SFT' | 'unknown', _options?: Configuration): Promise<RequestContext> {\n        let _config = _options || this.configuration;\n\n        // verify required parameter 'walletAddress' is not null or undefined\n        if (walletAddress === null || walletAddress === undefined) {\n            throw new RequiredError(\"DefaultApi\", \"getWalletTransactions\", \"walletAddress\");\n        }\n\n\n\n\n\n\n        // Path Params\n        const localVarPath = '/api/v1/wallets/{walletAddress}/transactions/history'\n            .replace('{' + 'walletAddress' + '}', encodeURIComponent(String(walletAddress)));\n\n        // Make Request Context\n        const requestContext = _config.baseServer.makeRequestContext(localVarPath, HttpMethod.GET);\n        requestContext.setHeaderParam(\"Accept\", \"application/json, */*;q=0.8\")\n\n        // Query Params\n        if (cursor !== undefined) {\n            requestContext.setQueryParam(\"cursor\", ObjectSerializer.serialize(cursor, \"string\", \"\"));\n        }\n\n        // Query Params\n        if (limit !== undefined) {\n            requestContext.setQueryParam(\"limit\", ObjectSerializer.serialize(limit, \"number\", \"\"));\n        }\n\n        // Query Params\n        if (chainID !== undefined) {\n            requestContext.setQueryParam(\"chainID\", ObjectSerializer.serialize(chainID, \"string\", \"\"));\n        }\n\n        // Query Params\n        if (tokenType !== undefined) {\n            requestContext.setQueryParam(\"tokenType\", ObjectSerializer.serialize(tokenType, \"'native' | 'fungible' | 'NFT' | 'SFT' | 'unknown'\", \"\"));\n        }\n\n\n        let authMethod: SecurityAuthentication | undefined;\n        // Apply auth methods\n        authMethod = _config.authMethods[\"apikey\"]\n        if (authMethod?.applySecurityAuthentication) {\n            await authMethod?.applySecurityAuthentication(requestContext);\n        }\n        \n        const defaultAuth: SecurityAuthentication | undefined = _options?.authMethods?.default || this.configuration?.authMethods?.default\n        if (defaultAuth?.applySecurityAuthentication) {\n            await defaultAuth?.applySecurityAuthentication(requestContext);\n        }\n\n        return requestContext;\n    }\n\n}\n\nexport class DefaultApiResponseProcessor {\n\n    /**\n     * Unwraps the actual response sent by the server from the response context and deserializes the response content\n     * to the expected objects\n     *\n     * @params response Response returned by the server for a request to getBlockchains\n     * @throws ApiException if the response code was not in [200, 299]\n     */\n     public async getBlockchains(response: ResponseContext): Promise<Array<BlockchainInfo> > {\n        const contentType = ObjectSerializer.normalizeMediaType(response.headers[\"content-type\"]);\n        if (isCodeInRange(\"200\", response.httpStatusCode)) {\n            const body: Array<BlockchainInfo> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<BlockchainInfo>\", \"\"\n            ) as Array<BlockchainInfo>;\n            return body;\n        }\n        if (isCodeInRange(\"0\", response.httpStatusCode)) {\n            const body: ErrorMessage = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"ErrorMessage\", \"\"\n            ) as ErrorMessage;\n            throw new ApiException<ErrorMessage>(response.httpStatusCode, \"An error message for unexpected requests.\", body, response.headers);\n        }\n\n        // Work around for missing responses in specification, e.g. for petstore.yaml\n        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {\n            const body: Array<BlockchainInfo> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<BlockchainInfo>\", \"\"\n            ) as Array<BlockchainInfo>;\n            return body;\n        }\n\n        throw new ApiException<string | Blob | undefined>(response.httpStatusCode, \"Unknown API Status Code!\", await response.getBodyAsAny(), response.headers);\n    }\n\n    /**\n     * Unwraps the actual response sent by the server from the response context and deserializes the response content\n     * to the expected objects\n     *\n     * @params response Response returned by the server for a request to getCollection\n     * @throws ApiException if the response code was not in [200, 299]\n     */\n     public async getCollection(response: ResponseContext): Promise<Array<Collection> > {\n        const contentType = ObjectSerializer.normalizeMediaType(response.headers[\"content-type\"]);\n        if (isCodeInRange(\"200\", response.httpStatusCode)) {\n            const body: Array<Collection> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<Collection>\", \"\"\n            ) as Array<Collection>;\n            return body;\n        }\n        if (isCodeInRange(\"0\", response.httpStatusCode)) {\n            const body: ErrorMessage = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"ErrorMessage\", \"\"\n            ) as ErrorMessage;\n            throw new ApiException<ErrorMessage>(response.httpStatusCode, \"An error message for unexpected requests.\", body, response.headers);\n        }\n\n        // Work around for missing responses in specification, e.g. for petstore.yaml\n        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {\n            const body: Array<Collection> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<Collection>\", \"\"\n            ) as Array<Collection>;\n            return body;\n        }\n\n        throw new ApiException<string | Blob | undefined>(response.httpStatusCode, \"Unknown API Status Code!\", await response.getBodyAsAny(), response.headers);\n    }\n\n    /**\n     * Unwraps the actual response sent by the server from the response context and deserializes the response content\n     * to the expected objects\n     *\n     * @params response Response returned by the server for a request to getContractGate\n     * @throws ApiException if the response code was not in [200, 299]\n     */\n     public async getContractGate(response: ResponseContext): Promise<AssetGate > {\n        const contentType = ObjectSerializer.normalizeMediaType(response.headers[\"content-type\"]);\n        if (isCodeInRange(\"200\", response.httpStatusCode)) {\n            const body: AssetGate = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"AssetGate\", \"\"\n            ) as AssetGate;\n            return body;\n        }\n        if (isCodeInRange(\"0\", response.httpStatusCode)) {\n            const body: ErrorMessage = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"ErrorMessage\", \"\"\n            ) as ErrorMessage;\n            throw new ApiException<ErrorMessage>(response.httpStatusCode, \"An error message for unexpected requests.\", body, response.headers);\n        }\n\n        // Work around for missing responses in specification, e.g. for petstore.yaml\n        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {\n            const body: AssetGate = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"AssetGate\", \"\"\n            ) as AssetGate;\n            return body;\n        }\n\n        throw new ApiException<string | Blob | undefined>(response.httpStatusCode, \"Unknown API Status Code!\", await response.getBodyAsAny(), response.headers);\n    }\n\n    /**\n     * Unwraps the actual response sent by the server from the response context and deserializes the response content\n     * to the expected objects\n     *\n     * @params response Response returned by the server for a request to getContractTokens\n     * @throws ApiException if the response code was not in [200, 299]\n     */\n     public async getContractTokens(response: ResponseContext): Promise<Array<Token> > {\n        const contentType = ObjectSerializer.normalizeMediaType(response.headers[\"content-type\"]);\n        if (isCodeInRange(\"200\", response.httpStatusCode)) {\n            const body: Array<Token> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<Token>\", \"\"\n            ) as Array<Token>;\n            return body;\n        }\n        if (isCodeInRange(\"0\", response.httpStatusCode)) {\n            const body: ErrorMessage = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"ErrorMessage\", \"\"\n            ) as ErrorMessage;\n            throw new ApiException<ErrorMessage>(response.httpStatusCode, \"An error message for unexpected requests.\", body, response.headers);\n        }\n\n        // Work around for missing responses in specification, e.g. for petstore.yaml\n        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {\n            const body: Array<Token> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<Token>\", \"\"\n            ) as Array<Token>;\n            return body;\n        }\n\n        throw new ApiException<string | Blob | undefined>(response.httpStatusCode, \"Unknown API Status Code!\", await response.getBodyAsAny(), response.headers);\n    }\n\n    /**\n     * Unwraps the actual response sent by the server from the response context and deserializes the response content\n     * to the expected objects\n     *\n     * @params response Response returned by the server for a request to getContractTokensByContractAndID\n     * @throws ApiException if the response code was not in [200, 299]\n     */\n     public async getContractTokensByContractAndID(response: ResponseContext): Promise<Array<Token> > {\n        const contentType = ObjectSerializer.normalizeMediaType(response.headers[\"content-type\"]);\n        if (isCodeInRange(\"200\", response.httpStatusCode)) {\n            const body: Array<Token> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<Token>\", \"\"\n            ) as Array<Token>;\n            return body;\n        }\n        if (isCodeInRange(\"0\", response.httpStatusCode)) {\n            const body: ErrorMessage = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"ErrorMessage\", \"\"\n            ) as ErrorMessage;\n            throw new ApiException<ErrorMessage>(response.httpStatusCode, \"An error message for unexpected requests.\", body, response.headers);\n        }\n\n        // Work around for missing responses in specification, e.g. for petstore.yaml\n        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {\n            const body: Array<Token> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<Token>\", \"\"\n            ) as Array<Token>;\n            return body;\n        }\n\n        throw new ApiException<string | Blob | undefined>(response.httpStatusCode, \"Unknown API Status Code!\", await response.getBodyAsAny(), response.headers);\n    }\n\n    /**\n     * Unwraps the actual response sent by the server from the response context and deserializes the response content\n     * to the expected objects\n     *\n     * @params response Response returned by the server for a request to getContractTransactionHistory\n     * @throws ApiException if the response code was not in [200, 299]\n     */\n     public async getContractTransactionHistory(response: ResponseContext): Promise<Array<Transaction> > {\n        const contentType = ObjectSerializer.normalizeMediaType(response.headers[\"content-type\"]);\n        if (isCodeInRange(\"200\", response.httpStatusCode)) {\n            const body: Array<Transaction> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<Transaction>\", \"\"\n            ) as Array<Transaction>;\n            return body;\n        }\n        if (isCodeInRange(\"0\", response.httpStatusCode)) {\n            const body: ErrorMessage = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"ErrorMessage\", \"\"\n            ) as ErrorMessage;\n            throw new ApiException<ErrorMessage>(response.httpStatusCode, \"An error message for unexpected requests.\", body, response.headers);\n        }\n\n        // Work around for missing responses in specification, e.g. for petstore.yaml\n        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {\n            const body: Array<Transaction> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<Transaction>\", \"\"\n            ) as Array<Transaction>;\n            return body;\n        }\n\n        throw new ApiException<string | Blob | undefined>(response.httpStatusCode, \"Unknown API Status Code!\", await response.getBodyAsAny(), response.headers);\n    }\n\n    /**\n     * Unwraps the actual response sent by the server from the response context and deserializes the response content\n     * to the expected objects\n     *\n     * @params response Response returned by the server for a request to getSearchResults\n     * @throws ApiException if the response code was not in [200, 299]\n     */\n     public async getSearchResults(response: ResponseContext): Promise<Array<SearchDocument> > {\n        const contentType = ObjectSerializer.normalizeMediaType(response.headers[\"content-type\"]);\n        if (isCodeInRange(\"200\", response.httpStatusCode)) {\n            const body: Array<SearchDocument> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<SearchDocument>\", \"\"\n            ) as Array<SearchDocument>;\n            return body;\n        }\n        if (isCodeInRange(\"0\", response.httpStatusCode)) {\n            const body: ErrorMessage = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"ErrorMessage\", \"\"\n            ) as ErrorMessage;\n            throw new ApiException<ErrorMessage>(response.httpStatusCode, \"An error message for unexpected requests.\", body, response.headers);\n        }\n\n        // Work around for missing responses in specification, e.g. for petstore.yaml\n        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {\n            const body: Array<SearchDocument> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<SearchDocument>\", \"\"\n            ) as Array<SearchDocument>;\n            return body;\n        }\n\n        throw new ApiException<string | Blob | undefined>(response.httpStatusCode, \"Unknown API Status Code!\", await response.getBodyAsAny(), response.headers);\n    }\n\n    /**\n     * Unwraps the actual response sent by the server from the response context and deserializes the response content\n     * to the expected objects\n     *\n     * @params response Response returned by the server for a request to getSoldTokens\n     * @throws ApiException if the response code was not in [200, 299]\n     */\n     public async getSoldTokens(response: ResponseContext): Promise<Array<Token> > {\n        const contentType = ObjectSerializer.normalizeMediaType(response.headers[\"content-type\"]);\n        if (isCodeInRange(\"200\", response.httpStatusCode)) {\n            const body: Array<Token> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<Token>\", \"\"\n            ) as Array<Token>;\n            return body;\n        }\n        if (isCodeInRange(\"0\", response.httpStatusCode)) {\n            const body: ErrorMessage = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"ErrorMessage\", \"\"\n            ) as ErrorMessage;\n            throw new ApiException<ErrorMessage>(response.httpStatusCode, \"An error message for unexpected requests.\", body, response.headers);\n        }\n\n        // Work around for missing responses in specification, e.g. for petstore.yaml\n        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {\n            const body: Array<Token> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<Token>\", \"\"\n            ) as Array<Token>;\n            return body;\n        }\n\n        throw new ApiException<string | Blob | undefined>(response.httpStatusCode, \"Unknown API Status Code!\", await response.getBodyAsAny(), response.headers);\n    }\n\n    /**\n     * Unwraps the actual response sent by the server from the response context and deserializes the response content\n     * to the expected objects\n     *\n     * @params response Response returned by the server for a request to getSuggestionsResults\n     * @throws ApiException if the response code was not in [200, 299]\n     */\n     public async getSuggestionsResults(response: ResponseContext): Promise<Array<AutoSuggestion> > {\n        const contentType = ObjectSerializer.normalizeMediaType(response.headers[\"content-type\"]);\n        if (isCodeInRange(\"200\", response.httpStatusCode)) {\n            const body: Array<AutoSuggestion> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<AutoSuggestion>\", \"\"\n            ) as Array<AutoSuggestion>;\n            return body;\n        }\n        if (isCodeInRange(\"0\", response.httpStatusCode)) {\n            const body: ErrorMessage = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"ErrorMessage\", \"\"\n            ) as ErrorMessage;\n            throw new ApiException<ErrorMessage>(response.httpStatusCode, \"An error message for unexpected requests.\", body, response.headers);\n        }\n\n        // Work around for missing responses in specification, e.g. for petstore.yaml\n        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {\n            const body: Array<AutoSuggestion> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<AutoSuggestion>\", \"\"\n            ) as Array<AutoSuggestion>;\n            return body;\n        }\n\n        throw new ApiException<string | Blob | undefined>(response.httpStatusCode, \"Unknown API Status Code!\", await response.getBodyAsAny(), response.headers);\n    }\n\n    /**\n     * Unwraps the actual response sent by the server from the response context and deserializes the response content\n     * to the expected objects\n     *\n     * @params response Response returned by the server for a request to getToken\n     * @throws ApiException if the response code was not in [200, 299]\n     */\n     public async getToken(response: ResponseContext): Promise<Array<Token> > {\n        const contentType = ObjectSerializer.normalizeMediaType(response.headers[\"content-type\"]);\n        if (isCodeInRange(\"200\", response.httpStatusCode)) {\n            const body: Array<Token> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<Token>\", \"\"\n            ) as Array<Token>;\n            return body;\n        }\n        if (isCodeInRange(\"0\", response.httpStatusCode)) {\n            const body: ErrorMessage = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"ErrorMessage\", \"\"\n            ) as ErrorMessage;\n            throw new ApiException<ErrorMessage>(response.httpStatusCode, \"An error message for unexpected requests.\", body, response.headers);\n        }\n\n        // Work around for missing responses in specification, e.g. for petstore.yaml\n        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {\n            const body: Array<Token> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<Token>\", \"\"\n            ) as Array<Token>;\n            return body;\n        }\n\n        throw new ApiException<string | Blob | undefined>(response.httpStatusCode, \"Unknown API Status Code!\", await response.getBodyAsAny(), response.headers);\n    }\n\n    /**\n     * Unwraps the actual response sent by the server from the response context and deserializes the response content\n     * to the expected objects\n     *\n     * @params response Response returned by the server for a request to getTokenGate\n     * @throws ApiException if the response code was not in [200, 299]\n     */\n     public async getTokenGate(response: ResponseContext): Promise<AssetGate > {\n        const contentType = ObjectSerializer.normalizeMediaType(response.headers[\"content-type\"]);\n        if (isCodeInRange(\"200\", response.httpStatusCode)) {\n            const body: AssetGate = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"AssetGate\", \"\"\n            ) as AssetGate;\n            return body;\n        }\n        if (isCodeInRange(\"0\", response.httpStatusCode)) {\n            const body: ErrorMessage = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"ErrorMessage\", \"\"\n            ) as ErrorMessage;\n            throw new ApiException<ErrorMessage>(response.httpStatusCode, \"An error message for unexpected requests.\", body, response.headers);\n        }\n\n        // Work around for missing responses in specification, e.g. for petstore.yaml\n        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {\n            const body: AssetGate = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"AssetGate\", \"\"\n            ) as AssetGate;\n            return body;\n        }\n\n        throw new ApiException<string | Blob | undefined>(response.httpStatusCode, \"Unknown API Status Code!\", await response.getBodyAsAny(), response.headers);\n    }\n\n    /**\n     * Unwraps the actual response sent by the server from the response context and deserializes the response content\n     * to the expected objects\n     *\n     * @params response Response returned by the server for a request to getTokenTransfers\n     * @throws ApiException if the response code was not in [200, 299]\n     */\n     public async getTokenTransfers(response: ResponseContext): Promise<TokenEvents > {\n        const contentType = ObjectSerializer.normalizeMediaType(response.headers[\"content-type\"]);\n        if (isCodeInRange(\"200\", response.httpStatusCode)) {\n            const body: TokenEvents = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"TokenEvents\", \"\"\n            ) as TokenEvents;\n            return body;\n        }\n        if (isCodeInRange(\"0\", response.httpStatusCode)) {\n            const body: ErrorMessage = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"ErrorMessage\", \"\"\n            ) as ErrorMessage;\n            throw new ApiException<ErrorMessage>(response.httpStatusCode, \"An error message for unexpected requests.\", body, response.headers);\n        }\n\n        // Work around for missing responses in specification, e.g. for petstore.yaml\n        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {\n            const body: TokenEvents = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"TokenEvents\", \"\"\n            ) as TokenEvents;\n            return body;\n        }\n\n        throw new ApiException<string | Blob | undefined>(response.httpStatusCode, \"Unknown API Status Code!\", await response.getBodyAsAny(), response.headers);\n    }\n\n    /**\n     * Unwraps the actual response sent by the server from the response context and deserializes the response content\n     * to the expected objects\n     *\n     * @params response Response returned by the server for a request to getTokensBySearchQuery\n     * @throws ApiException if the response code was not in [200, 299]\n     */\n     public async getTokensBySearchQuery(response: ResponseContext): Promise<Array<Token> > {\n        const contentType = ObjectSerializer.normalizeMediaType(response.headers[\"content-type\"]);\n        if (isCodeInRange(\"200\", response.httpStatusCode)) {\n            const body: Array<Token> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<Token>\", \"\"\n            ) as Array<Token>;\n            return body;\n        }\n        if (isCodeInRange(\"0\", response.httpStatusCode)) {\n            const body: ErrorMessage = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"ErrorMessage\", \"\"\n            ) as ErrorMessage;\n            throw new ApiException<ErrorMessage>(response.httpStatusCode, \"An error message for unexpected requests.\", body, response.headers);\n        }\n\n        // Work around for missing responses in specification, e.g. for petstore.yaml\n        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {\n            const body: Array<Token> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<Token>\", \"\"\n            ) as Array<Token>;\n            return body;\n        }\n\n        throw new ApiException<string | Blob | undefined>(response.httpStatusCode, \"Unknown API Status Code!\", await response.getBodyAsAny(), response.headers);\n    }\n\n    /**\n     * Unwraps the actual response sent by the server from the response context and deserializes the response content\n     * to the expected objects\n     *\n     * @params response Response returned by the server for a request to getWallet\n     * @throws ApiException if the response code was not in [200, 299]\n     */\n     public async getWallet(response: ResponseContext): Promise<Array<Wallet> > {\n        const contentType = ObjectSerializer.normalizeMediaType(response.headers[\"content-type\"]);\n        if (isCodeInRange(\"200\", response.httpStatusCode)) {\n            const body: Array<Wallet> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<Wallet>\", \"\"\n            ) as Array<Wallet>;\n            return body;\n        }\n        if (isCodeInRange(\"0\", response.httpStatusCode)) {\n            const body: ErrorMessage = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"ErrorMessage\", \"\"\n            ) as ErrorMessage;\n            throw new ApiException<ErrorMessage>(response.httpStatusCode, \"An error message for unexpected requests.\", body, response.headers);\n        }\n\n        // Work around for missing responses in specification, e.g. for petstore.yaml\n        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {\n            const body: Array<Wallet> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<Wallet>\", \"\"\n            ) as Array<Wallet>;\n            return body;\n        }\n\n        throw new ApiException<string | Blob | undefined>(response.httpStatusCode, \"Unknown API Status Code!\", await response.getBodyAsAny(), response.headers);\n    }\n\n    /**\n     * Unwraps the actual response sent by the server from the response context and deserializes the response content\n     * to the expected objects\n     *\n     * @params response Response returned by the server for a request to getWalletBalances\n     * @throws ApiException if the response code was not in [200, 299]\n     */\n     public async getWalletBalances(response: ResponseContext): Promise<Array<CurrencyInfo> > {\n        const contentType = ObjectSerializer.normalizeMediaType(response.headers[\"content-type\"]);\n        if (isCodeInRange(\"200\", response.httpStatusCode)) {\n            const body: Array<CurrencyInfo> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<CurrencyInfo>\", \"\"\n            ) as Array<CurrencyInfo>;\n            return body;\n        }\n        if (isCodeInRange(\"0\", response.httpStatusCode)) {\n            const body: ErrorMessage = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"ErrorMessage\", \"\"\n            ) as ErrorMessage;\n            throw new ApiException<ErrorMessage>(response.httpStatusCode, \"An error message for unexpected requests.\", body, response.headers);\n        }\n\n        // Work around for missing responses in specification, e.g. for petstore.yaml\n        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {\n            const body: Array<CurrencyInfo> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<CurrencyInfo>\", \"\"\n            ) as Array<CurrencyInfo>;\n            return body;\n        }\n\n        throw new ApiException<string | Blob | undefined>(response.httpStatusCode, \"Unknown API Status Code!\", await response.getBodyAsAny(), response.headers);\n    }\n\n    /**\n     * Unwraps the actual response sent by the server from the response context and deserializes the response content\n     * to the expected objects\n     *\n     * @params response Response returned by the server for a request to getWalletMints\n     * @throws ApiException if the response code was not in [200, 299]\n     */\n     public async getWalletMints(response: ResponseContext): Promise<Array<Token> > {\n        const contentType = ObjectSerializer.normalizeMediaType(response.headers[\"content-type\"]);\n        if (isCodeInRange(\"200\", response.httpStatusCode)) {\n            const body: Array<Token> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<Token>\", \"\"\n            ) as Array<Token>;\n            return body;\n        }\n        if (isCodeInRange(\"0\", response.httpStatusCode)) {\n            const body: ErrorMessage = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"ErrorMessage\", \"\"\n            ) as ErrorMessage;\n            throw new ApiException<ErrorMessage>(response.httpStatusCode, \"An error message for unexpected requests.\", body, response.headers);\n        }\n\n        // Work around for missing responses in specification, e.g. for petstore.yaml\n        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {\n            const body: Array<Token> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<Token>\", \"\"\n            ) as Array<Token>;\n            return body;\n        }\n\n        throw new ApiException<string | Blob | undefined>(response.httpStatusCode, \"Unknown API Status Code!\", await response.getBodyAsAny(), response.headers);\n    }\n\n    /**\n     * Unwraps the actual response sent by the server from the response context and deserializes the response content\n     * to the expected objects\n     *\n     * @params response Response returned by the server for a request to getWalletTokens\n     * @throws ApiException if the response code was not in [200, 299]\n     */\n     public async getWalletTokens(response: ResponseContext): Promise<Array<Token> > {\n        const contentType = ObjectSerializer.normalizeMediaType(response.headers[\"content-type\"]);\n        if (isCodeInRange(\"200\", response.httpStatusCode)) {\n            const body: Array<Token> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<Token>\", \"\"\n            ) as Array<Token>;\n            return body;\n        }\n        if (isCodeInRange(\"0\", response.httpStatusCode)) {\n            const body: ErrorMessage = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"ErrorMessage\", \"\"\n            ) as ErrorMessage;\n            throw new ApiException<ErrorMessage>(response.httpStatusCode, \"An error message for unexpected requests.\", body, response.headers);\n        }\n\n        // Work around for missing responses in specification, e.g. for petstore.yaml\n        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {\n            const body: Array<Token> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<Token>\", \"\"\n            ) as Array<Token>;\n            return body;\n        }\n\n        throw new ApiException<string | Blob | undefined>(response.httpStatusCode, \"Unknown API Status Code!\", await response.getBodyAsAny(), response.headers);\n    }\n\n    /**\n     * Unwraps the actual response sent by the server from the response context and deserializes the response content\n     * to the expected objects\n     *\n     * @params response Response returned by the server for a request to getWalletTransactions\n     * @throws ApiException if the response code was not in [200, 299]\n     */\n     public async getWalletTransactions(response: ResponseContext): Promise<Array<Transaction> > {\n        const contentType = ObjectSerializer.normalizeMediaType(response.headers[\"content-type\"]);\n        if (isCodeInRange(\"200\", response.httpStatusCode)) {\n            const body: Array<Transaction> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<Transaction>\", \"\"\n            ) as Array<Transaction>;\n            return body;\n        }\n        if (isCodeInRange(\"0\", response.httpStatusCode)) {\n            const body: ErrorMessage = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"ErrorMessage\", \"\"\n            ) as ErrorMessage;\n            throw new ApiException<ErrorMessage>(response.httpStatusCode, \"An error message for unexpected requests.\", body, response.headers);\n        }\n\n        // Work around for missing responses in specification, e.g. for petstore.yaml\n        if (response.httpStatusCode >= 200 && response.httpStatusCode <= 299) {\n            const body: Array<Transaction> = ObjectSerializer.deserialize(\n                ObjectSerializer.parse(await response.body.text(), contentType),\n                \"Array<Transaction>\", \"\"\n            ) as Array<Transaction>;\n            return body;\n        }\n\n        throw new ApiException<string | Blob | undefined>(response.httpStatusCode, \"Unknown API Status Code!\", await response.getBodyAsAny(), response.headers);\n    }\n\n}\n","import { ResponseContext, RequestContext, HttpFile } from '../http/http';\nimport * as models from '../models/all';\nimport { Configuration} from '../configuration'\nimport { Observable, of, from } from '../rxjsStub';\nimport {mergeMap, map} from  '../rxjsStub';\nimport { AssetGate } from '../models/AssetGate';\nimport { AutoSuggestion } from '../models/AutoSuggestion';\nimport { BlockchainInfo } from '../models/BlockchainInfo';\nimport { Collection } from '../models/Collection';\nimport { CreditEvent } from '../models/CreditEvent';\nimport { CurrencyInfo } from '../models/CurrencyInfo';\nimport { ENS } from '../models/ENS';\nimport { ErrorMessage } from '../models/ErrorMessage';\nimport { ExchangeEvent } from '../models/ExchangeEvent';\nimport { Media } from '../models/Media';\nimport { MediaPreview } from '../models/MediaPreview';\nimport { MediaVersion } from '../models/MediaVersion';\nimport { NonFungibleToken } from '../models/NonFungibleToken';\nimport { OpenSeaContract } from '../models/OpenSeaContract';\nimport { OwnedCollection } from '../models/OwnedCollection';\nimport { SearchDocument } from '../models/SearchDocument';\nimport { SocialMedia } from '../models/SocialMedia';\nimport { Token } from '../models/Token';\nimport { TokenAttribute } from '../models/TokenAttribute';\nimport { TokenEvents } from '../models/TokenEvents';\nimport { Transaction } from '../models/Transaction';\nimport { TransactionLogLine } from '../models/TransactionLogLine';\nimport { URL } from '../models/URL';\nimport { Wallet } from '../models/Wallet';\n\nimport { AlphaApiRequestFactory, AlphaApiResponseProcessor} from \"../apis/AlphaApi\";\nexport class ObservableAlphaApi {\n    private requestFactory: AlphaApiRequestFactory;\n    private responseProcessor: AlphaApiResponseProcessor;\n    private configuration: Configuration;\n\n    public constructor(\n        configuration: Configuration,\n        requestFactory?: AlphaApiRequestFactory,\n        responseProcessor?: AlphaApiResponseProcessor\n    ) {\n        this.configuration = configuration;\n        this.requestFactory = requestFactory || new AlphaApiRequestFactory(configuration);\n        this.responseProcessor = responseProcessor || new AlphaApiResponseProcessor();\n    }\n\n    /**\n     * Returns trending and interesting collections on Ethereum. Useful for powering discovery experiences and providing an on-ramp to exploring creative blockchain data.\n     */\n    public getTopCollections(_options?: Configuration): Observable<Array<Collection>> {\n        const requestContextPromise = this.requestFactory.getTopCollections(_options);\n\n        // build promise chain\n        let middlewarePreObservable = from<RequestContext>(requestContextPromise);\n        for (let middleware of this.configuration.middleware) {\n            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));\n        }\n\n        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).\n            pipe(mergeMap((response: ResponseContext) => {\n                let middlewarePostObservable = of(response);\n                for (let middleware of this.configuration.middleware) {\n                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));\n                }\n                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getTopCollections(rsp)));\n            }));\n    }\n\n    /**\n     * Returns trending and interesting NFTs and SFTs on Ethereum. Useful for powering discovery experiences and providing an on-ramp to exploring creative blockchain data.\n     */\n    public getTopTokens(_options?: Configuration): Observable<Array<Token>> {\n        const requestContextPromise = this.requestFactory.getTopTokens(_options);\n\n        // build promise chain\n        let middlewarePreObservable = from<RequestContext>(requestContextPromise);\n        for (let middleware of this.configuration.middleware) {\n            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));\n        }\n\n        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).\n            pipe(mergeMap((response: ResponseContext) => {\n                let middlewarePostObservable = of(response);\n                for (let middleware of this.configuration.middleware) {\n                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));\n                }\n                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getTopTokens(rsp)));\n            }));\n    }\n\n    /**\n     * Returns trending and interesting wallets on Ethereum. Useful for powering discovery experiences and providing an on-ramp to exploring creative blockchain data.\n     */\n    public getTopWallets(_options?: Configuration): Observable<Array<Wallet>> {\n        const requestContextPromise = this.requestFactory.getTopWallets(_options);\n\n        // build promise chain\n        let middlewarePreObservable = from<RequestContext>(requestContextPromise);\n        for (let middleware of this.configuration.middleware) {\n            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));\n        }\n\n        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).\n            pipe(mergeMap((response: ResponseContext) => {\n                let middlewarePostObservable = of(response);\n                for (let middleware of this.configuration.middleware) {\n                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));\n                }\n                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getTopWallets(rsp)));\n            }));\n    }\n\n}\n\nimport { DefaultApiRequestFactory, DefaultApiResponseProcessor} from \"../apis/DefaultApi\";\nexport class ObservableDefaultApi {\n    private requestFactory: DefaultApiRequestFactory;\n    private responseProcessor: DefaultApiResponseProcessor;\n    private configuration: Configuration;\n\n    public constructor(\n        configuration: Configuration,\n        requestFactory?: DefaultApiRequestFactory,\n        responseProcessor?: DefaultApiResponseProcessor\n    ) {\n        this.configuration = configuration;\n        this.requestFactory = requestFactory || new DefaultApiRequestFactory(configuration);\n        this.responseProcessor = responseProcessor || new DefaultApiResponseProcessor();\n    }\n\n    /**\n     * Lists all supported blockchains.\n     */\n    public getBlockchains(_options?: Configuration): Observable<Array<BlockchainInfo>> {\n        const requestContextPromise = this.requestFactory.getBlockchains(_options);\n\n        // build promise chain\n        let middlewarePreObservable = from<RequestContext>(requestContextPromise);\n        for (let middleware of this.configuration.middleware) {\n            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));\n        }\n\n        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).\n            pipe(mergeMap((response: ResponseContext) => {\n                let middlewarePostObservable = of(response);\n                for (let middleware of this.configuration.middleware) {\n                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));\n                }\n                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getBlockchains(rsp)));\n            }));\n    }\n\n    /**\n     * Get a collection by its contract address.\n     * @param contractAddress A hex address for a blockchain contract.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     */\n    public getCollection(contractAddress: string, chainID?: string, _options?: Configuration): Observable<Array<Collection>> {\n        const requestContextPromise = this.requestFactory.getCollection(contractAddress, chainID, _options);\n\n        // build promise chain\n        let middlewarePreObservable = from<RequestContext>(requestContextPromise);\n        for (let middleware of this.configuration.middleware) {\n            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));\n        }\n\n        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).\n            pipe(mergeMap((response: ResponseContext) => {\n                let middlewarePostObservable = of(response);\n                for (let middleware of this.configuration.middleware) {\n                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));\n                }\n                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getCollection(rsp)));\n            }));\n    }\n\n    /**\n     * Determine if a wallet has any token from a contract.\n     * @param contractAddress A hex address for a blockchain contract.\n     * @param walletAddress A hex string referencing a public wallet address.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     */\n    public getContractGate(contractAddress: string, walletAddress: string, chainID?: string, _options?: Configuration): Observable<AssetGate> {\n        const requestContextPromise = this.requestFactory.getContractGate(contractAddress, walletAddress, chainID, _options);\n\n        // build promise chain\n        let middlewarePreObservable = from<RequestContext>(requestContextPromise);\n        for (let middleware of this.configuration.middleware) {\n            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));\n        }\n\n        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).\n            pipe(mergeMap((response: ResponseContext) => {\n                let middlewarePostObservable = of(response);\n                for (let middleware of this.configuration.middleware) {\n                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));\n                }\n                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getContractGate(rsp)));\n            }));\n    }\n\n    /**\n     * Get tokens by contract address.\n     * @param contractAddress A hex address for a blockchain contract.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     * @param limit Limits the number of results in a single response.\n     */\n    public getContractTokens(contractAddress: string, chainID?: string, limit?: number, _options?: Configuration): Observable<Array<Token>> {\n        const requestContextPromise = this.requestFactory.getContractTokens(contractAddress, chainID, limit, _options);\n\n        // build promise chain\n        let middlewarePreObservable = from<RequestContext>(requestContextPromise);\n        for (let middleware of this.configuration.middleware) {\n            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));\n        }\n\n        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).\n            pipe(mergeMap((response: ResponseContext) => {\n                let middlewarePostObservable = of(response);\n                for (let middleware of this.configuration.middleware) {\n                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));\n                }\n                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getContractTokens(rsp)));\n            }));\n    }\n\n    /**\n     * Returns tokens from a batch lookup.\n     * @param contractAddresses A comma-separated hex address for a blockchain contract, the order of values should match the order in tokenIdentifiers.\n     * @param tokenIdentifiers A comma-separated token ID, the order of values should match the order in contractAddresses.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     * @param limit Limits the number of results in a single response.\n     */\n    public getContractTokensByContractAndID(contractAddresses: string, tokenIdentifiers: string, chainID?: string, limit?: number, _options?: Configuration): Observable<Array<Token>> {\n        const requestContextPromise = this.requestFactory.getContractTokensByContractAndID(contractAddresses, tokenIdentifiers, chainID, limit, _options);\n\n        // build promise chain\n        let middlewarePreObservable = from<RequestContext>(requestContextPromise);\n        for (let middleware of this.configuration.middleware) {\n            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));\n        }\n\n        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).\n            pipe(mergeMap((response: ResponseContext) => {\n                let middlewarePostObservable = of(response);\n                for (let middleware of this.configuration.middleware) {\n                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));\n                }\n                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getContractTokensByContractAndID(rsp)));\n            }));\n    }\n\n    /**\n     * Get the transaction history for a collection\n     * @param contractAddress A hex address for a blockchain contract.\n     * @param cursor Cursor to support API pagination.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     * @param limit Limits the number of results in a single response.\n     */\n    public getContractTransactionHistory(contractAddress: string, cursor?: string, chainID?: string, limit?: number, _options?: Configuration): Observable<Array<Transaction>> {\n        const requestContextPromise = this.requestFactory.getContractTransactionHistory(contractAddress, cursor, chainID, limit, _options);\n\n        // build promise chain\n        let middlewarePreObservable = from<RequestContext>(requestContextPromise);\n        for (let middleware of this.configuration.middleware) {\n            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));\n        }\n\n        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).\n            pipe(mergeMap((response: ResponseContext) => {\n                let middlewarePostObservable = of(response);\n                for (let middleware of this.configuration.middleware) {\n                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));\n                }\n                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getContractTransactionHistory(rsp)));\n            }));\n    }\n\n    /**\n     * Get search results such as wallets, tokens, and collections by a search query.\n     * @param query A search query that returns matching results\n     * @param cursor Cursor to support API pagination.\n     */\n    public getSearchResults(query: string, cursor?: string, _options?: Configuration): Observable<Array<SearchDocument>> {\n        const requestContextPromise = this.requestFactory.getSearchResults(query, cursor, _options);\n\n        // build promise chain\n        let middlewarePreObservable = from<RequestContext>(requestContextPromise);\n        for (let middleware of this.configuration.middleware) {\n            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));\n        }\n\n        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).\n            pipe(mergeMap((response: ResponseContext) => {\n                let middlewarePostObservable = of(response);\n                for (let middleware of this.configuration.middleware) {\n                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));\n                }\n                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getSearchResults(rsp)));\n            }));\n    }\n\n    /**\n     * Returns a list of tokens sold by a wallet.\n     * @param walletAddress A hex string referencing a public wallet address.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     * @param cursor Cursor to support API pagination.\n     * @param limit Limits the number of results in a single response.\n     */\n    public getSoldTokens(walletAddress: string, chainID?: string, cursor?: string, limit?: number, _options?: Configuration): Observable<Array<Token>> {\n        const requestContextPromise = this.requestFactory.getSoldTokens(walletAddress, chainID, cursor, limit, _options);\n\n        // build promise chain\n        let middlewarePreObservable = from<RequestContext>(requestContextPromise);\n        for (let middleware of this.configuration.middleware) {\n            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));\n        }\n\n        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).\n            pipe(mergeMap((response: ResponseContext) => {\n                let middlewarePostObservable = of(response);\n                for (let middleware of this.configuration.middleware) {\n                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));\n                }\n                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getSoldTokens(rsp)));\n            }));\n    }\n\n    /**\n     * Get autocomplete-style search suggestions for results.\n     * @param query A query or partial query that can be used to retrieve suggested results. For example \\&quot;bored a\\&quot; would return a suggestion for \\&quot;bored ape.\\&quot;\n     */\n    public getSuggestionsResults(query?: string, _options?: Configuration): Observable<Array<AutoSuggestion>> {\n        const requestContextPromise = this.requestFactory.getSuggestionsResults(query, _options);\n\n        // build promise chain\n        let middlewarePreObservable = from<RequestContext>(requestContextPromise);\n        for (let middleware of this.configuration.middleware) {\n            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));\n        }\n\n        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).\n            pipe(mergeMap((response: ResponseContext) => {\n                let middlewarePostObservable = of(response);\n                for (let middleware of this.configuration.middleware) {\n                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));\n                }\n                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getSuggestionsResults(rsp)));\n            }));\n    }\n\n    /**\n     * Get a token by its contract address and token ID.\n     * @param contractAddress A hex address for a blockchain contract.\n     * @param tokenID An arbitrary ID defined by a contract to uniquely identify a cryptographic asset such as an NFT.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     */\n    public getToken(contractAddress: string, tokenID: string, chainID?: string, _options?: Configuration): Observable<Array<Token>> {\n        const requestContextPromise = this.requestFactory.getToken(contractAddress, tokenID, chainID, _options);\n\n        // build promise chain\n        let middlewarePreObservable = from<RequestContext>(requestContextPromise);\n        for (let middleware of this.configuration.middleware) {\n            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));\n        }\n\n        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).\n            pipe(mergeMap((response: ResponseContext) => {\n                let middlewarePostObservable = of(response);\n                for (let middleware of this.configuration.middleware) {\n                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));\n                }\n                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getToken(rsp)));\n            }));\n    }\n\n    /**\n     * Determine if a wallet has a given token from a contract.\n     * @param tokenID An arbitrary ID defined by a contract to uniquely identify a cryptographic asset such as an NFT.\n     * @param contractAddress A hex address for a blockchain contract.\n     * @param walletAddress A hex string referencing a public wallet address.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     */\n    public getTokenGate(tokenID: string, contractAddress: string, walletAddress: string, chainID?: string, _options?: Configuration): Observable<AssetGate> {\n        const requestContextPromise = this.requestFactory.getTokenGate(tokenID, contractAddress, walletAddress, chainID, _options);\n\n        // build promise chain\n        let middlewarePreObservable = from<RequestContext>(requestContextPromise);\n        for (let middleware of this.configuration.middleware) {\n            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));\n        }\n\n        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).\n            pipe(mergeMap((response: ResponseContext) => {\n                let middlewarePostObservable = of(response);\n                for (let middleware of this.configuration.middleware) {\n                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));\n                }\n                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getTokenGate(rsp)));\n            }));\n    }\n\n    /**\n     * Returns a list of transfer transactions on a specified token.\n     * @param contractAddress A hex address for a blockchain contract.\n     * @param tokenID An arbitrary ID defined by a contract to uniquely identify a cryptographic asset such as an NFT.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     * @param limit Limits the number of results in a single response.\n     */\n    public getTokenTransfers(contractAddress: string, tokenID: string, chainID?: string, limit?: number, _options?: Configuration): Observable<TokenEvents> {\n        const requestContextPromise = this.requestFactory.getTokenTransfers(contractAddress, tokenID, chainID, limit, _options);\n\n        // build promise chain\n        let middlewarePreObservable = from<RequestContext>(requestContextPromise);\n        for (let middleware of this.configuration.middleware) {\n            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));\n        }\n\n        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).\n            pipe(mergeMap((response: ResponseContext) => {\n                let middlewarePostObservable = of(response);\n                for (let middleware of this.configuration.middleware) {\n                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));\n                }\n                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getTokenTransfers(rsp)));\n            }));\n    }\n\n    /**\n     * Get tokens by a search query.\n     * @param query A search query that returns matching results\n     * @param cursor Cursor to support API pagination.\n     */\n    public getTokensBySearchQuery(query: string, cursor?: string, _options?: Configuration): Observable<Array<Token>> {\n        const requestContextPromise = this.requestFactory.getTokensBySearchQuery(query, cursor, _options);\n\n        // build promise chain\n        let middlewarePreObservable = from<RequestContext>(requestContextPromise);\n        for (let middleware of this.configuration.middleware) {\n            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));\n        }\n\n        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).\n            pipe(mergeMap((response: ResponseContext) => {\n                let middlewarePostObservable = of(response);\n                for (let middleware of this.configuration.middleware) {\n                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));\n                }\n                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getTokensBySearchQuery(rsp)));\n            }));\n    }\n\n    /**\n     * Get a wallet by a wallet address\n     * @param walletAddress A hex string referencing a public wallet address.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     */\n    public getWallet(walletAddress: string, chainID?: string, _options?: Configuration): Observable<Array<Wallet>> {\n        const requestContextPromise = this.requestFactory.getWallet(walletAddress, chainID, _options);\n\n        // build promise chain\n        let middlewarePreObservable = from<RequestContext>(requestContextPromise);\n        for (let middleware of this.configuration.middleware) {\n            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));\n        }\n\n        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).\n            pipe(mergeMap((response: ResponseContext) => {\n                let middlewarePostObservable = of(response);\n                for (let middleware of this.configuration.middleware) {\n                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));\n                }\n                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getWallet(rsp)));\n            }));\n    }\n\n    /**\n     * Returns a list of balances for tokens this wallet currently owns.\n     * @param walletAddress A hex string referencing a public wallet address.\n     * @param limit Limits the number of results in a single response.\n     */\n    public getWalletBalances(walletAddress: string, limit?: number, _options?: Configuration): Observable<Array<CurrencyInfo>> {\n        const requestContextPromise = this.requestFactory.getWalletBalances(walletAddress, limit, _options);\n\n        // build promise chain\n        let middlewarePreObservable = from<RequestContext>(requestContextPromise);\n        for (let middleware of this.configuration.middleware) {\n            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));\n        }\n\n        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).\n            pipe(mergeMap((response: ResponseContext) => {\n                let middlewarePostObservable = of(response);\n                for (let middleware of this.configuration.middleware) {\n                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));\n                }\n                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getWalletBalances(rsp)));\n            }));\n    }\n\n    /**\n     * Returns a list of tokens minted by a wallet.\n     * @param walletAddress A hex string referencing a public wallet address.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     * @param cursor Cursor to support API pagination.\n     * @param limit Limits the number of results in a single response.\n     */\n    public getWalletMints(walletAddress: string, chainID?: string, cursor?: string, limit?: number, _options?: Configuration): Observable<Array<Token>> {\n        const requestContextPromise = this.requestFactory.getWalletMints(walletAddress, chainID, cursor, limit, _options);\n\n        // build promise chain\n        let middlewarePreObservable = from<RequestContext>(requestContextPromise);\n        for (let middleware of this.configuration.middleware) {\n            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));\n        }\n\n        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).\n            pipe(mergeMap((response: ResponseContext) => {\n                let middlewarePostObservable = of(response);\n                for (let middleware of this.configuration.middleware) {\n                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));\n                }\n                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getWalletMints(rsp)));\n            }));\n    }\n\n    /**\n     * Returns a list of tokens owned by a wallet.\n     * @param walletAddress A hex string referencing a public wallet address.\n     * @param cursor Cursor to support API pagination.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     * @param limit Limits the number of results in a single response.\n     */\n    public getWalletTokens(walletAddress: string, cursor?: string, chainID?: string, limit?: number, _options?: Configuration): Observable<Array<Token>> {\n        const requestContextPromise = this.requestFactory.getWalletTokens(walletAddress, cursor, chainID, limit, _options);\n\n        // build promise chain\n        let middlewarePreObservable = from<RequestContext>(requestContextPromise);\n        for (let middleware of this.configuration.middleware) {\n            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));\n        }\n\n        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).\n            pipe(mergeMap((response: ResponseContext) => {\n                let middlewarePostObservable = of(response);\n                for (let middleware of this.configuration.middleware) {\n                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));\n                }\n                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getWalletTokens(rsp)));\n            }));\n    }\n\n    /**\n     * Returns transactions related to a wallet.\n     * @param walletAddress A hex string referencing a public wallet address.\n     * @param cursor Cursor to support API pagination.\n     * @param limit Limits the number of results in a single response.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     * @param tokenType An indicator that be used to filter to only a subet of tokens, for example only NFTs. To select ERC-20, sidechain and L1 transactions, use the \\&quot;fungible.\\&quot; To select only NFTs or semi-fungible tokens (SFTs), use the respective enum.\n     */\n    public getWalletTransactions(walletAddress: string, cursor?: string, limit?: number, chainID?: string, tokenType?: 'native' | 'fungible' | 'NFT' | 'SFT' | 'unknown', _options?: Configuration): Observable<Array<Transaction>> {\n        const requestContextPromise = this.requestFactory.getWalletTransactions(walletAddress, cursor, limit, chainID, tokenType, _options);\n\n        // build promise chain\n        let middlewarePreObservable = from<RequestContext>(requestContextPromise);\n        for (let middleware of this.configuration.middleware) {\n            middlewarePreObservable = middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => middleware.pre(ctx)));\n        }\n\n        return middlewarePreObservable.pipe(mergeMap((ctx: RequestContext) => this.configuration.httpApi.send(ctx))).\n            pipe(mergeMap((response: ResponseContext) => {\n                let middlewarePostObservable = of(response);\n                for (let middleware of this.configuration.middleware) {\n                    middlewarePostObservable = middlewarePostObservable.pipe(mergeMap((rsp: ResponseContext) => middleware.post(rsp)));\n                }\n                return middlewarePostObservable.pipe(map((rsp: ResponseContext) => this.responseProcessor.getWalletTransactions(rsp)));\n            }));\n    }\n\n}\n","import { ResponseContext, RequestContext, HttpFile } from '../http/http';\nimport * as models from '../models/all';\nimport { Configuration} from '../configuration'\n\nimport { AssetGate } from '../models/AssetGate';\nimport { AutoSuggestion } from '../models/AutoSuggestion';\nimport { BlockchainInfo } from '../models/BlockchainInfo';\nimport { Collection } from '../models/Collection';\nimport { CreditEvent } from '../models/CreditEvent';\nimport { CurrencyInfo } from '../models/CurrencyInfo';\nimport { ENS } from '../models/ENS';\nimport { ErrorMessage } from '../models/ErrorMessage';\nimport { ExchangeEvent } from '../models/ExchangeEvent';\nimport { Media } from '../models/Media';\nimport { MediaPreview } from '../models/MediaPreview';\nimport { MediaVersion } from '../models/MediaVersion';\nimport { NonFungibleToken } from '../models/NonFungibleToken';\nimport { OpenSeaContract } from '../models/OpenSeaContract';\nimport { OwnedCollection } from '../models/OwnedCollection';\nimport { SearchDocument } from '../models/SearchDocument';\nimport { SocialMedia } from '../models/SocialMedia';\nimport { Token } from '../models/Token';\nimport { TokenAttribute } from '../models/TokenAttribute';\nimport { TokenEvents } from '../models/TokenEvents';\nimport { Transaction } from '../models/Transaction';\nimport { TransactionLogLine } from '../models/TransactionLogLine';\nimport { URL } from '../models/URL';\nimport { Wallet } from '../models/Wallet';\nimport { ObservableAlphaApi } from './ObservableAPI';\n\nimport { AlphaApiRequestFactory, AlphaApiResponseProcessor} from \"../apis/AlphaApi\";\nexport class PromiseAlphaApi {\n    private api: ObservableAlphaApi\n\n    public constructor(\n        configuration: Configuration,\n        requestFactory?: AlphaApiRequestFactory,\n        responseProcessor?: AlphaApiResponseProcessor\n    ) {\n        this.api = new ObservableAlphaApi(configuration, requestFactory, responseProcessor);\n    }\n\n    /**\n     * Returns trending and interesting collections on Ethereum. Useful for powering discovery experiences and providing an on-ramp to exploring creative blockchain data.\n     */\n    public getTopCollections(_options?: Configuration): Promise<Array<Collection>> {\n        const result = this.api.getTopCollections(_options);\n        return result.toPromise();\n    }\n\n    /**\n     * Returns trending and interesting NFTs and SFTs on Ethereum. Useful for powering discovery experiences and providing an on-ramp to exploring creative blockchain data.\n     */\n    public getTopTokens(_options?: Configuration): Promise<Array<Token>> {\n        const result = this.api.getTopTokens(_options);\n        return result.toPromise();\n    }\n\n    /**\n     * Returns trending and interesting wallets on Ethereum. Useful for powering discovery experiences and providing an on-ramp to exploring creative blockchain data.\n     */\n    public getTopWallets(_options?: Configuration): Promise<Array<Wallet>> {\n        const result = this.api.getTopWallets(_options);\n        return result.toPromise();\n    }\n\n\n}\n\n\n\nimport { ObservableDefaultApi } from './ObservableAPI';\n\nimport { DefaultApiRequestFactory, DefaultApiResponseProcessor} from \"../apis/DefaultApi\";\nexport class PromiseDefaultApi {\n    private api: ObservableDefaultApi\n\n    public constructor(\n        configuration: Configuration,\n        requestFactory?: DefaultApiRequestFactory,\n        responseProcessor?: DefaultApiResponseProcessor\n    ) {\n        this.api = new ObservableDefaultApi(configuration, requestFactory, responseProcessor);\n    }\n\n    /**\n     * Lists all supported blockchains.\n     */\n    public getBlockchains(_options?: Configuration): Promise<Array<BlockchainInfo>> {\n        const result = this.api.getBlockchains(_options);\n        return result.toPromise();\n    }\n\n    /**\n     * Get a collection by its contract address.\n     * @param contractAddress A hex address for a blockchain contract.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     */\n    public getCollection(contractAddress: string, chainID?: string, _options?: Configuration): Promise<Array<Collection>> {\n        const result = this.api.getCollection(contractAddress, chainID, _options);\n        return result.toPromise();\n    }\n\n    /**\n     * Determine if a wallet has any token from a contract.\n     * @param contractAddress A hex address for a blockchain contract.\n     * @param walletAddress A hex string referencing a public wallet address.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     */\n    public getContractGate(contractAddress: string, walletAddress: string, chainID?: string, _options?: Configuration): Promise<AssetGate> {\n        const result = this.api.getContractGate(contractAddress, walletAddress, chainID, _options);\n        return result.toPromise();\n    }\n\n    /**\n     * Get tokens by contract address.\n     * @param contractAddress A hex address for a blockchain contract.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     * @param limit Limits the number of results in a single response.\n     */\n    public getContractTokens(contractAddress: string, chainID?: string, limit?: number, _options?: Configuration): Promise<Array<Token>> {\n        const result = this.api.getContractTokens(contractAddress, chainID, limit, _options);\n        return result.toPromise();\n    }\n\n    /**\n     * Returns tokens from a batch lookup.\n     * @param contractAddresses A comma-separated hex address for a blockchain contract, the order of values should match the order in tokenIdentifiers.\n     * @param tokenIdentifiers A comma-separated token ID, the order of values should match the order in contractAddresses.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     * @param limit Limits the number of results in a single response.\n     */\n    public getContractTokensByContractAndID(contractAddresses: string, tokenIdentifiers: string, chainID?: string, limit?: number, _options?: Configuration): Promise<Array<Token>> {\n        const result = this.api.getContractTokensByContractAndID(contractAddresses, tokenIdentifiers, chainID, limit, _options);\n        return result.toPromise();\n    }\n\n    /**\n     * Get the transaction history for a collection\n     * @param contractAddress A hex address for a blockchain contract.\n     * @param cursor Cursor to support API pagination.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     * @param limit Limits the number of results in a single response.\n     */\n    public getContractTransactionHistory(contractAddress: string, cursor?: string, chainID?: string, limit?: number, _options?: Configuration): Promise<Array<Transaction>> {\n        const result = this.api.getContractTransactionHistory(contractAddress, cursor, chainID, limit, _options);\n        return result.toPromise();\n    }\n\n    /**\n     * Get search results such as wallets, tokens, and collections by a search query.\n     * @param query A search query that returns matching results\n     * @param cursor Cursor to support API pagination.\n     */\n    public getSearchResults(query: string, cursor?: string, _options?: Configuration): Promise<Array<SearchDocument>> {\n        const result = this.api.getSearchResults(query, cursor, _options);\n        return result.toPromise();\n    }\n\n    /**\n     * Returns a list of tokens sold by a wallet.\n     * @param walletAddress A hex string referencing a public wallet address.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     * @param cursor Cursor to support API pagination.\n     * @param limit Limits the number of results in a single response.\n     */\n    public getSoldTokens(walletAddress: string, chainID?: string, cursor?: string, limit?: number, _options?: Configuration): Promise<Array<Token>> {\n        const result = this.api.getSoldTokens(walletAddress, chainID, cursor, limit, _options);\n        return result.toPromise();\n    }\n\n    /**\n     * Get autocomplete-style search suggestions for results.\n     * @param query A query or partial query that can be used to retrieve suggested results. For example \\&quot;bored a\\&quot; would return a suggestion for \\&quot;bored ape.\\&quot;\n     */\n    public getSuggestionsResults(query?: string, _options?: Configuration): Promise<Array<AutoSuggestion>> {\n        const result = this.api.getSuggestionsResults(query, _options);\n        return result.toPromise();\n    }\n\n    /**\n     * Get a token by its contract address and token ID.\n     * @param contractAddress A hex address for a blockchain contract.\n     * @param tokenID An arbitrary ID defined by a contract to uniquely identify a cryptographic asset such as an NFT.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     */\n    public getToken(contractAddress: string, tokenID: string, chainID?: string, _options?: Configuration): Promise<Array<Token>> {\n        const result = this.api.getToken(contractAddress, tokenID, chainID, _options);\n        return result.toPromise();\n    }\n\n    /**\n     * Determine if a wallet has a given token from a contract.\n     * @param tokenID An arbitrary ID defined by a contract to uniquely identify a cryptographic asset such as an NFT.\n     * @param contractAddress A hex address for a blockchain contract.\n     * @param walletAddress A hex string referencing a public wallet address.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     */\n    public getTokenGate(tokenID: string, contractAddress: string, walletAddress: string, chainID?: string, _options?: Configuration): Promise<AssetGate> {\n        const result = this.api.getTokenGate(tokenID, contractAddress, walletAddress, chainID, _options);\n        return result.toPromise();\n    }\n\n    /**\n     * Returns a list of transfer transactions on a specified token.\n     * @param contractAddress A hex address for a blockchain contract.\n     * @param tokenID An arbitrary ID defined by a contract to uniquely identify a cryptographic asset such as an NFT.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     * @param limit Limits the number of results in a single response.\n     */\n    public getTokenTransfers(contractAddress: string, tokenID: string, chainID?: string, limit?: number, _options?: Configuration): Promise<TokenEvents> {\n        const result = this.api.getTokenTransfers(contractAddress, tokenID, chainID, limit, _options);\n        return result.toPromise();\n    }\n\n    /**\n     * Get tokens by a search query.\n     * @param query A search query that returns matching results\n     * @param cursor Cursor to support API pagination.\n     */\n    public getTokensBySearchQuery(query: string, cursor?: string, _options?: Configuration): Promise<Array<Token>> {\n        const result = this.api.getTokensBySearchQuery(query, cursor, _options);\n        return result.toPromise();\n    }\n\n    /**\n     * Get a wallet by a wallet address\n     * @param walletAddress A hex string referencing a public wallet address.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     */\n    public getWallet(walletAddress: string, chainID?: string, _options?: Configuration): Promise<Array<Wallet>> {\n        const result = this.api.getWallet(walletAddress, chainID, _options);\n        return result.toPromise();\n    }\n\n    /**\n     * Returns a list of balances for tokens this wallet currently owns.\n     * @param walletAddress A hex string referencing a public wallet address.\n     * @param limit Limits the number of results in a single response.\n     */\n    public getWalletBalances(walletAddress: string, limit?: number, _options?: Configuration): Promise<Array<CurrencyInfo>> {\n        const result = this.api.getWalletBalances(walletAddress, limit, _options);\n        return result.toPromise();\n    }\n\n    /**\n     * Returns a list of tokens minted by a wallet.\n     * @param walletAddress A hex string referencing a public wallet address.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     * @param cursor Cursor to support API pagination.\n     * @param limit Limits the number of results in a single response.\n     */\n    public getWalletMints(walletAddress: string, chainID?: string, cursor?: string, limit?: number, _options?: Configuration): Promise<Array<Token>> {\n        const result = this.api.getWalletMints(walletAddress, chainID, cursor, limit, _options);\n        return result.toPromise();\n    }\n\n    /**\n     * Returns a list of tokens owned by a wallet.\n     * @param walletAddress A hex string referencing a public wallet address.\n     * @param cursor Cursor to support API pagination.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     * @param limit Limits the number of results in a single response.\n     */\n    public getWalletTokens(walletAddress: string, cursor?: string, chainID?: string, limit?: number, _options?: Configuration): Promise<Array<Token>> {\n        const result = this.api.getWalletTokens(walletAddress, cursor, chainID, limit, _options);\n        return result.toPromise();\n    }\n\n    /**\n     * Returns transactions related to a wallet.\n     * @param walletAddress A hex string referencing a public wallet address.\n     * @param cursor Cursor to support API pagination.\n     * @param limit Limits the number of results in a single response.\n     * @param chainID An identifier to restrict results to a given blockchain. Provide either a keyword such as \\&quot;ethereum\\&quot; or \\&quot;polygon\\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.\n     * @param tokenType An indicator that be used to filter to only a subet of tokens, for example only NFTs. To select ERC-20, sidechain and L1 transactions, use the \\&quot;fungible.\\&quot; To select only NFTs or semi-fungible tokens (SFTs), use the respective enum.\n     */\n    public getWalletTransactions(walletAddress: string, cursor?: string, limit?: number, chainID?: string, tokenType?: 'native' | 'fungible' | 'NFT' | 'SFT' | 'unknown', _options?: Configuration): Promise<Array<Transaction>> {\n        const result = this.api.getWalletTransactions(walletAddress, cursor, limit, chainID, tokenType, _options);\n        return result.toPromise();\n    }\n\n\n}\n\n\n\n","export * from \"./http/http\";\nexport * from \"./auth/auth\";\nexport * from \"./models/all\";\nexport { createConfiguration } from \"./configuration\"\n//export { Configuration } from \"./configuration\"\nexport * from \"./apis/exception\";\nexport * from \"./servers\";\nexport { RequiredError } from \"./apis/baseapi\";\n\n//export { PromiseMiddleware as Middleware } from './middleware';\nexport { PromiseAlphaApi as AlphaApi,  PromiseDefaultApi as DefaultApi } from './types/PromiseAPI';\n\n"],"names":[],"version":3,"file":"index.d.ts.map"}