/**
 * n.xyz REST API
 * REST API for blockchain data.
 *
 * The version of the OpenAPI document: 0.17.1
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
export const BASE_PATH: string;
export interface ConfigurationParameters {
    basePath?: string;
    fetchApi?: FetchAPI;
    middleware?: Middleware[];
    queryParamsStringify?: (params: HTTPQuery) => string;
    username?: string;
    password?: string;
    apiKey?: string | ((name: string) => string);
    accessToken?: string | Promise<string> | ((name?: string, scopes?: string[]) => string | Promise<string>);
    headers?: HTTPHeaders;
    credentials?: RequestCredentials;
}
export class Configuration {
    constructor(configuration?: ConfigurationParameters);
    set config(configuration: Configuration);
    get basePath(): string;
    get fetchApi(): FetchAPI | undefined;
    get middleware(): Middleware[];
    get queryParamsStringify(): (params: HTTPQuery) => string;
    get username(): string | undefined;
    get password(): string | undefined;
    get apiKey(): ((name: string) => string) | undefined;
    get accessToken(): ((name?: string, scopes?: string[]) => string | Promise<string>) | undefined;
    get headers(): HTTPHeaders | undefined;
    get credentials(): RequestCredentials | undefined;
}
export const DefaultConfig: Configuration;
/**
 * This is the base class for all generated API classes.
 */
export class BaseAPI {
    protected configuration: Configuration;
    constructor(configuration?: Configuration);
    withMiddleware<T extends BaseAPI>(this: T, ...middlewares: Middleware[]): T;
    withPreMiddleware<T extends BaseAPI>(this: T, ...preMiddlewares: Array<Middleware['pre']>): T;
    withPostMiddleware<T extends BaseAPI>(this: T, ...postMiddlewares: Array<Middleware['post']>): T;
    protected request(context: RequestOpts, initOverrides?: RequestInit | InitOverrideFunction): Promise<Response>;
}
export class ResponseError extends Error {
    response: Response;
    name: "ResponseError";
    constructor(response: Response, msg?: string);
}
export class FetchError extends Error {
    cause: unknown;
    name: "FetchError";
    constructor(cause: unknown, msg?: string);
}
export class RequiredError extends Error {
    field: string;
    name: "RequiredError";
    constructor(field: string, msg?: string);
}
export const COLLECTION_FORMATS: {
    csv: string;
    ssv: string;
    tsv: string;
    pipes: string;
};
export type FetchAPI = WindowOrWorkerGlobalScope['fetch'];
export type Json = any;
export type HTTPMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE' | 'OPTIONS' | 'HEAD';
export type HTTPHeaders = {
    [key: string]: string;
};
export type HTTPQuery = {
    [key: string]: string | number | null | boolean | Array<string | number | null | boolean> | Set<string | number | null | boolean> | HTTPQuery;
};
export type HTTPBody = Json | FormData | URLSearchParams;
export type HTTPRequestInit = {
    headers?: HTTPHeaders;
    method: HTTPMethod;
    credentials?: RequestCredentials;
    body?: HTTPBody;
};
export type ModelPropertyNaming = 'camelCase' | 'snake_case' | 'PascalCase' | 'original';
export type InitOverrideFunction = (requestContext: {
    init: HTTPRequestInit;
    context: RequestOpts;
}) => Promise<RequestInit>;
export interface FetchParams {
    url: string;
    init: RequestInit;
}
export interface RequestOpts {
    path: string;
    method: HTTPMethod;
    headers: HTTPHeaders;
    query?: HTTPQuery;
    body?: HTTPBody;
}
export function exists(json: any, key: string): boolean;
export function querystring(params: HTTPQuery, prefix?: string): string;
export function mapValues(data: any, fn: (item: any) => any): {};
export function canConsumeForm(consumes: Consume[]): boolean;
export interface Consume {
    contentType: string;
}
export interface RequestContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
}
export interface ResponseContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
    response: Response;
}
export interface ErrorContext {
    fetch: FetchAPI;
    url: string;
    init: RequestInit;
    error: unknown;
    response?: Response;
}
export interface Middleware {
    pre?(context: RequestContext): Promise<FetchParams | void>;
    post?(context: ResponseContext): Promise<Response | void>;
    onError?(context: ErrorContext): Promise<Response | void>;
}
export interface ApiResponse<T> {
    raw: Response;
    value(): Promise<T>;
}
export interface ResponseTransformer<T> {
    (json: any): T;
}
export class JSONApiResponse<T> {
    raw: Response;
    constructor(raw: Response, transformer?: ResponseTransformer<T>);
    value(): Promise<T>;
}
export class VoidApiResponse {
    raw: Response;
    constructor(raw: Response);
    value(): Promise<void>;
}
export class BlobApiResponse {
    raw: Response;
    constructor(raw: Response);
    value(): Promise<Blob>;
}
export class TextApiResponse {
    raw: Response;
    constructor(raw: Response);
    value(): Promise<string>;
}
/**
 *
 * @export
 * @interface BlockchainInfo
 */
export interface BlockchainInfo {
    /**
     * The name of a given chain. This is often a canonical name since a protocol may have multiple chains.
     * @type {string}
     * @memberof BlockchainInfo
     */
    name?: string;
    /**
     * The short-hand name for a given chain. Multiple chains (e.g. mainnet and a testnet) may have the same name.
     * @type {string}
     * @memberof BlockchainInfo
     */
    shortName?: string;
    /**
     * A CAIP-2 compliant chain ID. This ID is designed to provide a unique identifier for a given chain.
     * @type {string}
     * @memberof BlockchainInfo
     */
    chainID?: string;
    /**
     * An ID used for a chain in a given ecosystem. This ID is not canonical and may collide with other chains. Do not use this value as a unique identifier.
     * @type {string}
     * @memberof BlockchainInfo
     */
    shortChainID?: string;
}
/**
 * Check if a given object implements the BlockchainInfo interface.
 */
export function instanceOfBlockchainInfo(value: object): boolean;
export function BlockchainInfoFromJSON(json: any): BlockchainInfo;
export function BlockchainInfoFromJSONTyped(json: any, ignoreDiscriminator: boolean): BlockchainInfo;
export function BlockchainInfoToJSON(value?: BlockchainInfo | null): any;
/**
 *
 * @export
 * @interface CurrencyInfo
 */
export interface CurrencyInfo {
    /**
     * Transaction value as a string-encoded bigint in the base unit for a given blockchain (e.g. wei for Ethereum) or fiat currency (e.g. US Dollars).
     * @type {string}
     * @memberof CurrencyInfo
     */
    value?: string;
    /**
     * Transaction value as a float representing the amount of tokens, e.g. 0.89 would be 89% of a token.
     * @type {number}
     * @memberof CurrencyInfo
     */
    tokenValue?: number;
    /**
     * The total value of this token in fiat currency.
     * @type {Array<CurrencyInfo>}
     * @memberof CurrencyInfo
     */
    fiat?: Array<CurrencyInfo>;
    /**
     * A formatted, human-friendly representation of the transaction value, e.g. the value in Ether, possibly with localized thousands separator and radix character.
     * @type {string}
     * @memberof CurrencyInfo
     */
    pretty?: string;
    /**
     * The base value for a given token. For Ethereum this would be 18. This would yield an equation such as 890000000000000000wei / 10^18 = 0.89 ETH.
     * @type {number}
     * @memberof CurrencyInfo
     */
    decimals?: number;
    /**
     *
     * @type {string}
     * @memberof CurrencyInfo
     */
    symbol?: string;
    /**
     *
     * @type {string}
     * @memberof CurrencyInfo
     */
    contractAddress?: string;
    /**
     *
     * @type {string}
     * @memberof CurrencyInfo
     */
    name?: string;
}
/**
 * Check if a given object implements the CurrencyInfo interface.
 */
export function instanceOfCurrencyInfo(value: object): boolean;
export function CurrencyInfoFromJSON(json: any): CurrencyInfo;
export function CurrencyInfoFromJSONTyped(json: any, ignoreDiscriminator: boolean): CurrencyInfo;
export function CurrencyInfoToJSON(value?: CurrencyInfo | null): any;
/**
 *
 * @export
 * @interface MediaVersion
 */
export interface MediaVersion {
    /**
     *
     * @type {string}
     * @memberof MediaVersion
     */
    kind?: MediaVersionKindEnum;
    /**
     *
     * @type {string}
     * @memberof MediaVersion
     */
    format?: string;
    /**
     *
     * @type {number}
     * @memberof MediaVersion
     */
    width?: number;
    /**
     *
     * @type {number}
     * @memberof MediaVersion
     */
    height?: number;
    /**
     *
     * @type {number}
     * @memberof MediaVersion
     */
    numBytes?: number;
    /**
     * If a video, length of video in ISO 8601 duration format.
     * @type {string}
     * @memberof MediaVersion
     */
    duration?: string;
}
/**
 * @export
 */
export const MediaVersionKindEnum: {
    readonly Video: "video";
    readonly Image: "image";
    readonly Raw: "raw";
    readonly Audio: "audio";
};
export type MediaVersionKindEnum = (typeof MediaVersionKindEnum)[keyof typeof MediaVersionKindEnum];
/**
 * Check if a given object implements the MediaVersion interface.
 */
export function instanceOfMediaVersion(value: object): boolean;
export function MediaVersionFromJSON(json: any): MediaVersion;
export function MediaVersionFromJSONTyped(json: any, ignoreDiscriminator: boolean): MediaVersion;
export function MediaVersionToJSON(value?: MediaVersion | null): any;
/**
 *
 * @export
 * @interface Media
 */
export interface Media {
    /**
     *
     * @type {string}
     * @memberof Media
     */
    key: string;
    /**
     * URI for the image asset.
     * @type {string}
     * @memberof Media
     */
    uRI?: string;
    /**
     *
     * @type {Array<MediaVersion>}
     * @memberof Media
     */
    version?: Array<MediaVersion>;
}
/**
 * Check if a given object implements the Media interface.
 */
export function instanceOfMedia(value: object): boolean;
export function MediaFromJSON(json: any): Media;
export function MediaFromJSONTyped(json: any, ignoreDiscriminator: boolean): Media;
export function MediaToJSON(value?: Media | null): any;
/**
 *
 * @export
 * @interface SocialMedia
 */
export interface SocialMedia {
    /**
     *
     * @type {string}
     * @memberof SocialMedia
     */
    network?: string;
    /**
     *
     * @type {string}
     * @memberof SocialMedia
     */
    username?: string;
}
/**
 * Check if a given object implements the SocialMedia interface.
 */
export function instanceOfSocialMedia(value: object): boolean;
export function SocialMediaFromJSON(json: any): SocialMedia;
export function SocialMediaFromJSONTyped(json: any, ignoreDiscriminator: boolean): SocialMedia;
export function SocialMediaToJSON(value?: SocialMedia | null): any;
/**
 *
 * @export
 * @interface URL
 */
export interface URL {
    /**
     * Human-readable name of the site.
     * @type {string}
     * @memberof URL
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof URL
     */
    url?: string;
}
/**
 * Check if a given object implements the URL interface.
 */
export function instanceOfURL(value: object): boolean;
export function URLFromJSON(json: any): URL;
export function URLFromJSONTyped(json: any, ignoreDiscriminator: boolean): URL;
export function URLToJSON(value?: URL | null): any;
/**
 *
 * @export
 * @interface Collection
 */
export interface Collection {
    /**
     *
     * @type {BlockchainInfo}
     * @memberof Collection
     */
    blockchain: BlockchainInfo;
    /**
     * Address of the contract that minted this NFT.
     * @type {string}
     * @memberof Collection
     */
    contractAddress: string;
    /**
     *
     * @type {string}
     * @memberof Collection
     */
    symbol?: string;
    /**
     *
     * @type {string}
     * @memberof Collection
     */
    slug?: string;
    /**
     *
     * @type {string}
     * @memberof Collection
     */
    name?: string;
    /**
     *
     * @type {string}
     * @memberof Collection
     */
    description?: string;
    /**
     *
     * @type {string}
     * @memberof Collection
     */
    shortDescription?: string;
    /**
     * Timestamp of creation of this contract in RFC 3339.
     * @type {Date}
     * @memberof Collection
     */
    createdDate?: Date | null;
    /**
     *
     * @type {CurrencyInfo}
     * @memberof Collection
     */
    floorPrice?: CurrencyInfo;
    /**
     *
     * @type {Media}
     * @memberof Collection
     */
    bannerImage?: Media;
    /**
     *
     * @type {Media}
     * @memberof Collection
     */
    featuredImage?: Media;
    /**
     *
     * @type {Array<URL>}
     * @memberof Collection
     */
    urls?: Array<URL>;
    /**
     *
     * @type {Array<SocialMedia>}
     * @memberof Collection
     */
    socialMedia?: Array<SocialMedia>;
}
/**
 * Check if a given object implements the Collection interface.
 */
export function instanceOfCollection(value: object): boolean;
export function CollectionFromJSON(json: any): Collection;
export function CollectionFromJSONTyped(json: any, ignoreDiscriminator: boolean): Collection;
export function CollectionToJSON(value?: Collection | null): any;
/**
 *
 * @export
 * @interface ENS
 */
export interface ENS {
    /**
     * The ENS or domain name.
     * @type {string}
     * @memberof ENS
     */
    name?: string;
    /**
     * The address the ENS record points to.
     * @type {string}
     * @memberof ENS
     */
    pointsTo?: string;
    /**
     * Date the ENS registration expires.
     * @type {Date}
     * @memberof ENS
     */
    expires?: Date | null;
    /**
     * A wallet address can have multiple ENS records. The primary ENS name represents a "cross-platform web3 username and profile." A wallet address can only have one primary name, and it can change at any time.
     * @type {boolean}
     * @memberof ENS
     */
    isPrimary?: boolean;
}
/**
 * Check if a given object implements the ENS interface.
 */
export function instanceOfENS(value: object): boolean;
export function ENSFromJSON(json: any): ENS;
export function ENSFromJSONTyped(json: any, ignoreDiscriminator: boolean): ENS;
export function ENSToJSON(value?: ENS | null): any;
/**
 *
 * @export
 * @interface ErrorMessage
 */
export interface ErrorMessage {
    /**
     *
     * @type {string}
     * @memberof ErrorMessage
     */
    error: string;
}
/**
 * Check if a given object implements the ErrorMessage interface.
 */
export function instanceOfErrorMessage(value: object): boolean;
export function ErrorMessageFromJSON(json: any): ErrorMessage;
export function ErrorMessageFromJSONTyped(json: any, ignoreDiscriminator: boolean): ErrorMessage;
export function ErrorMessageToJSON(value?: ErrorMessage | null): any;
/**
 *
 * @export
 * @interface MediaPreview
 */
export interface MediaPreview {
    /**
     * URI for the image asset.
     * @type {string}
     * @memberof MediaPreview
     */
    uRI?: string;
    /**
     *
     * @type {string}
     * @memberof MediaPreview
     */
    kind?: MediaPreviewKindEnum;
    /**
     *
     * @type {string}
     * @memberof MediaPreview
     */
    format?: string;
    /**
     * The image's approximate height in pixels.
     * @type {number}
     * @memberof MediaPreview
     */
    height?: number;
    /**
     * The image's approximate width in pixels.
     * @type {number}
     * @memberof MediaPreview
     */
    width?: number;
    /**
     * If a video, length of video in ISO 8601 duration format.
     * @type {string}
     * @memberof MediaPreview
     */
    duration?: string;
}
/**
 * @export
 */
export const MediaPreviewKindEnum: {
    readonly Video: "video";
    readonly Image: "image";
    readonly Raw: "raw";
    readonly Audio: "audio";
};
export type MediaPreviewKindEnum = (typeof MediaPreviewKindEnum)[keyof typeof MediaPreviewKindEnum];
/**
 * Check if a given object implements the MediaPreview interface.
 */
export function instanceOfMediaPreview(value: object): boolean;
export function MediaPreviewFromJSON(json: any): MediaPreview;
export function MediaPreviewFromJSONTyped(json: any, ignoreDiscriminator: boolean): MediaPreview;
export function MediaPreviewToJSON(value?: MediaPreview | null): any;
/**
 *
 * @export
 * @interface TokenAttribute
 */
export interface TokenAttribute {
    /**
     * The key or kind of trait.
     * @type {string}
     * @memberof TokenAttribute
     */
    traitType?: string;
    /**
     * A distinct attribute belonging to a particular type of trait.
     * @type {string}
     * @memberof TokenAttribute
     */
    value?: string;
}
/**
 * Check if a given object implements the TokenAttribute interface.
 */
export function instanceOfTokenAttribute(value: object): boolean;
export function TokenAttributeFromJSON(json: any): TokenAttribute;
export function TokenAttributeFromJSONTyped(json: any, ignoreDiscriminator: boolean): TokenAttribute;
export function TokenAttributeToJSON(value?: TokenAttribute | null): any;
/**
 *
 * @export
 * @interface TransactionLogLine
 */
export interface TransactionLogLine {
    /**
     * When the value is true, it indicates that a token has been burned, and this transaction corresponds to the burn.
     * @type {boolean}
     * @memberof TransactionLogLine
     */
    burned?: boolean | null;
    /**
     * When the value is true, it indicates this is the transaction representing a token minting.
     * @type {boolean}
     * @memberof TransactionLogLine
     */
    mint?: boolean | null;
    /**
     * Index of the log in the transaction.
     * @type {number}
     * @memberof TransactionLogLine
     */
    logIndex?: number;
    /**
     *
     * @type {string}
     * @memberof TransactionLogLine
     */
    fromAddress?: string;
    /**
     *
     * @type {string}
     * @memberof TransactionLogLine
     */
    toAddress?: string;
    /**
     *
     * @type {CurrencyInfo}
     * @memberof TransactionLogLine
     */
    price?: CurrencyInfo;
}
/**
 * Check if a given object implements the TransactionLogLine interface.
 */
export function instanceOfTransactionLogLine(value: object): boolean;
export function TransactionLogLineFromJSON(json: any): TransactionLogLine;
export function TransactionLogLineFromJSONTyped(json: any, ignoreDiscriminator: boolean): TransactionLogLine;
export function TransactionLogLineToJSON(value?: TransactionLogLine | null): any;
/**
 *
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * Block number of the transaction.
     * @type {number}
     * @memberof Transaction
     */
    blockNumber?: number;
    /**
     * Index of the transaction in the block.
     * @type {number}
     * @memberof Transaction
     */
    transactionIndex?: number;
    /**
     *
     * @type {CurrencyInfo}
     * @memberof Transaction
     */
    gasFee?: CurrencyInfo;
    /**
     * Timestamp of the transaction in RFC 3339.
     * @type {Date}
     * @memberof Transaction
     */
    timestamp?: Date | null;
    /**
     * Log lines related to the transaction.
     * @type {Array<TransactionLogLine>}
     * @memberof Transaction
     */
    logLine?: Array<TransactionLogLine>;
}
/**
 * Check if a given object implements the Transaction interface.
 */
export function instanceOfTransaction(value: object): boolean;
export function TransactionFromJSON(json: any): Transaction;
export function TransactionFromJSONTyped(json: any, ignoreDiscriminator: boolean): Transaction;
export function TransactionToJSON(value?: Transaction | null): any;
/**
 *
 * @export
 * @interface OpenSeaContract
 */
export interface OpenSeaContract {
    /**
     * The type of contract.
     * @type {string}
     * @memberof OpenSeaContract
     */
    assetContractType?: OpenSeaContractAssetContractTypeEnum;
    /**
     * The NFT Version
     * @type {string}
     * @memberof OpenSeaContract
     */
    nftVersion?: string;
    /**
     * The OpenSea Version
     * @type {string}
     * @memberof OpenSeaContract
     */
    openSeaVersion?: string;
    /**
     *
     * @type {boolean}
     * @memberof OpenSeaContract
     */
    defaultToFiat?: boolean;
    /**
     * Total fee levied on buyers by this contract, in basis points
     * @type {number}
     * @memberof OpenSeaContract
     */
    buyerFeeBasisPoints?: number;
    /**
     * Total fee levied on sellers by this contract, in basis points
     * @type {number}
     * @memberof OpenSeaContract
     */
    sellerFeeBasisPoints?: number;
}
/**
 * @export
 */
export const OpenSeaContractAssetContractTypeEnum: {
    readonly Nft: "NFT";
    readonly Sft: "SFT";
    readonly Unknown: "unknown";
};
export type OpenSeaContractAssetContractTypeEnum = (typeof OpenSeaContractAssetContractTypeEnum)[keyof typeof OpenSeaContractAssetContractTypeEnum];
/**
 * Check if a given object implements the OpenSeaContract interface.
 */
export function instanceOfOpenSeaContract(value: object): boolean;
export function OpenSeaContractFromJSON(json: any): OpenSeaContract;
export function OpenSeaContractFromJSONTyped(json: any, ignoreDiscriminator: boolean): OpenSeaContract;
export function OpenSeaContractToJSON(value?: OpenSeaContract | null): any;
/**
 *
 * @export
 * @interface Token
 */
export interface Token {
    /**
     *
     * @type {BlockchainInfo}
     * @memberof Token
     */
    blockchain: BlockchainInfo;
    /**
     * Address of the contract that minted this NFT.
     * @type {string}
     * @memberof Token
     */
    contractAddress: string;
    /**
     *
     * @type {string}
     * @memberof Token
     */
    tokenStandard?: string;
    /**
     *
     * @type {string}
     * @memberof Token
     */
    symbol?: string;
    /**
     *
     * @type {NonFungibleToken}
     * @memberof Token
     */
    nft?: NonFungibleToken;
    /**
     *
     * @type {OpenSeaContract}
     * @memberof Token
     */
    openSeaContract?: OpenSeaContract;
}
/**
 * Check if a given object implements the Token interface.
 */
export function instanceOfToken(value: object): boolean;
export function TokenFromJSON(json: any): Token;
export function TokenFromJSONTyped(json: any, ignoreDiscriminator: boolean): Token;
export function TokenToJSON(value?: Token | null): any;
/**
 *
 * @export
 * @interface OwnedCollection
 */
export interface OwnedCollection {
    /**
     * A sample of the tokens owned by this wallet.
     * @type {Array<Token>}
     * @memberof OwnedCollection
     */
    tokens?: Array<Token>;
    /**
     *
     * @type {Collection}
     * @memberof OwnedCollection
     */
    collection?: Collection;
    /**
     *
     * @type {CurrencyInfo}
     * @memberof OwnedCollection
     */
    totalSpent?: CurrencyInfo;
}
/**
 * Check if a given object implements the OwnedCollection interface.
 */
export function instanceOfOwnedCollection(value: object): boolean;
export function OwnedCollectionFromJSON(json: any): OwnedCollection;
export function OwnedCollectionFromJSONTyped(json: any, ignoreDiscriminator: boolean): OwnedCollection;
export function OwnedCollectionToJSON(value?: OwnedCollection | null): any;
/**
 *
 * @export
 * @interface Wallet
 */
export interface Wallet {
    /**
     * The total balance in a fiat currency (e.g. USD) for the wallet.
     * @type {Array<CurrencyInfo>}
     * @memberof Wallet
     */
    totalBalance?: Array<CurrencyInfo>;
    /**
     * The balance of fungible tokens from smart contracts or blockchains. Certain non-standard ERC-20 tokens (e.g. stETH) may occasionally have stale balances, for example interest payments can be slow to update.
     * @type {Array<CurrencyInfo>}
     * @memberof Wallet
     */
    balances?: Array<CurrencyInfo>;
    /**
     *
     * @type {string}
     * @memberof Wallet
     */
    address: string;
    /**
     *
     * @type {Array<ENS>}
     * @memberof Wallet
     */
    ens?: Array<ENS>;
    /**
     *
     * @type {Array<SocialMedia>}
     * @memberof Wallet
     */
    socialMedia?: Array<SocialMedia>;
    /**
     * A sample of the most recently transferred tokens owned by this wallet.
     * @type {Array<Token>}
     * @memberof Wallet
     */
    recentTokens?: Array<Token>;
    /**
     * A sample of the most expensive tokens owned by this wallet.
     * @type {Array<Token>}
     * @memberof Wallet
     */
    topTokens?: Array<Token>;
    /**
     * A sample of the collections this wallet owns.
     * @type {Array<OwnedCollection>}
     * @memberof Wallet
     */
    collections?: Array<OwnedCollection>;
    /**
     * A reverse-chronological list of the latest transactions for a wallet.
     * @type {Array<Transaction>}
     * @memberof Wallet
     */
    history?: Array<Transaction>;
}
/**
 * Check if a given object implements the Wallet interface.
 */
export function instanceOfWallet(value: object): boolean;
export function WalletFromJSON(json: any): Wallet;
export function WalletFromJSONTyped(json: any, ignoreDiscriminator: boolean): Wallet;
export function WalletToJSON(value?: Wallet | null): any;
/**
 *
 * @export
 * @interface NonFungibleToken
 */
export interface NonFungibleToken {
    /**
     * ID of this particular token.
     * @type {string}
     * @memberof NonFungibleToken
     */
    tokenID: string;
    /**
     *
     * @type {string}
     * @memberof NonFungibleToken
     */
    title?: string;
    /**
     *
     * @type {string}
     * @memberof NonFungibleToken
     */
    contractTitle?: string;
    /**
     * A description of a contract may contain markup such as HTML or Markdown.
     * @type {string}
     * @memberof NonFungibleToken
     */
    description?: string;
    /**
     *
     * @type {Media}
     * @memberof NonFungibleToken
     */
    media?: Media;
    /**
     * Transformed media assets that are resized and transcoded in to friendlier formats for web and mobile delivery.
     * @type {Array<MediaPreview>}
     * @memberof NonFungibleToken
     */
    previews?: Array<MediaPreview>;
    /**
     *
     * @type {Wallet}
     * @memberof NonFungibleToken
     */
    owner?: Wallet;
    /**
     *
     * @type {Array<TokenAttribute>}
     * @memberof NonFungibleToken
     */
    attributes?: Array<TokenAttribute>;
    /**
     *
     * @type {Collection}
     * @memberof NonFungibleToken
     */
    collection?: Collection;
    /**
     *
     * @type {Transaction}
     * @memberof NonFungibleToken
     */
    purchase?: Transaction;
    /**
     * A rough heuristic indicating the underlying technology and hypothetical durability of an asset. "On-Chain" assets store metadata and the asset media (e.g. SVG file, source code or MIDI) on a blockchain. "Distributed" assets are stored on decentralized protocols such as IPFS. "Web" assets are stored on services such as Amazon's S3. Each technology has different tradeoffs, in particular certain projects need more flexibility than is provided by on-chain data."
     * @type {string}
     * @memberof NonFungibleToken
     */
    durability?: NonFungibleTokenDurabilityEnum;
    /**
     * The project name of the NFT.
     * @type {string}
     * @memberof NonFungibleToken
     */
    projectName?: string;
}
/**
 * @export
 */
export const NonFungibleTokenDurabilityEnum: {
    readonly OnChain: "On-Chain";
    readonly Decentralized: "Decentralized";
    readonly Web: "Web";
    readonly Unknown: "Unknown";
};
export type NonFungibleTokenDurabilityEnum = (typeof NonFungibleTokenDurabilityEnum)[keyof typeof NonFungibleTokenDurabilityEnum];
/**
 * Check if a given object implements the NonFungibleToken interface.
 */
export function instanceOfNonFungibleToken(value: object): boolean;
export function NonFungibleTokenFromJSON(json: any): NonFungibleToken;
export function NonFungibleTokenFromJSONTyped(json: any, ignoreDiscriminator: boolean): NonFungibleToken;
export function NonFungibleTokenToJSON(value?: NonFungibleToken | null): any;
/**
 *
 * @export
 * @interface SearchDocument
 */
export interface SearchDocument {
    /**
     *
     * @type {Token}
     * @memberof SearchDocument
     */
    token?: Token;
    /**
     *
     * @type {Wallet}
     * @memberof SearchDocument
     */
    wallet?: Wallet;
    /**
     *
     * @type {Collection}
     * @memberof SearchDocument
     */
    collection?: Collection;
}
/**
 * Check if a given object implements the SearchDocument interface.
 */
export function instanceOfSearchDocument(value: object): boolean;
export function SearchDocumentFromJSON(json: any): SearchDocument;
export function SearchDocumentFromJSONTyped(json: any, ignoreDiscriminator: boolean): SearchDocument;
export function SearchDocumentToJSON(value?: SearchDocument | null): any;
/**
 *
 * @export
 * @interface TokenEvents
 */
export interface TokenEvents {
    /**
     * Metadata for the token specified in the request.
     * @type {Array<Token>}
     * @memberof TokenEvents
     */
    token?: Array<Token>;
    /**
     * A list of the events for a token.
     * @type {Array<Transaction>}
     * @memberof TokenEvents
     */
    events?: Array<Transaction>;
}
/**
 * Check if a given object implements the TokenEvents interface.
 */
export function instanceOfTokenEvents(value: object): boolean;
export function TokenEventsFromJSON(json: any): TokenEvents;
export function TokenEventsFromJSONTyped(json: any, ignoreDiscriminator: boolean): TokenEvents;
export function TokenEventsToJSON(value?: TokenEvents | null): any;
/**
 *
 * @export
 * @interface TokenGate
 */
export interface TokenGate {
    /**
     *
     * @type {boolean}
     * @memberof TokenGate
     */
    hasToken: boolean;
}
/**
 * Check if a given object implements the TokenGate interface.
 */
export function instanceOfTokenGate(value: object): boolean;
export function TokenGateFromJSON(json: any): TokenGate;
export function TokenGateFromJSONTyped(json: any, ignoreDiscriminator: boolean): TokenGate;
export function TokenGateToJSON(value?: TokenGate | null): any;
/**
 *
 */
export class AlphaApi extends runtime.BaseAPI {
    /**
     * Returns trending and interesting collections on Ethereum. Useful for powering discovery experiences and providing an on-ramp to exploring creative blockchain data.
     */
    getTopCollectionsRaw(initOverrides?: RequestInit | InitOverrideFunction): Promise<ApiResponse<Array<Collection>>>;
    /**
     * Returns trending and interesting collections on Ethereum. Useful for powering discovery experiences and providing an on-ramp to exploring creative blockchain data.
     */
    getTopCollections(initOverrides?: RequestInit | InitOverrideFunction): Promise<Array<Collection>>;
    /**
     * Returns trending and interesting NFTs and SFTs on Ethereum. Useful for powering discovery experiences and providing an on-ramp to exploring creative blockchain data.
     */
    getTopTokensRaw(initOverrides?: RequestInit | InitOverrideFunction): Promise<ApiResponse<Array<Token>>>;
    /**
     * Returns trending and interesting NFTs and SFTs on Ethereum. Useful for powering discovery experiences and providing an on-ramp to exploring creative blockchain data.
     */
    getTopTokens(initOverrides?: RequestInit | InitOverrideFunction): Promise<Array<Token>>;
    /**
     * Returns trending and interesting wallets on Ethereum. Useful for powering discovery experiences and providing an on-ramp to exploring creative blockchain data.
     */
    getTopWalletsRaw(initOverrides?: RequestInit | InitOverrideFunction): Promise<ApiResponse<Array<Wallet>>>;
    /**
     * Returns trending and interesting wallets on Ethereum. Useful for powering discovery experiences and providing an on-ramp to exploring creative blockchain data.
     */
    getTopWallets(initOverrides?: RequestInit | InitOverrideFunction): Promise<Array<Wallet>>;
}
export interface GetCollectionRequest {
    contractAddress: string;
    chainID?: string;
}
export interface GetContractTokensRequest {
    contractAddress: string;
    chainID?: string;
    limit?: number;
}
export interface GetContractTokensByContractAndIDRequest {
    contractAddresses: string;
    tokenIdentifiers: string;
    chainID?: string;
    limit?: number;
}
export interface GetContractTransactionHistoryRequest {
    contractAddress: string;
    cursor?: string;
    chainID?: string;
    limit?: number;
}
export interface GetSearchResultsRequest {
    query: string;
    cursor?: string;
}
export interface GetSoldTokensRequest {
    walletAddress: string;
    chainID?: string;
    cursor?: string;
    limit?: number;
}
export interface GetTokenRequest {
    contractAddress: string;
    tokenID: string;
    chainID?: string;
}
export interface GetTokenGateRequest {
    tokenID: string;
    contractAddress: string;
    walletAddress: string;
    chainID?: string;
}
export interface GetTokenTransfersRequest {
    contractAddress: string;
    tokenID: string;
    chainID?: string;
    limit?: number;
}
export interface GetTokensBySearchQueryRequest {
    query: string;
    cursor?: string;
}
export interface GetWalletRequest {
    walletAddress: string;
    chainID?: string;
}
export interface GetWalletBalancesRequest {
    walletAddress: string;
    limit?: number;
}
export interface GetWalletMintsRequest {
    walletAddress: string;
    chainID?: string;
    cursor?: string;
    limit?: number;
}
export interface GetWalletTokensRequest {
    walletAddress: string;
    cursor?: string;
    chainID?: string;
    limit?: number;
}
export interface GetWalletTransactionsRequest {
    walletAddress: string;
    cursor?: string;
    limit?: number;
    chainID?: string;
    tokenType?: GetWalletTransactionsTokenTypeEnum;
}
/**
 *
 */
export class DefaultApi extends runtime.BaseAPI {
    /**
     * Lists all supported blockchains.
     */
    getBlockchainsRaw(initOverrides?: RequestInit | InitOverrideFunction): Promise<ApiResponse<Array<BlockchainInfo>>>;
    /**
     * Lists all supported blockchains.
     */
    getBlockchains(initOverrides?: RequestInit | InitOverrideFunction): Promise<Array<BlockchainInfo>>;
    /**
     * Get a collection by its contract address.
     */
    getCollectionRaw(requestParameters: GetCollectionRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<ApiResponse<Array<Collection>>>;
    /**
     * Get a collection by its contract address.
     */
    getCollection(requestParameters: GetCollectionRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<Array<Collection>>;
    /**
     * Get tokens by contract address.
     */
    getContractTokensRaw(requestParameters: GetContractTokensRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<ApiResponse<Array<Token>>>;
    /**
     * Get tokens by contract address.
     */
    getContractTokens(requestParameters: GetContractTokensRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<Array<Token>>;
    /**
     * Get tokens by a pair of contract addresses and token IDs. The input are two ordered arrays. The first element of contractAddresses should be related to the 1st element of the tokenID, etc. In the below example two tokens are being requested, token 3481 from the \"goblintown\" contract (i.e. 0xbce3781ae7ca1a5e050bd9c4c77369867ebc307e) and token 50603 from the Otherdeed contract (i.e. 0x34d85c9cdeb23fa97cb08333b511ac86e1c4e258).
     */
    getContractTokensByContractAndIDRaw(requestParameters: GetContractTokensByContractAndIDRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<ApiResponse<Array<Token>>>;
    /**
     * Get tokens by a pair of contract addresses and token IDs. The input are two ordered arrays. The first element of contractAddresses should be related to the 1st element of the tokenID, etc. In the below example two tokens are being requested, token 3481 from the \"goblintown\" contract (i.e. 0xbce3781ae7ca1a5e050bd9c4c77369867ebc307e) and token 50603 from the Otherdeed contract (i.e. 0x34d85c9cdeb23fa97cb08333b511ac86e1c4e258).
     */
    getContractTokensByContractAndID(requestParameters: GetContractTokensByContractAndIDRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<Array<Token>>;
    /**
     * Get the transaction history for a collection
     */
    getContractTransactionHistoryRaw(requestParameters: GetContractTransactionHistoryRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<ApiResponse<Array<Transaction>>>;
    /**
     * Get the transaction history for a collection
     */
    getContractTransactionHistory(requestParameters: GetContractTransactionHistoryRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<Array<Transaction>>;
    /**
     * Get search results such as wallets, tokens, and collections by a search query.
     */
    getSearchResultsRaw(requestParameters: GetSearchResultsRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<ApiResponse<Array<SearchDocument>>>;
    /**
     * Get search results such as wallets, tokens, and collections by a search query.
     */
    getSearchResults(requestParameters: GetSearchResultsRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<Array<SearchDocument>>;
    /**
     * Returns a list of tokens sold by a wallet.
     */
    getSoldTokensRaw(requestParameters: GetSoldTokensRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<ApiResponse<Array<Token>>>;
    /**
     * Returns a list of tokens sold by a wallet.
     */
    getSoldTokens(requestParameters: GetSoldTokensRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<Array<Token>>;
    /**
     * Get a token by its contract address and token ID.
     */
    getTokenRaw(requestParameters: GetTokenRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<ApiResponse<Array<Token>>>;
    /**
     * Get a token by its contract address and token ID.
     */
    getToken(requestParameters: GetTokenRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<Array<Token>>;
    /**
     * Determine if a wallet has a given token from a contract.
     */
    getTokenGateRaw(requestParameters: GetTokenGateRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<ApiResponse<TokenGate>>;
    /**
     * Determine if a wallet has a given token from a contract.
     */
    getTokenGate(requestParameters: GetTokenGateRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<TokenGate>;
    /**
     * Returns a list of transfer transactions on a specified token.
     */
    getTokenTransfersRaw(requestParameters: GetTokenTransfersRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<ApiResponse<TokenEvents>>;
    /**
     * Returns a list of transfer transactions on a specified token.
     */
    getTokenTransfers(requestParameters: GetTokenTransfersRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<TokenEvents>;
    /**
     * Get tokens by a search query.
     */
    getTokensBySearchQueryRaw(requestParameters: GetTokensBySearchQueryRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<ApiResponse<Array<Token>>>;
    /**
     * Get tokens by a search query.
     */
    getTokensBySearchQuery(requestParameters: GetTokensBySearchQueryRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<Array<Token>>;
    /**
     * Get a wallet by a wallet address
     */
    getWalletRaw(requestParameters: GetWalletRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<ApiResponse<Array<Wallet>>>;
    /**
     * Get a wallet by a wallet address
     */
    getWallet(requestParameters: GetWalletRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<Array<Wallet>>;
    /**
     * Returns a list of balances for tokens this wallet currently owns.
     */
    getWalletBalancesRaw(requestParameters: GetWalletBalancesRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<ApiResponse<Array<CurrencyInfo>>>;
    /**
     * Returns a list of balances for tokens this wallet currently owns.
     */
    getWalletBalances(requestParameters: GetWalletBalancesRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<Array<CurrencyInfo>>;
    /**
     * Returns a list of tokens minted by a wallet.
     */
    getWalletMintsRaw(requestParameters: GetWalletMintsRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<ApiResponse<Array<Token>>>;
    /**
     * Returns a list of tokens minted by a wallet.
     */
    getWalletMints(requestParameters: GetWalletMintsRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<Array<Token>>;
    /**
     * Returns a list of tokens owned by a wallet.
     */
    getWalletTokensRaw(requestParameters: GetWalletTokensRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<ApiResponse<Array<Token>>>;
    /**
     * Returns a list of tokens owned by a wallet.
     */
    getWalletTokens(requestParameters: GetWalletTokensRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<Array<Token>>;
    /**
     * Returns a list of transactions that have been performed by this wallet. Use token type to restrict to only certain transactions, such as NFTs
     */
    getWalletTransactionsRaw(requestParameters: GetWalletTransactionsRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<ApiResponse<Array<Transaction>>>;
    /**
     * Returns a list of transactions that have been performed by this wallet. Use token type to restrict to only certain transactions, such as NFTs
     */
    getWalletTransactions(requestParameters: GetWalletTransactionsRequest, initOverrides?: RequestInit | InitOverrideFunction): Promise<Array<Transaction>>;
}
/**
 * @export
 */
export const GetWalletTransactionsTokenTypeEnum: {
    readonly Nft: "NFT";
    readonly Sft: "SFT";
    readonly Unknown: "unknown";
};
export type GetWalletTransactionsTokenTypeEnum = (typeof GetWalletTransactionsTokenTypeEnum)[keyof typeof GetWalletTransactionsTokenTypeEnum];

//# sourceMappingURL=index.d.ts.map
