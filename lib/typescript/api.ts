/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * n.xyz REST API
 * REST API for blockchain data.
 *
 * OpenAPI spec version: 0.9.1
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://api.n.xyz".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface BlockchainInfo
 */
export interface BlockchainInfo {
    /**
     * The name of a given chain. This is often a canonical name since a protocol may have multiple chains.
     * @type {string}
     * @memberof BlockchainInfo
     */
    name?: string;
    /**
     * The short-hand name for a given chain. Multiple chains (e.g. mainnet and a testnet) may have the same name.
     * @type {string}
     * @memberof BlockchainInfo
     */
    shortName?: string;
    /**
     * A CAIP-2 compliant chain ID. This ID is designed to provide a unique identifier for a given chain.
     * @type {string}
     * @memberof BlockchainInfo
     */
    chainID?: string;
    /**
     * An ID used for a chain in a given ecosystem. This ID is not canonical and may collide with other chains. Do not use this value as a unique identifier.
     * @type {string}
     * @memberof BlockchainInfo
     */
    shortChainID?: string;
}
/**
 * 
 * @export
 * @interface Collection
 */
export interface Collection {
    /**
     * 
     * @type {BlockchainInfo}
     * @memberof Collection
     */
    blockchain: BlockchainInfo;
    /**
     * Address of the contract that minted this NFT.
     * @type {string}
     * @memberof Collection
     */
    contractAddress: string;
    /**
     * 
     * @type {string}
     * @memberof Collection
     */
    symbol?: string;
    /**
     * 
     * @type {string}
     * @memberof Collection
     */
    slug?: string;
    /**
     * 
     * @type {string}
     * @memberof Collection
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof Collection
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof Collection
     */
    shortDescription?: string;
    /**
     * Timestamp of creation of this contract in RFC 3339.
     * @type {Date}
     * @memberof Collection
     */
    createdDate?: Date;
    /**
     * 
     * @type {CurrencyInfo}
     * @memberof Collection
     */
    floorPrice?: CurrencyInfo;
    /**
     * 
     * @type {Media}
     * @memberof Collection
     */
    bannerImage?: Media;
    /**
     * 
     * @type {Media}
     * @memberof Collection
     */
    featuredImage?: Media;
    /**
     * 
     * @type {Array<URL>}
     * @memberof Collection
     */
    urls?: Array<URL>;
    /**
     * 
     * @type {Array<SocialMedia>}
     * @memberof Collection
     */
    socialMedia?: Array<SocialMedia>;
}
/**
 * 
 * @export
 * @interface CurrencyInfo
 */
export interface CurrencyInfo {
    /**
     * Transaction value as a string-encoded bigint in the base unit for a given blockchain (e.g. wei for Ethereum) or fiat currency (e.g. US Dollars).
     * @type {string}
     * @memberof CurrencyInfo
     */
    value?: string;
    /**
     * Transaction value as a float representing the amount of tokens, e.g. 0.89 would be 89% of a token.
     * @type {number}
     * @memberof CurrencyInfo
     */
    tokenValue?: number;
    /**
     * The total value of this token in fiat currency.
     * @type {Array<CurrencyInfo>}
     * @memberof CurrencyInfo
     */
    fiat?: Array<CurrencyInfo>;
    /**
     * A formatted, human-friendly representation of the transaction value, e.g. the value in Ether, possibly with localized thousands separator and radix character.
     * @type {string}
     * @memberof CurrencyInfo
     */
    pretty?: string;
    /**
     * The base value for a given token. For Ethereum this would be 18. This would yield an equation such as 890000000000000000wei / 10^18 = 0.89 ETH.
     * @type {number}
     * @memberof CurrencyInfo
     */
    decimals?: number;
    /**
     * 
     * @type {string}
     * @memberof CurrencyInfo
     */
    symbol?: string;
    /**
     * 
     * @type {string}
     * @memberof CurrencyInfo
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface ENS
 */
export interface ENS {
    /**
     * The ENS or domain name.
     * @type {string}
     * @memberof ENS
     */
    name?: string;
    /**
     * The address the ENS record points to.
     * @type {string}
     * @memberof ENS
     */
    pointsTo?: string;
    /**
     * Date the ENS registration expires.
     * @type {Date}
     * @memberof ENS
     */
    expires?: Date;
    /**
     * A wallet address can have multiple ENS records. The primary ENS name represents a \"cross-platform web3 username and profile.\" A wallet address can only have one primary name, and it can change at any time.
     * @type {boolean}
     * @memberof ENS
     */
    isPrimary?: boolean;
}
/**
 * 
 * @export
 * @interface ErrorMessage
 */
export interface ErrorMessage {
    /**
     * 
     * @type {string}
     * @memberof ErrorMessage
     */
    error: string;
}
/**
 * 
 * @export
 * @interface Media
 */
export interface Media {
    /**
     * 
     * @type {string}
     * @memberof Media
     */
    key: string;
    /**
     * URI for the image asset.
     * @type {string}
     * @memberof Media
     */
    URI?: string;
    /**
     * 
     * @type {Array<MediaVersion>}
     * @memberof Media
     */
    version?: Array<MediaVersion>;
}
/**
 * 
 * @export
 * @interface MediaVersion
 */
export interface MediaVersion {
    /**
     * 
     * @type {string}
     * @memberof MediaVersion
     */
    kind?: MediaVersion.KindEnum;
    /**
     * 
     * @type {string}
     * @memberof MediaVersion
     */
    format?: string;
    /**
     * 
     * @type {number}
     * @memberof MediaVersion
     */
    width?: number;
    /**
     * 
     * @type {number}
     * @memberof MediaVersion
     */
    height?: number;
    /**
     * 
     * @type {number}
     * @memberof MediaVersion
     */
    numBytes?: number;
    /**
     * If a video, length of video in ISO 8601 duration format.
     * @type {string}
     * @memberof MediaVersion
     */
    duration?: string;
}

/**
 * @export
 * @namespace MediaVersion
 */
export namespace MediaVersion {
    /**
     * @export
     * @enum {string}
     */
    export enum KindEnum {
        Video = <any> 'video',
        Image = <any> 'image',
        Raw = <any> 'raw',
        Audio = <any> 'audio'
    }
}
/**
 * 
 * @export
 * @interface NonFungibleToken
 */
export interface NonFungibleToken {
    /**
     * ID of this particular token.
     * @type {string}
     * @memberof NonFungibleToken
     */
    tokenID: string;
    /**
     * 
     * @type {string}
     * @memberof NonFungibleToken
     */
    title?: string;
    /**
     * 
     * @type {string}
     * @memberof NonFungibleToken
     */
    contractTitle?: string;
    /**
     * A description of a contract may contain markup such as HTML or Markdown.
     * @type {string}
     * @memberof NonFungibleToken
     */
    description?: string;
    /**
     * 
     * @type {Media}
     * @memberof NonFungibleToken
     */
    media?: Media;
    /**
     * 
     * @type {Wallet}
     * @memberof NonFungibleToken
     */
    owner?: Wallet;
    /**
     * 
     * @type {Array<TokenAttribute>}
     * @memberof NonFungibleToken
     */
    attributes?: Array<TokenAttribute>;
    /**
     * 
     * @type {Collection}
     * @memberof NonFungibleToken
     */
    collection?: Collection;
    /**
     * 
     * @type {Transaction}
     * @memberof NonFungibleToken
     */
    purchase?: Transaction;
    /**
     * A rough heuristic indicating the underlying technology and hypothetical durability of an asset. \"On-Chain\" assets store metadata and the asset media (e.g. SVG file, source code or MIDI) on a blockchain. \"Distributed\" assets are stored on decentralized protocols such as IPFS. \"Web\" assets are stored on services such as Amazon's S3. Each technology has different tradeoffs, in particular certain projects need more flexibility than is provided by on-chain data.\"
     * @type {string}
     * @memberof NonFungibleToken
     */
    durability?: NonFungibleToken.DurabilityEnum;
    /**
     * The project name of the NFT.
     * @type {string}
     * @memberof NonFungibleToken
     */
    projectName?: string;
}

/**
 * @export
 * @namespace NonFungibleToken
 */
export namespace NonFungibleToken {
    /**
     * @export
     * @enum {string}
     */
    export enum DurabilityEnum {
        OnChain = <any> 'On-Chain',
        Decentralized = <any> 'Decentralized',
        Web = <any> 'Web',
        Unknown = <any> 'Unknown'
    }
}
/**
 * 
 * @export
 * @interface OwnedCollection
 */
export interface OwnedCollection {
    /**
     * A sample of the tokens owned by this wallet.
     * @type {Array<Token>}
     * @memberof OwnedCollection
     */
    tokens?: Array<Token>;
    /**
     * 
     * @type {Collection}
     * @memberof OwnedCollection
     */
    collection?: Collection;
    /**
     * 
     * @type {CurrencyInfo}
     * @memberof OwnedCollection
     */
    totalSpent?: CurrencyInfo;
}
/**
 * 
 * @export
 * @interface SocialMedia
 */
export interface SocialMedia {
    /**
     * 
     * @type {string}
     * @memberof SocialMedia
     */
    network?: string;
    /**
     * 
     * @type {string}
     * @memberof SocialMedia
     */
    username?: string;
}
/**
 * 
 * @export
 * @interface Token
 */
export interface Token {
    /**
     * 
     * @type {BlockchainInfo}
     * @memberof Token
     */
    blockchain: BlockchainInfo;
    /**
     * Address of the contract that minted this NFT.
     * @type {string}
     * @memberof Token
     */
    contractAddress: string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    tokenStandard?: string;
    /**
     * 
     * @type {string}
     * @memberof Token
     */
    symbol?: string;
    /**
     * 
     * @type {NonFungibleToken}
     * @memberof Token
     */
    nft?: NonFungibleToken;
}
/**
 * 
 * @export
 * @interface TokenAttribute
 */
export interface TokenAttribute {
    /**
     * The key or kind of trait.
     * @type {string}
     * @memberof TokenAttribute
     */
    traitType?: string;
    /**
     * A distinct attribute belonging to a particular type of trait.
     * @type {string}
     * @memberof TokenAttribute
     */
    value?: string;
}
/**
 * 
 * @export
 * @interface TokenEvents
 */
export interface TokenEvents {
    /**
     * 
     * @type {Token}
     * @memberof TokenEvents
     */
    token?: Token;
    /**
     * A list of the events for a token.
     * @type {Array<Transaction>}
     * @memberof TokenEvents
     */
    events?: Array<Transaction>;
}
/**
 * 
 * @export
 * @interface Transaction
 */
export interface Transaction {
    /**
     * Block number of the transaction.
     * @type {number}
     * @memberof Transaction
     */
    blockNumber?: number;
    /**
     * Index of the transaction in the block.
     * @type {number}
     * @memberof Transaction
     */
    transactionIndex?: number;
    /**
     * 
     * @type {CurrencyInfo}
     * @memberof Transaction
     */
    gasFee?: CurrencyInfo;
    /**
     * Timestamp of the transaction in RFC 3339.
     * @type {Date}
     * @memberof Transaction
     */
    timestamp?: Date;
    /**
     * Log lines related to the transaction.
     * @type {Array<TransactionLogLine>}
     * @memberof Transaction
     */
    logLine?: Array<TransactionLogLine>;
}
/**
 * 
 * @export
 * @interface TransactionLogLine
 */
export interface TransactionLogLine {
    /**
     * When the value is true, it indicates that a token has been burned, and this transaction corresponds to the burn.
     * @type {boolean}
     * @memberof TransactionLogLine
     */
    burned?: boolean;
    /**
     * When the value is true, it indicates this is the transaction representing a token minting.
     * @type {boolean}
     * @memberof TransactionLogLine
     */
    mint?: boolean;
    /**
     * Index of the log in the transaction.
     * @type {number}
     * @memberof TransactionLogLine
     */
    logIndex?: number;
    /**
     * 
     * @type {string}
     * @memberof TransactionLogLine
     */
    fromAddress?: string;
    /**
     * 
     * @type {string}
     * @memberof TransactionLogLine
     */
    toAddress?: string;
    /**
     * 
     * @type {CurrencyInfo}
     * @memberof TransactionLogLine
     */
    price?: CurrencyInfo;
}
/**
 * 
 * @export
 * @interface URL
 */
export interface URL {
    /**
     * Human-readable name of the site.
     * @type {string}
     * @memberof URL
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof URL
     */
    url?: string;
}
/**
 * 
 * @export
 * @interface Wallet
 */
export interface Wallet {
    /**
     * The total balance in a fiat currency (e.g. USD) for the wallet.
     * @type {Array<CurrencyInfo>}
     * @memberof Wallet
     */
    totalBalance?: Array<CurrencyInfo>;
    /**
     * The balance of fungible tokens from smart contracts or blockchains.
     * @type {Array<CurrencyInfo>}
     * @memberof Wallet
     */
    balances?: Array<CurrencyInfo>;
    /**
     * 
     * @type {string}
     * @memberof Wallet
     */
    address: string;
    /**
     * 
     * @type {Array<ENS>}
     * @memberof Wallet
     */
    ens?: Array<ENS>;
    /**
     * 
     * @type {Array<SocialMedia>}
     * @memberof Wallet
     */
    socialMedia?: Array<SocialMedia>;
    /**
     * A sample of the most recently transferred tokens owned by this wallet.
     * @type {Array<Token>}
     * @memberof Wallet
     */
    recentTokens?: Array<Token>;
    /**
     * A sample of the most expensive tokens owned by this wallet.
     * @type {Array<Token>}
     * @memberof Wallet
     */
    topTokens?: Array<Token>;
    /**
     * A sample of the collections this wallet owns.
     * @type {Array<OwnedCollection>}
     * @memberof Wallet
     */
    collections?: Array<OwnedCollection>;
    /**
     * A reverse-chronological list of the latest transactions for a wallet.
     * @type {Array<Transaction>}
     * @memberof Wallet
     */
    history?: Array<Transaction>;
}
/**
 * DefaultApi - fetch parameter creator
 * @export
 */
export const DefaultApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all supported blockchains.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BlockchainsGet(options: any = {}): FetchArgs {
            const localVarPath = `/api/v1/blockchains`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("apikey")
					: configuration.apiKey;
                localVarQueryParameter["apikey"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a collection by its contract address.
         * @param {string} contractAddress A hex address for a blockchain contract.
         * @param {string} [chainID] An identifier to restrict results to a given blockchain. Provide either a keyword such as \&quot;ethereum\&quot; or \&quot;polygon\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CollectionsContractAddressGet(contractAddress: string, chainID?: string, options: any = {}): FetchArgs {
            // verify required parameter 'contractAddress' is not null or undefined
            if (contractAddress === null || contractAddress === undefined) {
                throw new RequiredError('contractAddress','Required parameter contractAddress was null or undefined when calling apiV1CollectionsContractAddressGet.');
            }
            const localVarPath = `/api/v1/collections/{contractAddress}`
                .replace(`{${"contractAddress"}}`, encodeURIComponent(String(contractAddress)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("apikey")
					: configuration.apiKey;
                localVarQueryParameter["apikey"] = localVarApiKeyValue;
            }

            if (chainID !== undefined) {
                localVarQueryParameter['chainID'] = chainID;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get tokens by contract address.
         * @param {string} contractAddress A hex address for a blockchain contract.
         * @param {string} [chainID] An identifier to restrict results to a given blockchain. Provide either a keyword such as \&quot;ethereum\&quot; or \&quot;polygon\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.
         * @param {number} [page] The page number for a set of results. The first page is 0.
         * @param {number} [limit] Limits the number of results in a single response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TokensContractAddressGet(contractAddress: string, chainID?: string, page?: number, limit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'contractAddress' is not null or undefined
            if (contractAddress === null || contractAddress === undefined) {
                throw new RequiredError('contractAddress','Required parameter contractAddress was null or undefined when calling apiV1TokensContractAddressGet.');
            }
            const localVarPath = `/api/v1/tokens/{contractAddress}`
                .replace(`{${"contractAddress"}}`, encodeURIComponent(String(contractAddress)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("apikey")
					: configuration.apiKey;
                localVarQueryParameter["apikey"] = localVarApiKeyValue;
            }

            if (chainID !== undefined) {
                localVarQueryParameter['chainID'] = chainID;
            }

            if (page !== undefined) {
                localVarQueryParameter['page'] = page;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a token by its contract address and token ID.
         * @param {string} contractAddress A hex address for a blockchain contract.
         * @param {string} tokenID An arbitrary ID defined by a contract to uniquely identify a cryptographic asset such as an NFT.
         * @param {string} [chainID] An identifier to restrict results to a given blockchain. Provide either a keyword such as \&quot;ethereum\&quot; or \&quot;polygon\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TokensContractAddressTokenIDGet(contractAddress: string, tokenID: string, chainID?: string, options: any = {}): FetchArgs {
            // verify required parameter 'contractAddress' is not null or undefined
            if (contractAddress === null || contractAddress === undefined) {
                throw new RequiredError('contractAddress','Required parameter contractAddress was null or undefined when calling apiV1TokensContractAddressTokenIDGet.');
            }
            // verify required parameter 'tokenID' is not null or undefined
            if (tokenID === null || tokenID === undefined) {
                throw new RequiredError('tokenID','Required parameter tokenID was null or undefined when calling apiV1TokensContractAddressTokenIDGet.');
            }
            const localVarPath = `/api/v1/tokens/{contractAddress}/{tokenID}`
                .replace(`{${"contractAddress"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"tokenID"}}`, encodeURIComponent(String(tokenID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("apikey")
					: configuration.apiKey;
                localVarQueryParameter["apikey"] = localVarApiKeyValue;
            }

            if (chainID !== undefined) {
                localVarQueryParameter['chainID'] = chainID;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Returns a list of transfer transactions on a specified token.
         * @param {string} contractAddress A hex address for a blockchain contract.
         * @param {string} tokenID An arbitrary ID defined by a contract to uniquely identify a cryptographic asset such as an NFT.
         * @param {string} [chainID] An identifier to restrict results to a given blockchain. Provide either a keyword such as \&quot;ethereum\&quot; or \&quot;polygon\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TokensContractAddressTokenIDTransfersGet(contractAddress: string, tokenID: string, chainID?: string, options: any = {}): FetchArgs {
            // verify required parameter 'contractAddress' is not null or undefined
            if (contractAddress === null || contractAddress === undefined) {
                throw new RequiredError('contractAddress','Required parameter contractAddress was null or undefined when calling apiV1TokensContractAddressTokenIDTransfersGet.');
            }
            // verify required parameter 'tokenID' is not null or undefined
            if (tokenID === null || tokenID === undefined) {
                throw new RequiredError('tokenID','Required parameter tokenID was null or undefined when calling apiV1TokensContractAddressTokenIDTransfersGet.');
            }
            const localVarPath = `/api/v1/tokens/{contractAddress}/{tokenID}/transfers`
                .replace(`{${"contractAddress"}}`, encodeURIComponent(String(contractAddress)))
                .replace(`{${"tokenID"}}`, encodeURIComponent(String(tokenID)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("apikey")
					: configuration.apiKey;
                localVarQueryParameter["apikey"] = localVarApiKeyValue;
            }

            if (chainID !== undefined) {
                localVarQueryParameter['chainID'] = chainID;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get a wallet by a wallet address
         * @param {string} walletAddress A hex string referencing a public wallet address.
         * @param {string} [chainID] An identifier to restrict results to a given blockchain. Provide either a keyword such as \&quot;ethereum\&quot; or \&quot;polygon\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WalletsWalletAddressGet(walletAddress: string, chainID?: string, options: any = {}): FetchArgs {
            // verify required parameter 'walletAddress' is not null or undefined
            if (walletAddress === null || walletAddress === undefined) {
                throw new RequiredError('walletAddress','Required parameter walletAddress was null or undefined when calling apiV1WalletsWalletAddressGet.');
            }
            const localVarPath = `/api/v1/wallets/{walletAddress}`
                .replace(`{${"walletAddress"}}`, encodeURIComponent(String(walletAddress)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apikey required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("apikey")
					: configuration.apiKey;
                localVarQueryParameter["apikey"] = localVarApiKeyValue;
            }

            if (chainID !== undefined) {
                localVarQueryParameter['chainID'] = chainID;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Lists all supported blockchains.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BlockchainsGet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<BlockchainInfo>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiV1BlockchainsGet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a collection by its contract address.
         * @param {string} contractAddress A hex address for a blockchain contract.
         * @param {string} [chainID] An identifier to restrict results to a given blockchain. Provide either a keyword such as \&quot;ethereum\&quot; or \&quot;polygon\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CollectionsContractAddressGet(contractAddress: string, chainID?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Collection>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiV1CollectionsContractAddressGet(contractAddress, chainID, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get tokens by contract address.
         * @param {string} contractAddress A hex address for a blockchain contract.
         * @param {string} [chainID] An identifier to restrict results to a given blockchain. Provide either a keyword such as \&quot;ethereum\&quot; or \&quot;polygon\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.
         * @param {number} [page] The page number for a set of results. The first page is 0.
         * @param {number} [limit] Limits the number of results in a single response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TokensContractAddressGet(contractAddress: string, chainID?: string, page?: number, limit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Token>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiV1TokensContractAddressGet(contractAddress, chainID, page, limit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a token by its contract address and token ID.
         * @param {string} contractAddress A hex address for a blockchain contract.
         * @param {string} tokenID An arbitrary ID defined by a contract to uniquely identify a cryptographic asset such as an NFT.
         * @param {string} [chainID] An identifier to restrict results to a given blockchain. Provide either a keyword such as \&quot;ethereum\&quot; or \&quot;polygon\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TokensContractAddressTokenIDGet(contractAddress: string, tokenID: string, chainID?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Token>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiV1TokensContractAddressTokenIDGet(contractAddress, tokenID, chainID, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Returns a list of transfer transactions on a specified token.
         * @param {string} contractAddress A hex address for a blockchain contract.
         * @param {string} tokenID An arbitrary ID defined by a contract to uniquely identify a cryptographic asset such as an NFT.
         * @param {string} [chainID] An identifier to restrict results to a given blockchain. Provide either a keyword such as \&quot;ethereum\&quot; or \&quot;polygon\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TokensContractAddressTokenIDTransfersGet(contractAddress: string, tokenID: string, chainID?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<TokenEvents> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiV1TokensContractAddressTokenIDTransfersGet(contractAddress, tokenID, chainID, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get a wallet by a wallet address
         * @param {string} walletAddress A hex string referencing a public wallet address.
         * @param {string} [chainID] An identifier to restrict results to a given blockchain. Provide either a keyword such as \&quot;ethereum\&quot; or \&quot;polygon\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WalletsWalletAddressGet(walletAddress: string, chainID?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Array<Wallet>> {
            const localVarFetchArgs = DefaultApiFetchParamCreator(configuration).apiV1WalletsWalletAddressGet(walletAddress, chainID, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * 
         * @summary Lists all supported blockchains.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1BlockchainsGet(options?: any) {
            return DefaultApiFp(configuration).apiV1BlockchainsGet(options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a collection by its contract address.
         * @param {string} contractAddress A hex address for a blockchain contract.
         * @param {string} [chainID] An identifier to restrict results to a given blockchain. Provide either a keyword such as \&quot;ethereum\&quot; or \&quot;polygon\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1CollectionsContractAddressGet(contractAddress: string, chainID?: string, options?: any) {
            return DefaultApiFp(configuration).apiV1CollectionsContractAddressGet(contractAddress, chainID, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get tokens by contract address.
         * @param {string} contractAddress A hex address for a blockchain contract.
         * @param {string} [chainID] An identifier to restrict results to a given blockchain. Provide either a keyword such as \&quot;ethereum\&quot; or \&quot;polygon\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.
         * @param {number} [page] The page number for a set of results. The first page is 0.
         * @param {number} [limit] Limits the number of results in a single response.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TokensContractAddressGet(contractAddress: string, chainID?: string, page?: number, limit?: number, options?: any) {
            return DefaultApiFp(configuration).apiV1TokensContractAddressGet(contractAddress, chainID, page, limit, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a token by its contract address and token ID.
         * @param {string} contractAddress A hex address for a blockchain contract.
         * @param {string} tokenID An arbitrary ID defined by a contract to uniquely identify a cryptographic asset such as an NFT.
         * @param {string} [chainID] An identifier to restrict results to a given blockchain. Provide either a keyword such as \&quot;ethereum\&quot; or \&quot;polygon\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TokensContractAddressTokenIDGet(contractAddress: string, tokenID: string, chainID?: string, options?: any) {
            return DefaultApiFp(configuration).apiV1TokensContractAddressTokenIDGet(contractAddress, tokenID, chainID, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Returns a list of transfer transactions on a specified token.
         * @param {string} contractAddress A hex address for a blockchain contract.
         * @param {string} tokenID An arbitrary ID defined by a contract to uniquely identify a cryptographic asset such as an NFT.
         * @param {string} [chainID] An identifier to restrict results to a given blockchain. Provide either a keyword such as \&quot;ethereum\&quot; or \&quot;polygon\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1TokensContractAddressTokenIDTransfersGet(contractAddress: string, tokenID: string, chainID?: string, options?: any) {
            return DefaultApiFp(configuration).apiV1TokensContractAddressTokenIDTransfersGet(contractAddress, tokenID, chainID, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get a wallet by a wallet address
         * @param {string} walletAddress A hex string referencing a public wallet address.
         * @param {string} [chainID] An identifier to restrict results to a given blockchain. Provide either a keyword such as \&quot;ethereum\&quot; or \&quot;polygon\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        apiV1WalletsWalletAddressGet(walletAddress: string, chainID?: string, options?: any) {
            return DefaultApiFp(configuration).apiV1WalletsWalletAddressGet(walletAddress, chainID, options)(fetch, basePath);
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Lists all supported blockchains.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1BlockchainsGet(options?: any) {
        return DefaultApiFp(this.configuration).apiV1BlockchainsGet(options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a collection by its contract address.
     * @param {string} contractAddress A hex address for a blockchain contract.
     * @param {string} [chainID] An identifier to restrict results to a given blockchain. Provide either a keyword such as \&quot;ethereum\&quot; or \&quot;polygon\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1CollectionsContractAddressGet(contractAddress: string, chainID?: string, options?: any) {
        return DefaultApiFp(this.configuration).apiV1CollectionsContractAddressGet(contractAddress, chainID, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get tokens by contract address.
     * @param {string} contractAddress A hex address for a blockchain contract.
     * @param {string} [chainID] An identifier to restrict results to a given blockchain. Provide either a keyword such as \&quot;ethereum\&quot; or \&quot;polygon\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.
     * @param {number} [page] The page number for a set of results. The first page is 0.
     * @param {number} [limit] Limits the number of results in a single response.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1TokensContractAddressGet(contractAddress: string, chainID?: string, page?: number, limit?: number, options?: any) {
        return DefaultApiFp(this.configuration).apiV1TokensContractAddressGet(contractAddress, chainID, page, limit, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a token by its contract address and token ID.
     * @param {string} contractAddress A hex address for a blockchain contract.
     * @param {string} tokenID An arbitrary ID defined by a contract to uniquely identify a cryptographic asset such as an NFT.
     * @param {string} [chainID] An identifier to restrict results to a given blockchain. Provide either a keyword such as \&quot;ethereum\&quot; or \&quot;polygon\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1TokensContractAddressTokenIDGet(contractAddress: string, tokenID: string, chainID?: string, options?: any) {
        return DefaultApiFp(this.configuration).apiV1TokensContractAddressTokenIDGet(contractAddress, tokenID, chainID, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Returns a list of transfer transactions on a specified token.
     * @param {string} contractAddress A hex address for a blockchain contract.
     * @param {string} tokenID An arbitrary ID defined by a contract to uniquely identify a cryptographic asset such as an NFT.
     * @param {string} [chainID] An identifier to restrict results to a given blockchain. Provide either a keyword such as \&quot;ethereum\&quot; or \&quot;polygon\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1TokensContractAddressTokenIDTransfersGet(contractAddress: string, tokenID: string, chainID?: string, options?: any) {
        return DefaultApiFp(this.configuration).apiV1TokensContractAddressTokenIDTransfersGet(contractAddress, tokenID, chainID, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get a wallet by a wallet address
     * @param {string} walletAddress A hex string referencing a public wallet address.
     * @param {string} [chainID] An identifier to restrict results to a given blockchain. Provide either a keyword such as \&quot;ethereum\&quot; or \&quot;polygon\&quot; to restrict to the mainnet for named chains. Also supports CAIP-2 identifiers.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public apiV1WalletsWalletAddressGet(walletAddress: string, chainID?: string, options?: any) {
        return DefaultApiFp(this.configuration).apiV1WalletsWalletAddressGet(walletAddress, chainID, options)(this.fetch, this.basePath);
    }

}
