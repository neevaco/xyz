/* tslint:disable */
/* eslint-disable */
/**
 * n.xyz REST API
 * REST API for blockchain data.
 *
 * The version of the OpenAPI document: 0.17.1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  BlockchainInfo,
  Collection,
  CurrencyInfo,
  ErrorMessage,
  SearchDocument,
  Token,
  TokenEvents,
  TokenGate,
  Transaction,
  Wallet,
} from '../models';
import {
    BlockchainInfoFromJSON,
    BlockchainInfoToJSON,
    CollectionFromJSON,
    CollectionToJSON,
    CurrencyInfoFromJSON,
    CurrencyInfoToJSON,
    ErrorMessageFromJSON,
    ErrorMessageToJSON,
    SearchDocumentFromJSON,
    SearchDocumentToJSON,
    TokenFromJSON,
    TokenToJSON,
    TokenEventsFromJSON,
    TokenEventsToJSON,
    TokenGateFromJSON,
    TokenGateToJSON,
    TransactionFromJSON,
    TransactionToJSON,
    WalletFromJSON,
    WalletToJSON,
} from '../models';

export interface GetCollectionRequest {
    contractAddress: string;
    chainID?: string;
}

export interface GetContractTokensRequest {
    contractAddress: string;
    chainID?: string;
    limit?: number;
}

export interface GetContractTokensByContractAndIDRequest {
    contractAddresses: string;
    tokenIdentifiers: string;
    chainID?: string;
    limit?: number;
}

export interface GetContractTransactionHistoryRequest {
    contractAddress: string;
    cursor?: string;
    chainID?: string;
    limit?: number;
}

export interface GetSearchResultsRequest {
    query: string;
    cursor?: string;
}

export interface GetSoldTokensRequest {
    walletAddress: string;
    chainID?: string;
    cursor?: string;
    limit?: number;
}

export interface GetTokenRequest {
    contractAddress: string;
    tokenID: string;
    chainID?: string;
}

export interface GetTokenGateRequest {
    tokenID: string;
    contractAddress: string;
    walletAddress: string;
    chainID?: string;
}

export interface GetTokenTransfersRequest {
    contractAddress: string;
    tokenID: string;
    chainID?: string;
    limit?: number;
}

export interface GetTokensBySearchQueryRequest {
    query: string;
    cursor?: string;
}

export interface GetWalletRequest {
    walletAddress: string;
    chainID?: string;
}

export interface GetWalletBalancesRequest {
    walletAddress: string;
    limit?: number;
}

export interface GetWalletMintsRequest {
    walletAddress: string;
    chainID?: string;
    cursor?: string;
    limit?: number;
}

export interface GetWalletTokensRequest {
    walletAddress: string;
    cursor?: string;
    chainID?: string;
    limit?: number;
}

export interface GetWalletTransactionsRequest {
    walletAddress: string;
    cursor?: string;
    limit?: number;
    chainID?: string;
    tokenType?: GetWalletTransactionsTokenTypeEnum;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * Lists all supported blockchains.
     */
    async getBlockchainsRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<BlockchainInfo>>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["apikey"] = this.configuration.apiKey("apikey"); // apikey authentication
        }

        const response = await this.request({
            path: `/api/v1/blockchains`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(BlockchainInfoFromJSON));
    }

    /**
     * Lists all supported blockchains.
     */
    async getBlockchains(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<BlockchainInfo>> {
        const response = await this.getBlockchainsRaw(initOverrides);
        return await response.value();
    }

    /**
     * Get a collection by its contract address.
     */
    async getCollectionRaw(requestParameters: GetCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Collection>>> {
        if (requestParameters.contractAddress === null || requestParameters.contractAddress === undefined) {
            throw new runtime.RequiredError('contractAddress','Required parameter requestParameters.contractAddress was null or undefined when calling getCollection.');
        }

        const queryParameters: any = {};

        if (requestParameters.chainID !== undefined) {
            queryParameters['chainID'] = requestParameters.chainID;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["apikey"] = this.configuration.apiKey("apikey"); // apikey authentication
        }

        const response = await this.request({
            path: `/api/v1/collections/{contractAddress}`.replace(`{${"contractAddress"}}`, encodeURIComponent(String(requestParameters.contractAddress))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CollectionFromJSON));
    }

    /**
     * Get a collection by its contract address.
     */
    async getCollection(requestParameters: GetCollectionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Collection>> {
        const response = await this.getCollectionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get tokens by contract address.
     */
    async getContractTokensRaw(requestParameters: GetContractTokensRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Token>>> {
        if (requestParameters.contractAddress === null || requestParameters.contractAddress === undefined) {
            throw new runtime.RequiredError('contractAddress','Required parameter requestParameters.contractAddress was null or undefined when calling getContractTokens.');
        }

        const queryParameters: any = {};

        if (requestParameters.chainID !== undefined) {
            queryParameters['chainID'] = requestParameters.chainID;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["apikey"] = this.configuration.apiKey("apikey"); // apikey authentication
        }

        const response = await this.request({
            path: `/api/v1/tokens/{contractAddress}`.replace(`{${"contractAddress"}}`, encodeURIComponent(String(requestParameters.contractAddress))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TokenFromJSON));
    }

    /**
     * Get tokens by contract address.
     */
    async getContractTokens(requestParameters: GetContractTokensRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Token>> {
        const response = await this.getContractTokensRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get tokens by a pair of contract addresses and token IDs. The input are two ordered arrays. The first element of contractAddresses should be related to the 1st element of the tokenID, etc. In the below example two tokens are being requested, token 3481 from the \"goblintown\" contract (i.e. 0xbce3781ae7ca1a5e050bd9c4c77369867ebc307e) and token 50603 from the Otherdeed contract (i.e. 0x34d85c9cdeb23fa97cb08333b511ac86e1c4e258).
     */
    async getContractTokensByContractAndIDRaw(requestParameters: GetContractTokensByContractAndIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Token>>> {
        if (requestParameters.contractAddresses === null || requestParameters.contractAddresses === undefined) {
            throw new runtime.RequiredError('contractAddresses','Required parameter requestParameters.contractAddresses was null or undefined when calling getContractTokensByContractAndID.');
        }

        if (requestParameters.tokenIdentifiers === null || requestParameters.tokenIdentifiers === undefined) {
            throw new runtime.RequiredError('tokenIdentifiers','Required parameter requestParameters.tokenIdentifiers was null or undefined when calling getContractTokensByContractAndID.');
        }

        const queryParameters: any = {};

        if (requestParameters.contractAddresses !== undefined) {
            queryParameters['contractAddresses'] = requestParameters.contractAddresses;
        }

        if (requestParameters.tokenIdentifiers !== undefined) {
            queryParameters['tokenIdentifiers'] = requestParameters.tokenIdentifiers;
        }

        if (requestParameters.chainID !== undefined) {
            queryParameters['chainID'] = requestParameters.chainID;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["apikey"] = this.configuration.apiKey("apikey"); // apikey authentication
        }

        const response = await this.request({
            path: `/api/v1/token-batch`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TokenFromJSON));
    }

    /**
     * Get tokens by a pair of contract addresses and token IDs. The input are two ordered arrays. The first element of contractAddresses should be related to the 1st element of the tokenID, etc. In the below example two tokens are being requested, token 3481 from the \"goblintown\" contract (i.e. 0xbce3781ae7ca1a5e050bd9c4c77369867ebc307e) and token 50603 from the Otherdeed contract (i.e. 0x34d85c9cdeb23fa97cb08333b511ac86e1c4e258).
     */
    async getContractTokensByContractAndID(requestParameters: GetContractTokensByContractAndIDRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Token>> {
        const response = await this.getContractTokensByContractAndIDRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get the transaction history for a collection
     */
    async getContractTransactionHistoryRaw(requestParameters: GetContractTransactionHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Transaction>>> {
        if (requestParameters.contractAddress === null || requestParameters.contractAddress === undefined) {
            throw new runtime.RequiredError('contractAddress','Required parameter requestParameters.contractAddress was null or undefined when calling getContractTransactionHistory.');
        }

        const queryParameters: any = {};

        if (requestParameters.cursor !== undefined) {
            queryParameters['cursor'] = requestParameters.cursor;
        }

        if (requestParameters.chainID !== undefined) {
            queryParameters['chainID'] = requestParameters.chainID;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["apikey"] = this.configuration.apiKey("apikey"); // apikey authentication
        }

        const response = await this.request({
            path: `/api/v1/collections/{contractAddress}/transactions/history`.replace(`{${"contractAddress"}}`, encodeURIComponent(String(requestParameters.contractAddress))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TransactionFromJSON));
    }

    /**
     * Get the transaction history for a collection
     */
    async getContractTransactionHistory(requestParameters: GetContractTransactionHistoryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Transaction>> {
        const response = await this.getContractTransactionHistoryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get search results such as wallets, tokens, and collections by a search query.
     */
    async getSearchResultsRaw(requestParameters: GetSearchResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<SearchDocument>>> {
        if (requestParameters.query === null || requestParameters.query === undefined) {
            throw new runtime.RequiredError('query','Required parameter requestParameters.query was null or undefined when calling getSearchResults.');
        }

        const queryParameters: any = {};

        if (requestParameters.cursor !== undefined) {
            queryParameters['cursor'] = requestParameters.cursor;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["apikey"] = this.configuration.apiKey("apikey"); // apikey authentication
        }

        const response = await this.request({
            path: `/api/v1/search/{query}`.replace(`{${"query"}}`, encodeURIComponent(String(requestParameters.query))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SearchDocumentFromJSON));
    }

    /**
     * Get search results such as wallets, tokens, and collections by a search query.
     */
    async getSearchResults(requestParameters: GetSearchResultsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<SearchDocument>> {
        const response = await this.getSearchResultsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of tokens sold by a wallet.
     */
    async getSoldTokensRaw(requestParameters: GetSoldTokensRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Token>>> {
        if (requestParameters.walletAddress === null || requestParameters.walletAddress === undefined) {
            throw new runtime.RequiredError('walletAddress','Required parameter requestParameters.walletAddress was null or undefined when calling getSoldTokens.');
        }

        const queryParameters: any = {};

        if (requestParameters.chainID !== undefined) {
            queryParameters['chainID'] = requestParameters.chainID;
        }

        if (requestParameters.cursor !== undefined) {
            queryParameters['cursor'] = requestParameters.cursor;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["apikey"] = this.configuration.apiKey("apikey"); // apikey authentication
        }

        const response = await this.request({
            path: `/api/v1/wallets/{walletAddress}/sold-tokens`.replace(`{${"walletAddress"}}`, encodeURIComponent(String(requestParameters.walletAddress))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TokenFromJSON));
    }

    /**
     * Returns a list of tokens sold by a wallet.
     */
    async getSoldTokens(requestParameters: GetSoldTokensRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Token>> {
        const response = await this.getSoldTokensRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a token by its contract address and token ID.
     */
    async getTokenRaw(requestParameters: GetTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Token>>> {
        if (requestParameters.contractAddress === null || requestParameters.contractAddress === undefined) {
            throw new runtime.RequiredError('contractAddress','Required parameter requestParameters.contractAddress was null or undefined when calling getToken.');
        }

        if (requestParameters.tokenID === null || requestParameters.tokenID === undefined) {
            throw new runtime.RequiredError('tokenID','Required parameter requestParameters.tokenID was null or undefined when calling getToken.');
        }

        const queryParameters: any = {};

        if (requestParameters.chainID !== undefined) {
            queryParameters['chainID'] = requestParameters.chainID;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["apikey"] = this.configuration.apiKey("apikey"); // apikey authentication
        }

        const response = await this.request({
            path: `/api/v1/tokens/{contractAddress}/{tokenID}`.replace(`{${"contractAddress"}}`, encodeURIComponent(String(requestParameters.contractAddress))).replace(`{${"tokenID"}}`, encodeURIComponent(String(requestParameters.tokenID))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TokenFromJSON));
    }

    /**
     * Get a token by its contract address and token ID.
     */
    async getToken(requestParameters: GetTokenRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Token>> {
        const response = await this.getTokenRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Determine if a wallet has a given token from a contract.
     */
    async getTokenGateRaw(requestParameters: GetTokenGateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TokenGate>> {
        if (requestParameters.tokenID === null || requestParameters.tokenID === undefined) {
            throw new runtime.RequiredError('tokenID','Required parameter requestParameters.tokenID was null or undefined when calling getTokenGate.');
        }

        if (requestParameters.contractAddress === null || requestParameters.contractAddress === undefined) {
            throw new runtime.RequiredError('contractAddress','Required parameter requestParameters.contractAddress was null or undefined when calling getTokenGate.');
        }

        if (requestParameters.walletAddress === null || requestParameters.walletAddress === undefined) {
            throw new runtime.RequiredError('walletAddress','Required parameter requestParameters.walletAddress was null or undefined when calling getTokenGate.');
        }

        const queryParameters: any = {};

        if (requestParameters.chainID !== undefined) {
            queryParameters['chainID'] = requestParameters.chainID;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["apikey"] = this.configuration.apiKey("apikey"); // apikey authentication
        }

        const response = await this.request({
            path: `/api/v1/wallets/{walletAddress}/gate/{contractAddress}/{tokenID}`.replace(`{${"tokenID"}}`, encodeURIComponent(String(requestParameters.tokenID))).replace(`{${"contractAddress"}}`, encodeURIComponent(String(requestParameters.contractAddress))).replace(`{${"walletAddress"}}`, encodeURIComponent(String(requestParameters.walletAddress))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TokenGateFromJSON(jsonValue));
    }

    /**
     * Determine if a wallet has a given token from a contract.
     */
    async getTokenGate(requestParameters: GetTokenGateRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TokenGate> {
        const response = await this.getTokenGateRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of transfer transactions on a specified token.
     */
    async getTokenTransfersRaw(requestParameters: GetTokenTransfersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<TokenEvents>> {
        if (requestParameters.contractAddress === null || requestParameters.contractAddress === undefined) {
            throw new runtime.RequiredError('contractAddress','Required parameter requestParameters.contractAddress was null or undefined when calling getTokenTransfers.');
        }

        if (requestParameters.tokenID === null || requestParameters.tokenID === undefined) {
            throw new runtime.RequiredError('tokenID','Required parameter requestParameters.tokenID was null or undefined when calling getTokenTransfers.');
        }

        const queryParameters: any = {};

        if (requestParameters.chainID !== undefined) {
            queryParameters['chainID'] = requestParameters.chainID;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["apikey"] = this.configuration.apiKey("apikey"); // apikey authentication
        }

        const response = await this.request({
            path: `/api/v1/tokens/{contractAddress}/{tokenID}/transfers`.replace(`{${"contractAddress"}}`, encodeURIComponent(String(requestParameters.contractAddress))).replace(`{${"tokenID"}}`, encodeURIComponent(String(requestParameters.tokenID))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => TokenEventsFromJSON(jsonValue));
    }

    /**
     * Returns a list of transfer transactions on a specified token.
     */
    async getTokenTransfers(requestParameters: GetTokenTransfersRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<TokenEvents> {
        const response = await this.getTokenTransfersRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get tokens by a search query.
     */
    async getTokensBySearchQueryRaw(requestParameters: GetTokensBySearchQueryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Token>>> {
        if (requestParameters.query === null || requestParameters.query === undefined) {
            throw new runtime.RequiredError('query','Required parameter requestParameters.query was null or undefined when calling getTokensBySearchQuery.');
        }

        const queryParameters: any = {};

        if (requestParameters.cursor !== undefined) {
            queryParameters['cursor'] = requestParameters.cursor;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["apikey"] = this.configuration.apiKey("apikey"); // apikey authentication
        }

        const response = await this.request({
            path: `/api/v1/tokens/search/{query}`.replace(`{${"query"}}`, encodeURIComponent(String(requestParameters.query))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TokenFromJSON));
    }

    /**
     * Get tokens by a search query.
     */
    async getTokensBySearchQuery(requestParameters: GetTokensBySearchQueryRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Token>> {
        const response = await this.getTokensBySearchQueryRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Get a wallet by a wallet address
     */
    async getWalletRaw(requestParameters: GetWalletRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Wallet>>> {
        if (requestParameters.walletAddress === null || requestParameters.walletAddress === undefined) {
            throw new runtime.RequiredError('walletAddress','Required parameter requestParameters.walletAddress was null or undefined when calling getWallet.');
        }

        const queryParameters: any = {};

        if (requestParameters.chainID !== undefined) {
            queryParameters['chainID'] = requestParameters.chainID;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["apikey"] = this.configuration.apiKey("apikey"); // apikey authentication
        }

        const response = await this.request({
            path: `/api/v1/wallets/{walletAddress}`.replace(`{${"walletAddress"}}`, encodeURIComponent(String(requestParameters.walletAddress))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(WalletFromJSON));
    }

    /**
     * Get a wallet by a wallet address
     */
    async getWallet(requestParameters: GetWalletRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Wallet>> {
        const response = await this.getWalletRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of balances for tokens this wallet currently owns.
     */
    async getWalletBalancesRaw(requestParameters: GetWalletBalancesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<CurrencyInfo>>> {
        if (requestParameters.walletAddress === null || requestParameters.walletAddress === undefined) {
            throw new runtime.RequiredError('walletAddress','Required parameter requestParameters.walletAddress was null or undefined when calling getWalletBalances.');
        }

        const queryParameters: any = {};

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["apikey"] = this.configuration.apiKey("apikey"); // apikey authentication
        }

        const response = await this.request({
            path: `/api/v1/wallets/{walletAddress}/balances`.replace(`{${"walletAddress"}}`, encodeURIComponent(String(requestParameters.walletAddress))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(CurrencyInfoFromJSON));
    }

    /**
     * Returns a list of balances for tokens this wallet currently owns.
     */
    async getWalletBalances(requestParameters: GetWalletBalancesRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<CurrencyInfo>> {
        const response = await this.getWalletBalancesRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of tokens minted by a wallet.
     */
    async getWalletMintsRaw(requestParameters: GetWalletMintsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Token>>> {
        if (requestParameters.walletAddress === null || requestParameters.walletAddress === undefined) {
            throw new runtime.RequiredError('walletAddress','Required parameter requestParameters.walletAddress was null or undefined when calling getWalletMints.');
        }

        const queryParameters: any = {};

        if (requestParameters.chainID !== undefined) {
            queryParameters['chainID'] = requestParameters.chainID;
        }

        if (requestParameters.cursor !== undefined) {
            queryParameters['cursor'] = requestParameters.cursor;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["apikey"] = this.configuration.apiKey("apikey"); // apikey authentication
        }

        const response = await this.request({
            path: `/api/v1/wallets/{walletAddress}/mints`.replace(`{${"walletAddress"}}`, encodeURIComponent(String(requestParameters.walletAddress))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TokenFromJSON));
    }

    /**
     * Returns a list of tokens minted by a wallet.
     */
    async getWalletMints(requestParameters: GetWalletMintsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Token>> {
        const response = await this.getWalletMintsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of tokens owned by a wallet.
     */
    async getWalletTokensRaw(requestParameters: GetWalletTokensRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Token>>> {
        if (requestParameters.walletAddress === null || requestParameters.walletAddress === undefined) {
            throw new runtime.RequiredError('walletAddress','Required parameter requestParameters.walletAddress was null or undefined when calling getWalletTokens.');
        }

        const queryParameters: any = {};

        if (requestParameters.cursor !== undefined) {
            queryParameters['cursor'] = requestParameters.cursor;
        }

        if (requestParameters.chainID !== undefined) {
            queryParameters['chainID'] = requestParameters.chainID;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["apikey"] = this.configuration.apiKey("apikey"); // apikey authentication
        }

        const response = await this.request({
            path: `/api/v1/wallets/{walletAddress}/tokens`.replace(`{${"walletAddress"}}`, encodeURIComponent(String(requestParameters.walletAddress))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TokenFromJSON));
    }

    /**
     * Returns a list of tokens owned by a wallet.
     */
    async getWalletTokens(requestParameters: GetWalletTokensRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Token>> {
        const response = await this.getWalletTokensRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of transactions that have been performed by this wallet. Use token type to restrict to only certain transactions, such as NFTs
     */
    async getWalletTransactionsRaw(requestParameters: GetWalletTransactionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Array<Transaction>>> {
        if (requestParameters.walletAddress === null || requestParameters.walletAddress === undefined) {
            throw new runtime.RequiredError('walletAddress','Required parameter requestParameters.walletAddress was null or undefined when calling getWalletTransactions.');
        }

        const queryParameters: any = {};

        if (requestParameters.cursor !== undefined) {
            queryParameters['cursor'] = requestParameters.cursor;
        }

        if (requestParameters.limit !== undefined) {
            queryParameters['limit'] = requestParameters.limit;
        }

        if (requestParameters.chainID !== undefined) {
            queryParameters['chainID'] = requestParameters.chainID;
        }

        if (requestParameters.tokenType !== undefined) {
            queryParameters['tokenType'] = requestParameters.tokenType;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.apiKey) {
            queryParameters["apikey"] = this.configuration.apiKey("apikey"); // apikey authentication
        }

        const response = await this.request({
            path: `/api/v1/wallets/{walletAddress}/transactions/history`.replace(`{${"walletAddress"}}`, encodeURIComponent(String(requestParameters.walletAddress))),
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(TransactionFromJSON));
    }

    /**
     * Returns a list of transactions that have been performed by this wallet. Use token type to restrict to only certain transactions, such as NFTs
     */
    async getWalletTransactions(requestParameters: GetWalletTransactionsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Array<Transaction>> {
        const response = await this.getWalletTransactionsRaw(requestParameters, initOverrides);
        return await response.value();
    }

}

/**
 * @export
 */
export const GetWalletTransactionsTokenTypeEnum = {
    Nft: 'NFT',
    Sft: 'SFT',
    Unknown: 'unknown'
} as const;
export type GetWalletTransactionsTokenTypeEnum = typeof GetWalletTransactionsTokenTypeEnum[keyof typeof GetWalletTransactionsTokenTypeEnum];
